function GM(t, e) {
  for (var n = 0; n < e.length; n++) {
    const i = e[n];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in t)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              t,
              r,
              s.get
                ? s
                : {
                    enumerable: !0,
                    get: () => i[r],
                  }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module",
    })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const a of s.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && i(a);
  }).observe(document, {
    childList: !0,
    subtree: !0,
  });
  function n(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = n(r);
    fetch(r.href, s);
  }
})();
var ri =
  typeof globalThis < "u"
    ? globalThis
    : typeof window < "u"
    ? window
    : typeof global < "u"
    ? global
    : typeof self < "u"
    ? self
    : {};
function WM(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default")
    ? t.default
    : t;
}
function $M(t) {
  if (t.__esModule) return t;
  var e = t.default;
  if (typeof e == "function") {
    var n = function i() {
      return this instanceof i
        ? Reflect.construct(e, arguments, this.constructor)
        : e.apply(this, arguments);
    };
    n.prototype = e.prototype;
  } else n = {};
  return (
    Object.defineProperty(n, "__esModule", {
      value: !0,
    }),
    Object.keys(t).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(t, i);
      Object.defineProperty(
        n,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return t[i];
              },
            }
      );
    }),
    n
  );
}
var gS = {
    exports: {},
  },
  Hd = {},
  vS = {
    exports: {},
  },
  Qe = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var fc = Symbol.for("react.element"),
  XM = Symbol.for("react.portal"),
  qM = Symbol.for("react.fragment"),
  YM = Symbol.for("react.strict_mode"),
  ZM = Symbol.for("react.profiler"),
  KM = Symbol.for("react.provider"),
  JM = Symbol.for("react.context"),
  QM = Symbol.for("react.forward_ref"),
  eb = Symbol.for("react.suspense"),
  tb = Symbol.for("react.memo"),
  nb = Symbol.for("react.lazy"),
  Fv = Symbol.iterator;
function ib(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Fv && t[Fv]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var _S = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  yS = Object.assign,
  xS = {};
function Mo(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = xS),
    (this.updater = n || _S);
}
Mo.prototype.isReactComponent = {};
Mo.prototype.setState = function (t, e) {
  if (typeof t != "object" && typeof t != "function" && t != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, t, e, "setState");
};
Mo.prototype.forceUpdate = function (t) {
  this.updater.enqueueForceUpdate(this, t, "forceUpdate");
};
function SS() {}
SS.prototype = Mo.prototype;
function Gm(t, e, n) {
  (this.props = t),
    (this.context = e),
    (this.refs = xS),
    (this.updater = n || _S);
}
var Wm = (Gm.prototype = new SS());
Wm.constructor = Gm;
yS(Wm, Mo.prototype);
Wm.isPureReactComponent = !0;
var Bv = Array.isArray,
  wS = Object.prototype.hasOwnProperty,
  $m = {
    current: null,
  },
  ES = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0,
  };
function TS(t, e, n) {
  var i,
    r = {},
    s = null,
    a = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (a = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      wS.call(e, i) && !ES.hasOwnProperty(i) && (r[i] = e[i]);
  var o = arguments.length - 2;
  if (o === 1) r.children = n;
  else if (1 < o) {
    for (var l = Array(o), c = 0; c < o; c++) l[c] = arguments[c + 2];
    r.children = l;
  }
  if (t && t.defaultProps)
    for (i in ((o = t.defaultProps), o)) r[i] === void 0 && (r[i] = o[i]);
  return {
    $$typeof: fc,
    type: t,
    key: s,
    ref: a,
    props: r,
    _owner: $m.current,
  };
}
function rb(t, e) {
  return {
    $$typeof: fc,
    type: t.type,
    key: e,
    ref: t.ref,
    props: t.props,
    _owner: t._owner,
  };
}
function Xm(t) {
  return typeof t == "object" && t !== null && t.$$typeof === fc;
}
function sb(t) {
  var e = {
    "=": "=0",
    ":": "=2",
  };
  return (
    "$" +
    t.replace(/[=:]/g, function (n) {
      return e[n];
    })
  );
}
var zv = /\/+/g;
function Lh(t, e) {
  return typeof t == "object" && t !== null && t.key != null
    ? sb("" + t.key)
    : e.toString(36);
}
function Pu(t, e, n, i, r) {
  var s = typeof t;
  (s === "undefined" || s === "boolean") && (t = null);
  var a = !1;
  if (t === null) a = !0;
  else
    switch (s) {
      case "string":
      case "number":
        a = !0;
        break;
      case "object":
        switch (t.$$typeof) {
          case fc:
          case XM:
            a = !0;
        }
    }
  if (a)
    return (
      (a = t),
      (r = r(a)),
      (t = i === "" ? "." + Lh(a, 0) : i),
      Bv(r)
        ? ((n = ""),
          t != null && (n = t.replace(zv, "$&/") + "/"),
          Pu(r, e, n, "", function (c) {
            return c;
          }))
        : r != null &&
          (Xm(r) &&
            (r = rb(
              r,
              n +
                (!r.key || (a && a.key === r.key)
                  ? ""
                  : ("" + r.key).replace(zv, "$&/") + "/") +
                t
            )),
          e.push(r)),
      1
    );
  if (((a = 0), (i = i === "" ? "." : i + ":"), Bv(t)))
    for (var o = 0; o < t.length; o++) {
      s = t[o];
      var l = i + Lh(s, o);
      a += Pu(s, e, n, l, r);
    }
  else if (((l = ib(t)), typeof l == "function"))
    for (t = l.call(t), o = 0; !(s = t.next()).done; )
      (s = s.value), (l = i + Lh(s, o++)), (a += Pu(s, e, n, l, r));
  else if (s === "object")
    throw (
      ((e = String(t)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(t).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return a;
}
function kc(t, e, n) {
  if (t == null) return t;
  var i = [],
    r = 0;
  return (
    Pu(t, i, "", "", function (s) {
      return e.call(n, s, r++);
    }),
    i
  );
}
function ab(t) {
  if (t._status === -1) {
    var e = t._result;
    (e = e()),
      e.then(
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 1), (t._result = n));
        },
        function (n) {
          (t._status === 0 || t._status === -1) &&
            ((t._status = 2), (t._result = n));
        }
      ),
      t._status === -1 && ((t._status = 0), (t._result = e));
  }
  if (t._status === 1) return t._result.default;
  throw t._result;
}
var Sn = {
    current: null,
  },
  Lu = {
    transition: null,
  },
  ob = {
    ReactCurrentDispatcher: Sn,
    ReactCurrentBatchConfig: Lu,
    ReactCurrentOwner: $m,
  };
function MS() {
  throw Error("act(...) is not supported in production builds of React.");
}
Qe.Children = {
  map: kc,
  forEach: function (t, e, n) {
    kc(
      t,
      function () {
        e.apply(this, arguments);
      },
      n
    );
  },
  count: function (t) {
    var e = 0;
    return (
      kc(t, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (t) {
    return (
      kc(t, function (e) {
        return e;
      }) || []
    );
  },
  only: function (t) {
    if (!Xm(t))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return t;
  },
};
Qe.Component = Mo;
Qe.Fragment = qM;
Qe.Profiler = ZM;
Qe.PureComponent = Gm;
Qe.StrictMode = YM;
Qe.Suspense = eb;
Qe.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ob;
Qe.act = MS;
Qe.cloneElement = function (t, e, n) {
  if (t == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        t +
        "."
    );
  var i = yS({}, t.props),
    r = t.key,
    s = t.ref,
    a = t._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (a = $m.current)),
      e.key !== void 0 && (r = "" + e.key),
      t.type && t.type.defaultProps)
    )
      var o = t.type.defaultProps;
    for (l in e)
      wS.call(e, l) &&
        !ES.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && o !== void 0 ? o[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = n;
  else if (1 < l) {
    o = Array(l);
    for (var c = 0; c < l; c++) o[c] = arguments[c + 2];
    i.children = o;
  }
  return {
    $$typeof: fc,
    type: t.type,
    key: r,
    ref: s,
    props: i,
    _owner: a,
  };
};
Qe.createContext = function (t) {
  return (
    (t = {
      $$typeof: JM,
      _currentValue: t,
      _currentValue2: t,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (t.Provider = {
      $$typeof: KM,
      _context: t,
    }),
    (t.Consumer = t)
  );
};
Qe.createElement = TS;
Qe.createFactory = function (t) {
  var e = TS.bind(null, t);
  return (e.type = t), e;
};
Qe.createRef = function () {
  return {
    current: null,
  };
};
Qe.forwardRef = function (t) {
  return {
    $$typeof: QM,
    render: t,
  };
};
Qe.isValidElement = Xm;
Qe.lazy = function (t) {
  return {
    $$typeof: nb,
    _payload: {
      _status: -1,
      _result: t,
    },
    _init: ab,
  };
};
Qe.memo = function (t, e) {
  return {
    $$typeof: tb,
    type: t,
    compare: e === void 0 ? null : e,
  };
};
Qe.startTransition = function (t) {
  var e = Lu.transition;
  Lu.transition = {};
  try {
    t();
  } finally {
    Lu.transition = e;
  }
};
Qe.unstable_act = MS;
Qe.useCallback = function (t, e) {
  return Sn.current.useCallback(t, e);
};
Qe.useContext = function (t) {
  return Sn.current.useContext(t);
};
Qe.useDebugValue = function () {};
Qe.useDeferredValue = function (t) {
  return Sn.current.useDeferredValue(t);
};
Qe.useEffect = function (t, e) {
  return Sn.current.useEffect(t, e);
};
Qe.useId = function () {
  return Sn.current.useId();
};
Qe.useImperativeHandle = function (t, e, n) {
  return Sn.current.useImperativeHandle(t, e, n);
};
Qe.useInsertionEffect = function (t, e) {
  return Sn.current.useInsertionEffect(t, e);
};
Qe.useLayoutEffect = function (t, e) {
  return Sn.current.useLayoutEffect(t, e);
};
Qe.useMemo = function (t, e) {
  return Sn.current.useMemo(t, e);
};
Qe.useReducer = function (t, e, n) {
  return Sn.current.useReducer(t, e, n);
};
Qe.useRef = function (t) {
  return Sn.current.useRef(t);
};
Qe.useState = function (t) {
  return Sn.current.useState(t);
};
Qe.useSyncExternalStore = function (t, e, n) {
  return Sn.current.useSyncExternalStore(t, e, n);
};
Qe.useTransition = function () {
  return Sn.current.useTransition();
};
Qe.version = "18.3.1";
vS.exports = Qe;
var O = vS.exports;
const lb = WM(O),
  cb = GM(
    {
      __proto__: null,
      default: lb,
    },
    [O]
  );
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var ub = O,
  db = Symbol.for("react.element"),
  hb = Symbol.for("react.fragment"),
  fb = Object.prototype.hasOwnProperty,
  pb = ub.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  mb = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0,
  };
function bS(t, e, n) {
  var i,
    r = {},
    s = null,
    a = null;
  n !== void 0 && (s = "" + n),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (a = e.ref);
  for (i in e) fb.call(e, i) && !mb.hasOwnProperty(i) && (r[i] = e[i]);
  if (t && t.defaultProps)
    for (i in ((e = t.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: db,
    type: t,
    key: s,
    ref: a,
    props: r,
    _owner: pb.current,
  };
}
Hd.Fragment = hb;
Hd.jsx = bS;
Hd.jsxs = bS;
gS.exports = Hd;
var _ = gS.exports,
  AS = {
    exports: {},
  },
  $n = {},
  CS = {
    exports: {},
  },
  RS = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

(function (t) {
  function e(L, U) {
    var X = L.length;
    L.push(U);
    e: for (; 0 < X; ) {
      var K = (X - 1) >>> 1,
        oe = L[K];
      if (0 < r(oe, U)) (L[K] = U), (L[X] = oe), (X = K);
      else break e;
    }
  }
  function n(L) {
    return L.length === 0 ? null : L[0];
  }
  function i(L) {
    if (L.length === 0) return null;
    var U = L[0],
      X = L.pop();
    if (X !== U) {
      L[0] = X;
      e: for (var K = 0, oe = L.length, ke = oe >>> 1; K < ke; ) {
        var V = 2 * (K + 1) - 1,
          Q = L[V],
          he = V + 1,
          Re = L[he];
        if (0 > r(Q, X))
          he < oe && 0 > r(Re, Q)
            ? ((L[K] = Re), (L[he] = X), (K = he))
            : ((L[K] = Q), (L[V] = X), (K = V));
        else if (he < oe && 0 > r(Re, X)) (L[K] = Re), (L[he] = X), (K = he);
        else break e;
      }
    }
    return U;
  }
  function r(L, U) {
    var X = L.sortIndex - U.sortIndex;
    return X !== 0 ? X : L.id - U.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    t.unstable_now = function () {
      return s.now();
    };
  } else {
    var a = Date,
      o = a.now();
    t.unstable_now = function () {
      return a.now() - o;
    };
  }
  var l = [],
    c = [],
    u = 1,
    d = null,
    h = 3,
    p = !1,
    v = !1,
    x = !1,
    m = typeof setTimeout == "function" ? setTimeout : null,
    f = typeof clearTimeout == "function" ? clearTimeout : null,
    y = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function g(L) {
    for (var U = n(c); U !== null; ) {
      if (U.callback === null) i(c);
      else if (U.startTime <= L)
        i(c), (U.sortIndex = U.expirationTime), e(l, U);
      else break;
      U = n(c);
    }
  }
  function S(L) {
    if (((x = !1), g(L), !v))
      if (n(l) !== null) (v = !0), q(T);
      else {
        var U = n(c);
        U !== null && W(S, U.startTime - L);
      }
  }
  function T(L, U) {
    (v = !1), x && ((x = !1), f(P), (P = -1)), (p = !0);
    var X = h;
    try {
      for (
        g(U), d = n(l);
        d !== null && (!(d.expirationTime > U) || (L && !R()));

      ) {
        var K = d.callback;
        if (typeof K == "function") {
          (d.callback = null), (h = d.priorityLevel);
          var oe = K(d.expirationTime <= U);
          (U = t.unstable_now()),
            typeof oe == "function" ? (d.callback = oe) : d === n(l) && i(l),
            g(U);
        } else i(l);
        d = n(l);
      }
      if (d !== null) var ke = !0;
      else {
        var V = n(c);
        V !== null && W(S, V.startTime - U), (ke = !1);
      }
      return ke;
    } finally {
      (d = null), (h = X), (p = !1);
    }
  }
  var A = !1,
    b = null,
    P = -1,
    G = 5,
    w = -1;
  function R() {
    return !(t.unstable_now() - w < G);
  }
  function ie() {
    if (b !== null) {
      var L = t.unstable_now();
      w = L;
      var U = !0;
      try {
        U = b(!0, L);
      } finally {
        U ? J() : ((A = !1), (b = null));
      }
    } else A = !1;
  }
  var J;
  if (typeof y == "function")
    J = function () {
      y(ie);
    };
  else if (typeof MessageChannel < "u") {
    var D = new MessageChannel(),
      Y = D.port2;
    (D.port1.onmessage = ie),
      (J = function () {
        Y.postMessage(null);
      });
  } else
    J = function () {
      m(ie, 0);
    };
  function q(L) {
    (b = L), A || ((A = !0), J());
  }
  function W(L, U) {
    P = m(function () {
      L(t.unstable_now());
    }, U);
  }
  (t.unstable_IdlePriority = 5),
    (t.unstable_ImmediatePriority = 1),
    (t.unstable_LowPriority = 4),
    (t.unstable_NormalPriority = 3),
    (t.unstable_Profiling = null),
    (t.unstable_UserBlockingPriority = 2),
    (t.unstable_cancelCallback = function (L) {
      L.callback = null;
    }),
    (t.unstable_continueExecution = function () {
      v || p || ((v = !0), q(T));
    }),
    (t.unstable_forceFrameRate = function (L) {
      0 > L || 125 < L
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (G = 0 < L ? Math.floor(1e3 / L) : 5);
    }),
    (t.unstable_getCurrentPriorityLevel = function () {
      return h;
    }),
    (t.unstable_getFirstCallbackNode = function () {
      return n(l);
    }),
    (t.unstable_next = function (L) {
      switch (h) {
        case 1:
        case 2:
        case 3:
          var U = 3;
          break;
        default:
          U = h;
      }
      var X = h;
      h = U;
      try {
        return L();
      } finally {
        h = X;
      }
    }),
    (t.unstable_pauseExecution = function () {}),
    (t.unstable_requestPaint = function () {}),
    (t.unstable_runWithPriority = function (L, U) {
      switch (L) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          L = 3;
      }
      var X = h;
      h = L;
      try {
        return U();
      } finally {
        h = X;
      }
    }),
    (t.unstable_scheduleCallback = function (L, U, X) {
      var K = t.unstable_now();
      switch (
        (typeof X == "object" && X !== null
          ? ((X = X.delay), (X = typeof X == "number" && 0 < X ? K + X : K))
          : (X = K),
        L)
      ) {
        case 1:
          var oe = -1;
          break;
        case 2:
          oe = 250;
          break;
        case 5:
          oe = 1073741823;
          break;
        case 4:
          oe = 1e4;
          break;
        default:
          oe = 5e3;
      }
      return (
        (oe = X + oe),
        (L = {
          id: u++,
          callback: U,
          priorityLevel: L,
          startTime: X,
          expirationTime: oe,
          sortIndex: -1,
        }),
        X > K
          ? ((L.sortIndex = X),
            e(c, L),
            n(l) === null &&
              L === n(c) &&
              (x ? (f(P), (P = -1)) : (x = !0), W(S, X - K)))
          : ((L.sortIndex = oe), e(l, L), v || p || ((v = !0), q(T))),
        L
      );
    }),
    (t.unstable_shouldYield = R),
    (t.unstable_wrapCallback = function (L) {
      var U = h;
      return function () {
        var X = h;
        h = U;
        try {
          return L.apply(this, arguments);
        } finally {
          h = X;
        }
      };
    });
})(RS);
CS.exports = RS;
var gb = CS.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var vb = O,
  Gn = gb;
function ne(t) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1;
    n < arguments.length;
    n++
  )
    e += "&args[]=" + encodeURIComponent(arguments[n]);
  return (
    "Minified React error #" +
    t +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var PS = new Set(),
  Rl = {};
function na(t, e) {
  ao(t, e), ao(t + "Capture", e);
}
function ao(t, e) {
  for (Rl[t] = e, t = 0; t < e.length; t++) PS.add(e[t]);
}
var dr = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  ap = Object.prototype.hasOwnProperty,
  _b =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  jv = {},
  Vv = {};
function yb(t) {
  return ap.call(Vv, t)
    ? !0
    : ap.call(jv, t)
    ? !1
    : _b.test(t)
    ? (Vv[t] = !0)
    : ((jv[t] = !0), !1);
}
function xb(t, e, n, i) {
  if (n !== null && n.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : n !== null
        ? !n.acceptsBooleans
        : ((t = t.toLowerCase().slice(0, 5)), t !== "data-" && t !== "aria-");
    default:
      return !1;
  }
}
function Sb(t, e, n, i) {
  if (e === null || typeof e > "u" || xb(t, e, n, i)) return !0;
  if (i) return !1;
  if (n !== null)
    switch (n.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function wn(t, e, n, i, r, s, a) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = n),
    (this.propertyName = t),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = a);
}
var tn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (t) {
    tn[t] = new wn(t, 0, !1, t, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (t) {
  var e = t[0];
  tn[e] = new wn(e, 1, !1, t[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) {
  tn[t] = new wn(t, 2, !1, t.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (t) {
  tn[t] = new wn(t, 2, !1, t, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (t) {
    tn[t] = new wn(t, 3, !1, t.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (t) {
  tn[t] = new wn(t, 3, !0, t, null, !1, !1);
});
["capture", "download"].forEach(function (t) {
  tn[t] = new wn(t, 4, !1, t, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (t) {
  tn[t] = new wn(t, 6, !1, t, null, !1, !1);
});
["rowSpan", "start"].forEach(function (t) {
  tn[t] = new wn(t, 5, !1, t.toLowerCase(), null, !1, !1);
});
var qm = /[\-:]([a-z])/g;
function Ym(t) {
  return t[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(qm, Ym);
    tn[e] = new wn(e, 1, !1, t, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (t) {
    var e = t.replace(qm, Ym);
    tn[e] = new wn(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (t) {
  var e = t.replace(qm, Ym);
  tn[e] = new wn(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (t) {
  tn[t] = new wn(t, 1, !1, t.toLowerCase(), null, !1, !1);
});
tn.xlinkHref = new wn(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (t) {
  tn[t] = new wn(t, 1, !1, t.toLowerCase(), null, !0, !0);
});
function Zm(t, e, n, i) {
  var r = tn.hasOwnProperty(e) ? tn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (Sb(e, n, r, i) && (n = null),
    i || r === null
      ? yb(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n))
      : r.mustUseProperty
      ? (t[r.propertyName] = n === null ? (r.type === 3 ? !1 : "") : n)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        n === null
          ? t.removeAttribute(e)
          : ((r = r.type),
            (n = r === 3 || (r === 4 && n === !0) ? "" : "" + n),
            i ? t.setAttributeNS(i, e, n) : t.setAttribute(e, n))));
}
var vr = vb.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Ic = Symbol.for("react.element"),
  Pa = Symbol.for("react.portal"),
  La = Symbol.for("react.fragment"),
  Km = Symbol.for("react.strict_mode"),
  op = Symbol.for("react.profiler"),
  LS = Symbol.for("react.provider"),
  NS = Symbol.for("react.context"),
  Jm = Symbol.for("react.forward_ref"),
  lp = Symbol.for("react.suspense"),
  cp = Symbol.for("react.suspense_list"),
  Qm = Symbol.for("react.memo"),
  Pr = Symbol.for("react.lazy"),
  DS = Symbol.for("react.offscreen"),
  Hv = Symbol.iterator;
function Oo(t) {
  return t === null || typeof t != "object"
    ? null
    : ((t = (Hv && t[Hv]) || t["@@iterator"]),
      typeof t == "function" ? t : null);
}
var At = Object.assign,
  Nh;
function el(t) {
  if (Nh === void 0)
    try {
      throw Error();
    } catch (n) {
      var e = n.stack.trim().match(/\n( *(at )?)/);
      Nh = (e && e[1]) || "";
    }
  return (
    `
` +
    Nh +
    t
  );
}
var Dh = !1;
function kh(t, e) {
  if (!t || Dh) return "";
  Dh = !0;
  var n = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var i = c;
        }
        Reflect.construct(t, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          i = c;
        }
        t.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        i = c;
      }
      t();
    }
  } catch (c) {
    if (c && i && typeof c.stack == "string") {
      for (
        var r = c.stack.split(`
`),
          s = i.stack.split(`
`),
          a = r.length - 1,
          o = s.length - 1;
        1 <= a && 0 <= o && r[a] !== s[o];

      )
        o--;
      for (; 1 <= a && 0 <= o; a--, o--)
        if (r[a] !== s[o]) {
          if (a !== 1 || o !== 1)
            do
              if ((a--, o--, 0 > o || r[a] !== s[o])) {
                var l =
                  `
` + r[a].replace(" at new ", " at ");
                return (
                  t.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", t.displayName)),
                  l
                );
              }
            while (1 <= a && 0 <= o);
          break;
        }
    }
  } finally {
    (Dh = !1), (Error.prepareStackTrace = n);
  }
  return (t = t ? t.displayName || t.name : "") ? el(t) : "";
}
function wb(t) {
  switch (t.tag) {
    case 5:
      return el(t.type);
    case 16:
      return el("Lazy");
    case 13:
      return el("Suspense");
    case 19:
      return el("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (t = kh(t.type, !1)), t;
    case 11:
      return (t = kh(t.type.render, !1)), t;
    case 1:
      return (t = kh(t.type, !0)), t;
    default:
      return "";
  }
}
function up(t) {
  if (t == null) return null;
  if (typeof t == "function") return t.displayName || t.name || null;
  if (typeof t == "string") return t;
  switch (t) {
    case La:
      return "Fragment";
    case Pa:
      return "Portal";
    case op:
      return "Profiler";
    case Km:
      return "StrictMode";
    case lp:
      return "Suspense";
    case cp:
      return "SuspenseList";
  }
  if (typeof t == "object")
    switch (t.$$typeof) {
      case NS:
        return (t.displayName || "Context") + ".Consumer";
      case LS:
        return (t._context.displayName || "Context") + ".Provider";
      case Jm:
        var e = t.render;
        return (
          (t = t.displayName),
          t ||
            ((t = e.displayName || e.name || ""),
            (t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")),
          t
        );
      case Qm:
        return (
          (e = t.displayName || null), e !== null ? e : up(t.type) || "Memo"
        );
      case Pr:
        (e = t._payload), (t = t._init);
        try {
          return up(t(e));
        } catch {}
    }
  return null;
}
function Eb(t) {
  var e = t.type;
  switch (t.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (t = e.render),
        (t = t.displayName || t.name || ""),
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return up(e);
    case 8:
      return e === Km ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Qr(t) {
  switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return t;
    case "object":
      return t;
    default:
      return "";
  }
}
function kS(t) {
  var e = t.type;
  return (
    (t = t.nodeName) &&
    t.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function Tb(t) {
  var e = kS(t) ? "checked" : "value",
    n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e),
    i = "" + t[e];
  if (
    !t.hasOwnProperty(e) &&
    typeof n < "u" &&
    typeof n.get == "function" &&
    typeof n.set == "function"
  ) {
    var r = n.get,
      s = n.set;
    return (
      Object.defineProperty(t, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (a) {
          (i = "" + a), s.call(this, a);
        },
      }),
      Object.defineProperty(t, e, {
        enumerable: n.enumerable,
      }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (a) {
          i = "" + a;
        },
        stopTracking: function () {
          (t._valueTracker = null), delete t[e];
        },
      }
    );
  }
}
function Uc(t) {
  t._valueTracker || (t._valueTracker = Tb(t));
}
function IS(t) {
  if (!t) return !1;
  var e = t._valueTracker;
  if (!e) return !0;
  var n = e.getValue(),
    i = "";
  return (
    t && (i = kS(t) ? (t.checked ? "true" : "false") : t.value),
    (t = i),
    t !== n ? (e.setValue(t), !0) : !1
  );
}
function Yu(t) {
  if (((t = t || (typeof document < "u" ? document : void 0)), typeof t > "u"))
    return null;
  try {
    return t.activeElement || t.body;
  } catch {
    return t.body;
  }
}
function dp(t, e) {
  var n = e.checked;
  return At({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: n ?? t._wrapperState.initialChecked,
  });
}
function Gv(t, e) {
  var n = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (n = Qr(e.value != null ? e.value : n)),
    (t._wrapperState = {
      initialChecked: i,
      initialValue: n,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function US(t, e) {
  (e = e.checked), e != null && Zm(t, "checked", e, !1);
}
function hp(t, e) {
  US(t, e);
  var n = Qr(e.value),
    i = e.type;
  if (n != null)
    i === "number"
      ? ((n === 0 && t.value === "") || t.value != n) && (t.value = "" + n)
      : t.value !== "" + n && (t.value = "" + n);
  else if (i === "submit" || i === "reset") {
    t.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? fp(t, e.type, n)
    : e.hasOwnProperty("defaultValue") && fp(t, e.type, Qr(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (t.defaultChecked = !!e.defaultChecked);
}
function Wv(t, e, n) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + t._wrapperState.initialValue),
      n || e === t.value || (t.value = e),
      (t.defaultValue = e);
  }
  (n = t.name),
    n !== "" && (t.name = ""),
    (t.defaultChecked = !!t._wrapperState.initialChecked),
    n !== "" && (t.name = n);
}
function fp(t, e, n) {
  (e !== "number" || Yu(t.ownerDocument) !== t) &&
    (n == null
      ? (t.defaultValue = "" + t._wrapperState.initialValue)
      : t.defaultValue !== "" + n && (t.defaultValue = "" + n));
}
var tl = Array.isArray;
function Za(t, e, n, i) {
  if (((t = t.options), e)) {
    e = {};
    for (var r = 0; r < n.length; r++) e["$" + n[r]] = !0;
    for (n = 0; n < t.length; n++)
      (r = e.hasOwnProperty("$" + t[n].value)),
        t[n].selected !== r && (t[n].selected = r),
        r && i && (t[n].defaultSelected = !0);
  } else {
    for (n = "" + Qr(n), e = null, r = 0; r < t.length; r++) {
      if (t[r].value === n) {
        (t[r].selected = !0), i && (t[r].defaultSelected = !0);
        return;
      }
      e !== null || t[r].disabled || (e = t[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function pp(t, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(ne(91));
  return At({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + t._wrapperState.initialValue,
  });
}
function $v(t, e) {
  var n = e.value;
  if (n == null) {
    if (((n = e.children), (e = e.defaultValue), n != null)) {
      if (e != null) throw Error(ne(92));
      if (tl(n)) {
        if (1 < n.length) throw Error(ne(93));
        n = n[0];
      }
      e = n;
    }
    e == null && (e = ""), (n = e);
  }
  t._wrapperState = {
    initialValue: Qr(n),
  };
}
function OS(t, e) {
  var n = Qr(e.value),
    i = Qr(e.defaultValue);
  n != null &&
    ((n = "" + n),
    n !== t.value && (t.value = n),
    e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)),
    i != null && (t.defaultValue = "" + i);
}
function Xv(t) {
  var e = t.textContent;
  e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e);
}
function FS(t) {
  switch (t) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function mp(t, e) {
  return t == null || t === "http://www.w3.org/1999/xhtml"
    ? FS(e)
    : t === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : t;
}
var Oc,
  BS = (function (t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, n, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return t(e, n, i, r);
          });
        }
      : t;
  })(function (t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t)
      t.innerHTML = e;
    else {
      for (
        Oc = Oc || document.createElement("div"),
          Oc.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Oc.firstChild;
        t.firstChild;

      )
        t.removeChild(t.firstChild);
      for (; e.firstChild; ) t.appendChild(e.firstChild);
    }
  });
function Pl(t, e) {
  if (e) {
    var n = t.firstChild;
    if (n && n === t.lastChild && n.nodeType === 3) {
      n.nodeValue = e;
      return;
    }
  }
  t.textContent = e;
}
var dl = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  Mb = ["Webkit", "ms", "Moz", "O"];
Object.keys(dl).forEach(function (t) {
  Mb.forEach(function (e) {
    (e = e + t.charAt(0).toUpperCase() + t.substring(1)), (dl[e] = dl[t]);
  });
});
function zS(t, e, n) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : n || typeof e != "number" || e === 0 || (dl.hasOwnProperty(t) && dl[t])
    ? ("" + e).trim()
    : e + "px";
}
function jS(t, e) {
  t = t.style;
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      var i = n.indexOf("--") === 0,
        r = zS(n, e[n], i);
      n === "float" && (n = "cssFloat"), i ? t.setProperty(n, r) : (t[n] = r);
    }
}
var bb = At(
  {
    menuitem: !0,
  },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function gp(t, e) {
  if (e) {
    if (bb[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(ne(137, t));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(ne(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(ne(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(ne(62));
  }
}
function vp(t, e) {
  if (t.indexOf("-") === -1) return typeof e.is == "string";
  switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var _p = null;
function eg(t) {
  return (
    (t = t.target || t.srcElement || window),
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
  );
}
var yp = null,
  Ka = null,
  Ja = null;
function qv(t) {
  if ((t = gc(t))) {
    if (typeof yp != "function") throw Error(ne(280));
    var e = t.stateNode;
    e && ((e = qd(e)), yp(t.stateNode, t.type, e));
  }
}
function VS(t) {
  Ka ? (Ja ? Ja.push(t) : (Ja = [t])) : (Ka = t);
}
function HS() {
  if (Ka) {
    var t = Ka,
      e = Ja;
    if (((Ja = Ka = null), qv(t), e)) for (t = 0; t < e.length; t++) qv(e[t]);
  }
}
function GS(t, e) {
  return t(e);
}
function WS() {}
var Ih = !1;
function $S(t, e, n) {
  if (Ih) return t(e, n);
  Ih = !0;
  try {
    return GS(t, e, n);
  } finally {
    (Ih = !1), (Ka !== null || Ja !== null) && (WS(), HS());
  }
}
function Ll(t, e) {
  var n = t.stateNode;
  if (n === null) return null;
  var i = qd(n);
  if (i === null) return null;
  n = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((t = t.type),
        (i = !(
          t === "button" ||
          t === "input" ||
          t === "select" ||
          t === "textarea"
        ))),
        (t = !i);
      break e;
    default:
      t = !1;
  }
  if (t) return null;
  if (n && typeof n != "function") throw Error(ne(231, e, typeof n));
  return n;
}
var xp = !1;
if (dr)
  try {
    var Fo = {};
    Object.defineProperty(Fo, "passive", {
      get: function () {
        xp = !0;
      },
    }),
      window.addEventListener("test", Fo, Fo),
      window.removeEventListener("test", Fo, Fo);
  } catch {
    xp = !1;
  }
function Ab(t, e, n, i, r, s, a, o, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(n, c);
  } catch (u) {
    this.onError(u);
  }
}
var hl = !1,
  Zu = null,
  Ku = !1,
  Sp = null,
  Cb = {
    onError: function (t) {
      (hl = !0), (Zu = t);
    },
  };
function Rb(t, e, n, i, r, s, a, o, l) {
  (hl = !1), (Zu = null), Ab.apply(Cb, arguments);
}
function Pb(t, e, n, i, r, s, a, o, l) {
  if ((Rb.apply(this, arguments), hl)) {
    if (hl) {
      var c = Zu;
      (hl = !1), (Zu = null);
    } else throw Error(ne(198));
    Ku || ((Ku = !0), (Sp = c));
  }
}
function ia(t) {
  var e = t,
    n = t;
  if (t.alternate) for (; e.return; ) e = e.return;
  else {
    t = e;
    do (e = t), e.flags & 4098 && (n = e.return), (t = e.return);
    while (t);
  }
  return e.tag === 3 ? n : null;
}
function XS(t) {
  if (t.tag === 13) {
    var e = t.memoizedState;
    if (
      (e === null && ((t = t.alternate), t !== null && (e = t.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function Yv(t) {
  if (ia(t) !== t) throw Error(ne(188));
}
function Lb(t) {
  var e = t.alternate;
  if (!e) {
    if (((e = ia(t)), e === null)) throw Error(ne(188));
    return e !== t ? null : t;
  }
  for (var n = t, i = e; ; ) {
    var r = n.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        n = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === n) return Yv(r), t;
        if (s === i) return Yv(r), e;
        s = s.sibling;
      }
      throw Error(ne(188));
    }
    if (n.return !== i.return) (n = r), (i = s);
    else {
      for (var a = !1, o = r.child; o; ) {
        if (o === n) {
          (a = !0), (n = r), (i = s);
          break;
        }
        if (o === i) {
          (a = !0), (i = r), (n = s);
          break;
        }
        o = o.sibling;
      }
      if (!a) {
        for (o = s.child; o; ) {
          if (o === n) {
            (a = !0), (n = s), (i = r);
            break;
          }
          if (o === i) {
            (a = !0), (i = s), (n = r);
            break;
          }
          o = o.sibling;
        }
        if (!a) throw Error(ne(189));
      }
    }
    if (n.alternate !== i) throw Error(ne(190));
  }
  if (n.tag !== 3) throw Error(ne(188));
  return n.stateNode.current === n ? t : e;
}
function qS(t) {
  return (t = Lb(t)), t !== null ? YS(t) : null;
}
function YS(t) {
  if (t.tag === 5 || t.tag === 6) return t;
  for (t = t.child; t !== null; ) {
    var e = YS(t);
    if (e !== null) return e;
    t = t.sibling;
  }
  return null;
}
var ZS = Gn.unstable_scheduleCallback,
  Zv = Gn.unstable_cancelCallback,
  Nb = Gn.unstable_shouldYield,
  Db = Gn.unstable_requestPaint,
  Dt = Gn.unstable_now,
  kb = Gn.unstable_getCurrentPriorityLevel,
  tg = Gn.unstable_ImmediatePriority,
  KS = Gn.unstable_UserBlockingPriority,
  Ju = Gn.unstable_NormalPriority,
  Ib = Gn.unstable_LowPriority,
  JS = Gn.unstable_IdlePriority,
  Gd = null,
  Ui = null;
function Ub(t) {
  if (Ui && typeof Ui.onCommitFiberRoot == "function")
    try {
      Ui.onCommitFiberRoot(Gd, t, void 0, (t.current.flags & 128) === 128);
    } catch {}
}
var xi = Math.clz32 ? Math.clz32 : Bb,
  Ob = Math.log,
  Fb = Math.LN2;
function Bb(t) {
  return (t >>>= 0), t === 0 ? 32 : (31 - ((Ob(t) / Fb) | 0)) | 0;
}
var Fc = 64,
  Bc = 4194304;
function nl(t) {
  switch (t & -t) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return t & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return t;
  }
}
function Qu(t, e) {
  var n = t.pendingLanes;
  if (n === 0) return 0;
  var i = 0,
    r = t.suspendedLanes,
    s = t.pingedLanes,
    a = n & 268435455;
  if (a !== 0) {
    var o = a & ~r;
    o !== 0 ? (i = nl(o)) : ((s &= a), s !== 0 && (i = nl(s)));
  } else (a = n & ~r), a !== 0 ? (i = nl(a)) : s !== 0 && (i = nl(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= n & 16), (e = t.entangledLanes), e !== 0))
    for (t = t.entanglements, e &= i; 0 < e; )
      (n = 31 - xi(e)), (r = 1 << n), (i |= t[n]), (e &= ~r);
  return i;
}
function zb(t, e) {
  switch (t) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function jb(t, e) {
  for (
    var n = t.suspendedLanes,
      i = t.pingedLanes,
      r = t.expirationTimes,
      s = t.pendingLanes;
    0 < s;

  ) {
    var a = 31 - xi(s),
      o = 1 << a,
      l = r[a];
    l === -1
      ? (!(o & n) || o & i) && (r[a] = zb(o, e))
      : l <= e && (t.expiredLanes |= o),
      (s &= ~o);
  }
}
function wp(t) {
  return (
    (t = t.pendingLanes & -1073741825),
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
  );
}
function QS() {
  var t = Fc;
  return (Fc <<= 1), !(Fc & 4194240) && (Fc = 64), t;
}
function Uh(t) {
  for (var e = [], n = 0; 31 > n; n++) e.push(t);
  return e;
}
function pc(t, e, n) {
  (t.pendingLanes |= e),
    e !== 536870912 && ((t.suspendedLanes = 0), (t.pingedLanes = 0)),
    (t = t.eventTimes),
    (e = 31 - xi(e)),
    (t[e] = n);
}
function Vb(t, e) {
  var n = t.pendingLanes & ~e;
  (t.pendingLanes = e),
    (t.suspendedLanes = 0),
    (t.pingedLanes = 0),
    (t.expiredLanes &= e),
    (t.mutableReadLanes &= e),
    (t.entangledLanes &= e),
    (e = t.entanglements);
  var i = t.eventTimes;
  for (t = t.expirationTimes; 0 < n; ) {
    var r = 31 - xi(n),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (t[r] = -1), (n &= ~s);
  }
}
function ng(t, e) {
  var n = (t.entangledLanes |= e);
  for (t = t.entanglements; n; ) {
    var i = 31 - xi(n),
      r = 1 << i;
    (r & e) | (t[i] & e) && (t[i] |= e), (n &= ~r);
  }
}
var ut = 0;
function ew(t) {
  return (t &= -t), 1 < t ? (4 < t ? (t & 268435455 ? 16 : 536870912) : 4) : 1;
}
var tw,
  ig,
  nw,
  iw,
  rw,
  Ep = !1,
  zc = [],
  jr = null,
  Vr = null,
  Hr = null,
  Nl = new Map(),
  Dl = new Map(),
  Dr = [],
  Hb =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function Kv(t, e) {
  switch (t) {
    case "focusin":
    case "focusout":
      jr = null;
      break;
    case "dragenter":
    case "dragleave":
      Vr = null;
      break;
    case "mouseover":
    case "mouseout":
      Hr = null;
      break;
    case "pointerover":
    case "pointerout":
      Nl.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Dl.delete(e.pointerId);
  }
}
function Bo(t, e, n, i, r, s) {
  return t === null || t.nativeEvent !== s
    ? ((t = {
        blockedOn: e,
        domEventName: n,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = gc(e)), e !== null && ig(e)),
      t)
    : ((t.eventSystemFlags |= i),
      (e = t.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      t);
}
function Gb(t, e, n, i, r) {
  switch (e) {
    case "focusin":
      return (jr = Bo(jr, t, e, n, i, r)), !0;
    case "dragenter":
      return (Vr = Bo(Vr, t, e, n, i, r)), !0;
    case "mouseover":
      return (Hr = Bo(Hr, t, e, n, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return Nl.set(s, Bo(Nl.get(s) || null, t, e, n, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), Dl.set(s, Bo(Dl.get(s) || null, t, e, n, i, r)), !0
      );
  }
  return !1;
}
function sw(t) {
  var e = ks(t.target);
  if (e !== null) {
    var n = ia(e);
    if (n !== null) {
      if (((e = n.tag), e === 13)) {
        if (((e = XS(n)), e !== null)) {
          (t.blockedOn = e),
            rw(t.priority, function () {
              nw(n);
            });
          return;
        }
      } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) {
        t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null;
        return;
      }
    }
  }
  t.blockedOn = null;
}
function Nu(t) {
  if (t.blockedOn !== null) return !1;
  for (var e = t.targetContainers; 0 < e.length; ) {
    var n = Tp(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
    if (n === null) {
      n = t.nativeEvent;
      var i = new n.constructor(n.type, n);
      (_p = i), n.target.dispatchEvent(i), (_p = null);
    } else return (e = gc(n)), e !== null && ig(e), (t.blockedOn = n), !1;
    e.shift();
  }
  return !0;
}
function Jv(t, e, n) {
  Nu(t) && n.delete(e);
}
function Wb() {
  (Ep = !1),
    jr !== null && Nu(jr) && (jr = null),
    Vr !== null && Nu(Vr) && (Vr = null),
    Hr !== null && Nu(Hr) && (Hr = null),
    Nl.forEach(Jv),
    Dl.forEach(Jv);
}
function zo(t, e) {
  t.blockedOn === e &&
    ((t.blockedOn = null),
    Ep ||
      ((Ep = !0),
      Gn.unstable_scheduleCallback(Gn.unstable_NormalPriority, Wb)));
}
function kl(t) {
  function e(r) {
    return zo(r, t);
  }
  if (0 < zc.length) {
    zo(zc[0], t);
    for (var n = 1; n < zc.length; n++) {
      var i = zc[n];
      i.blockedOn === t && (i.blockedOn = null);
    }
  }
  for (
    jr !== null && zo(jr, t),
      Vr !== null && zo(Vr, t),
      Hr !== null && zo(Hr, t),
      Nl.forEach(e),
      Dl.forEach(e),
      n = 0;
    n < Dr.length;
    n++
  )
    (i = Dr[n]), i.blockedOn === t && (i.blockedOn = null);
  for (; 0 < Dr.length && ((n = Dr[0]), n.blockedOn === null); )
    sw(n), n.blockedOn === null && Dr.shift();
}
var Qa = vr.ReactCurrentBatchConfig,
  ed = !0;
function $b(t, e, n, i) {
  var r = ut,
    s = Qa.transition;
  Qa.transition = null;
  try {
    (ut = 1), rg(t, e, n, i);
  } finally {
    (ut = r), (Qa.transition = s);
  }
}
function Xb(t, e, n, i) {
  var r = ut,
    s = Qa.transition;
  Qa.transition = null;
  try {
    (ut = 4), rg(t, e, n, i);
  } finally {
    (ut = r), (Qa.transition = s);
  }
}
function rg(t, e, n, i) {
  if (ed) {
    var r = Tp(t, e, n, i);
    if (r === null) $h(t, e, i, td, n), Kv(t, i);
    else if (Gb(r, t, e, n, i)) i.stopPropagation();
    else if ((Kv(t, i), e & 4 && -1 < Hb.indexOf(t))) {
      for (; r !== null; ) {
        var s = gc(r);
        if (
          (s !== null && tw(s),
          (s = Tp(t, e, n, i)),
          s === null && $h(t, e, i, td, n),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else $h(t, e, i, null, n);
  }
}
var td = null;
function Tp(t, e, n, i) {
  if (((td = null), (t = eg(i)), (t = ks(t)), t !== null))
    if (((e = ia(t)), e === null)) t = null;
    else if (((n = e.tag), n === 13)) {
      if (((t = XS(e)), t !== null)) return t;
      t = null;
    } else if (n === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      t = null;
    } else e !== t && (t = null);
  return (td = t), null;
}
function aw(t) {
  switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (kb()) {
        case tg:
          return 1;
        case KS:
          return 4;
        case Ju:
        case Ib:
          return 16;
        case JS:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Or = null,
  sg = null,
  Du = null;
function ow() {
  if (Du) return Du;
  var t,
    e = sg,
    n = e.length,
    i,
    r = "value" in Or ? Or.value : Or.textContent,
    s = r.length;
  for (t = 0; t < n && e[t] === r[t]; t++);
  var a = n - t;
  for (i = 1; i <= a && e[n - i] === r[s - i]; i++);
  return (Du = r.slice(t, 1 < i ? 1 - i : void 0));
}
function ku(t) {
  var e = t.keyCode;
  return (
    "charCode" in t
      ? ((t = t.charCode), t === 0 && e === 13 && (t = 13))
      : (t = e),
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
  );
}
function jc() {
  return !0;
}
function Qv() {
  return !1;
}
function Xn(t) {
  function e(n, i, r, s, a) {
    (this._reactName = n),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = a),
      (this.currentTarget = null);
    for (var o in t)
      t.hasOwnProperty(o) && ((n = t[o]), (this[o] = n ? n(s) : s[o]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? jc
        : Qv),
      (this.isPropagationStopped = Qv),
      this
    );
  }
  return (
    At(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var n = this.nativeEvent;
        n &&
          (n.preventDefault
            ? n.preventDefault()
            : typeof n.returnValue != "unknown" && (n.returnValue = !1),
          (this.isDefaultPrevented = jc));
      },
      stopPropagation: function () {
        var n = this.nativeEvent;
        n &&
          (n.stopPropagation
            ? n.stopPropagation()
            : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0),
          (this.isPropagationStopped = jc));
      },
      persist: function () {},
      isPersistent: jc,
    }),
    e
  );
}
var bo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (t) {
      return t.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  ag = Xn(bo),
  mc = At({}, bo, {
    view: 0,
    detail: 0,
  }),
  qb = Xn(mc),
  Oh,
  Fh,
  jo,
  Wd = At({}, mc, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: og,
    button: 0,
    buttons: 0,
    relatedTarget: function (t) {
      return t.relatedTarget === void 0
        ? t.fromElement === t.srcElement
          ? t.toElement
          : t.fromElement
        : t.relatedTarget;
    },
    movementX: function (t) {
      return "movementX" in t
        ? t.movementX
        : (t !== jo &&
            (jo && t.type === "mousemove"
              ? ((Oh = t.screenX - jo.screenX), (Fh = t.screenY - jo.screenY))
              : (Fh = Oh = 0),
            (jo = t)),
          Oh);
    },
    movementY: function (t) {
      return "movementY" in t ? t.movementY : Fh;
    },
  }),
  e0 = Xn(Wd),
  Yb = At({}, Wd, {
    dataTransfer: 0,
  }),
  Zb = Xn(Yb),
  Kb = At({}, mc, {
    relatedTarget: 0,
  }),
  Bh = Xn(Kb),
  Jb = At({}, bo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0,
  }),
  Qb = Xn(Jb),
  eA = At({}, bo, {
    clipboardData: function (t) {
      return "clipboardData" in t ? t.clipboardData : window.clipboardData;
    },
  }),
  tA = Xn(eA),
  nA = At({}, bo, {
    data: 0,
  }),
  t0 = Xn(nA),
  iA = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  rA = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  sA = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function aA(t) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(t) : (t = sA[t]) ? !!e[t] : !1;
}
function og() {
  return aA;
}
var oA = At({}, mc, {
    key: function (t) {
      if (t.key) {
        var e = iA[t.key] || t.key;
        if (e !== "Unidentified") return e;
      }
      return t.type === "keypress"
        ? ((t = ku(t)), t === 13 ? "Enter" : String.fromCharCode(t))
        : t.type === "keydown" || t.type === "keyup"
        ? rA[t.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: og,
    charCode: function (t) {
      return t.type === "keypress" ? ku(t) : 0;
    },
    keyCode: function (t) {
      return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0;
    },
    which: function (t) {
      return t.type === "keypress"
        ? ku(t)
        : t.type === "keydown" || t.type === "keyup"
        ? t.keyCode
        : 0;
    },
  }),
  lA = Xn(oA),
  cA = At({}, Wd, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  n0 = Xn(cA),
  uA = At({}, mc, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: og,
  }),
  dA = Xn(uA),
  hA = At({}, bo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0,
  }),
  fA = Xn(hA),
  pA = At({}, Wd, {
    deltaX: function (t) {
      return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0;
    },
    deltaY: function (t) {
      return "deltaY" in t
        ? t.deltaY
        : "wheelDeltaY" in t
        ? -t.wheelDeltaY
        : "wheelDelta" in t
        ? -t.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  mA = Xn(pA),
  gA = [9, 13, 27, 32],
  lg = dr && "CompositionEvent" in window,
  fl = null;
dr && "documentMode" in document && (fl = document.documentMode);
var vA = dr && "TextEvent" in window && !fl,
  lw = dr && (!lg || (fl && 8 < fl && 11 >= fl)),
  i0 = " ",
  r0 = !1;
function cw(t, e) {
  switch (t) {
    case "keyup":
      return gA.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function uw(t) {
  return (t = t.detail), typeof t == "object" && "data" in t ? t.data : null;
}
var Na = !1;
function _A(t, e) {
  switch (t) {
    case "compositionend":
      return uw(e);
    case "keypress":
      return e.which !== 32 ? null : ((r0 = !0), i0);
    case "textInput":
      return (t = e.data), t === i0 && r0 ? null : t;
    default:
      return null;
  }
}
function yA(t, e) {
  if (Na)
    return t === "compositionend" || (!lg && cw(t, e))
      ? ((t = ow()), (Du = sg = Or = null), (Na = !1), t)
      : null;
  switch (t) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return lw && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var xA = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function s0(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return e === "input" ? !!xA[t.type] : e === "textarea";
}
function dw(t, e, n, i) {
  VS(i),
    (e = nd(e, "onChange")),
    0 < e.length &&
      ((n = new ag("onChange", "change", null, n, i)),
      t.push({
        event: n,
        listeners: e,
      }));
}
var pl = null,
  Il = null;
function SA(t) {
  ww(t, 0);
}
function $d(t) {
  var e = Ia(t);
  if (IS(e)) return t;
}
function wA(t, e) {
  if (t === "change") return e;
}
var hw = !1;
if (dr) {
  var zh;
  if (dr) {
    var jh = "oninput" in document;
    if (!jh) {
      var a0 = document.createElement("div");
      a0.setAttribute("oninput", "return;"),
        (jh = typeof a0.oninput == "function");
    }
    zh = jh;
  } else zh = !1;
  hw = zh && (!document.documentMode || 9 < document.documentMode);
}
function o0() {
  pl && (pl.detachEvent("onpropertychange", fw), (Il = pl = null));
}
function fw(t) {
  if (t.propertyName === "value" && $d(Il)) {
    var e = [];
    dw(e, Il, t, eg(t)), $S(SA, e);
  }
}
function EA(t, e, n) {
  t === "focusin"
    ? (o0(), (pl = e), (Il = n), pl.attachEvent("onpropertychange", fw))
    : t === "focusout" && o0();
}
function TA(t) {
  if (t === "selectionchange" || t === "keyup" || t === "keydown")
    return $d(Il);
}
function MA(t, e) {
  if (t === "click") return $d(e);
}
function bA(t, e) {
  if (t === "input" || t === "change") return $d(e);
}
function AA(t, e) {
  return (t === e && (t !== 0 || 1 / t === 1 / e)) || (t !== t && e !== e);
}
var Ti = typeof Object.is == "function" ? Object.is : AA;
function Ul(t, e) {
  if (Ti(t, e)) return !0;
  if (typeof t != "object" || t === null || typeof e != "object" || e === null)
    return !1;
  var n = Object.keys(t),
    i = Object.keys(e);
  if (n.length !== i.length) return !1;
  for (i = 0; i < n.length; i++) {
    var r = n[i];
    if (!ap.call(e, r) || !Ti(t[r], e[r])) return !1;
  }
  return !0;
}
function l0(t) {
  for (; t && t.firstChild; ) t = t.firstChild;
  return t;
}
function c0(t, e) {
  var n = l0(t);
  t = 0;
  for (var i; n; ) {
    if (n.nodeType === 3) {
      if (((i = t + n.textContent.length), t <= e && i >= e))
        return {
          node: n,
          offset: e - t,
        };
      t = i;
    }
    e: {
      for (; n; ) {
        if (n.nextSibling) {
          n = n.nextSibling;
          break e;
        }
        n = n.parentNode;
      }
      n = void 0;
    }
    n = l0(n);
  }
}
function pw(t, e) {
  return t && e
    ? t === e
      ? !0
      : t && t.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? pw(t, e.parentNode)
      : "contains" in t
      ? t.contains(e)
      : t.compareDocumentPosition
      ? !!(t.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function mw() {
  for (var t = window, e = Yu(); e instanceof t.HTMLIFrameElement; ) {
    try {
      var n = typeof e.contentWindow.location.href == "string";
    } catch {
      n = !1;
    }
    if (n) t = e.contentWindow;
    else break;
    e = Yu(t.document);
  }
  return e;
}
function cg(t) {
  var e = t && t.nodeName && t.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (t.type === "text" ||
        t.type === "search" ||
        t.type === "tel" ||
        t.type === "url" ||
        t.type === "password")) ||
      e === "textarea" ||
      t.contentEditable === "true")
  );
}
function CA(t) {
  var e = mw(),
    n = t.focusedElem,
    i = t.selectionRange;
  if (
    e !== n &&
    n &&
    n.ownerDocument &&
    pw(n.ownerDocument.documentElement, n)
  ) {
    if (i !== null && cg(n)) {
      if (
        ((e = i.start),
        (t = i.end),
        t === void 0 && (t = e),
        "selectionStart" in n)
      )
        (n.selectionStart = e), (n.selectionEnd = Math.min(t, n.value.length));
      else if (
        ((t = ((e = n.ownerDocument || document) && e.defaultView) || window),
        t.getSelection)
      ) {
        t = t.getSelection();
        var r = n.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !t.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = c0(n, s));
        var a = c0(n, i);
        r &&
          a &&
          (t.rangeCount !== 1 ||
            t.anchorNode !== r.node ||
            t.anchorOffset !== r.offset ||
            t.focusNode !== a.node ||
            t.focusOffset !== a.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          t.removeAllRanges(),
          s > i
            ? (t.addRange(e), t.extend(a.node, a.offset))
            : (e.setEnd(a.node, a.offset), t.addRange(e)));
      }
    }
    for (e = [], t = n; (t = t.parentNode); )
      t.nodeType === 1 &&
        e.push({
          element: t,
          left: t.scrollLeft,
          top: t.scrollTop,
        });
    for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)
      (t = e[n]),
        (t.element.scrollLeft = t.left),
        (t.element.scrollTop = t.top);
  }
}
var RA = dr && "documentMode" in document && 11 >= document.documentMode,
  Da = null,
  Mp = null,
  ml = null,
  bp = !1;
function u0(t, e, n) {
  var i = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument;
  bp ||
    Da == null ||
    Da !== Yu(i) ||
    ((i = Da),
    "selectionStart" in i && cg(i)
      ? (i = {
          start: i.selectionStart,
          end: i.selectionEnd,
        })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (ml && Ul(ml, i)) ||
      ((ml = i),
      (i = nd(Mp, "onSelect")),
      0 < i.length &&
        ((e = new ag("onSelect", "select", null, e, n)),
        t.push({
          event: e,
          listeners: i,
        }),
        (e.target = Da))));
}
function Vc(t, e) {
  var n = {};
  return (
    (n[t.toLowerCase()] = e.toLowerCase()),
    (n["Webkit" + t] = "webkit" + e),
    (n["Moz" + t] = "moz" + e),
    n
  );
}
var ka = {
    animationend: Vc("Animation", "AnimationEnd"),
    animationiteration: Vc("Animation", "AnimationIteration"),
    animationstart: Vc("Animation", "AnimationStart"),
    transitionend: Vc("Transition", "TransitionEnd"),
  },
  Vh = {},
  gw = {};
dr &&
  ((gw = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete ka.animationend.animation,
    delete ka.animationiteration.animation,
    delete ka.animationstart.animation),
  "TransitionEvent" in window || delete ka.transitionend.transition);
function Xd(t) {
  if (Vh[t]) return Vh[t];
  if (!ka[t]) return t;
  var e = ka[t],
    n;
  for (n in e) if (e.hasOwnProperty(n) && n in gw) return (Vh[t] = e[n]);
  return t;
}
var vw = Xd("animationend"),
  _w = Xd("animationiteration"),
  yw = Xd("animationstart"),
  xw = Xd("transitionend"),
  Sw = new Map(),
  d0 =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function ls(t, e) {
  Sw.set(t, e), na(e, [t]);
}
for (var Hh = 0; Hh < d0.length; Hh++) {
  var Gh = d0[Hh],
    PA = Gh.toLowerCase(),
    LA = Gh[0].toUpperCase() + Gh.slice(1);
  ls(PA, "on" + LA);
}
ls(vw, "onAnimationEnd");
ls(_w, "onAnimationIteration");
ls(yw, "onAnimationStart");
ls("dblclick", "onDoubleClick");
ls("focusin", "onFocus");
ls("focusout", "onBlur");
ls(xw, "onTransitionEnd");
ao("onMouseEnter", ["mouseout", "mouseover"]);
ao("onMouseLeave", ["mouseout", "mouseover"]);
ao("onPointerEnter", ["pointerout", "pointerover"]);
ao("onPointerLeave", ["pointerout", "pointerover"]);
na(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
na(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
na("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
na(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
na(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
na(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var il =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  NA = new Set("cancel close invalid load scroll toggle".split(" ").concat(il));
function h0(t, e, n) {
  var i = t.type || "unknown-event";
  (t.currentTarget = n), Pb(i, e, void 0, t), (t.currentTarget = null);
}
function ww(t, e) {
  e = (e & 4) !== 0;
  for (var n = 0; n < t.length; n++) {
    var i = t[n],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var a = i.length - 1; 0 <= a; a--) {
          var o = i[a],
            l = o.instance,
            c = o.currentTarget;
          if (((o = o.listener), l !== s && r.isPropagationStopped())) break e;
          h0(r, o, c), (s = l);
        }
      else
        for (a = 0; a < i.length; a++) {
          if (
            ((o = i[a]),
            (l = o.instance),
            (c = o.currentTarget),
            (o = o.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          h0(r, o, c), (s = l);
        }
    }
  }
  if (Ku) throw ((t = Sp), (Ku = !1), (Sp = null), t);
}
function gt(t, e) {
  var n = e[Lp];
  n === void 0 && (n = e[Lp] = new Set());
  var i = t + "__bubble";
  n.has(i) || (Ew(e, t, 2, !1), n.add(i));
}
function Wh(t, e, n) {
  var i = 0;
  e && (i |= 4), Ew(n, t, i, e);
}
var Hc = "_reactListening" + Math.random().toString(36).slice(2);
function Ol(t) {
  if (!t[Hc]) {
    (t[Hc] = !0),
      PS.forEach(function (n) {
        n !== "selectionchange" && (NA.has(n) || Wh(n, !1, t), Wh(n, !0, t));
      });
    var e = t.nodeType === 9 ? t : t.ownerDocument;
    e === null || e[Hc] || ((e[Hc] = !0), Wh("selectionchange", !1, e));
  }
}
function Ew(t, e, n, i) {
  switch (aw(e)) {
    case 1:
      var r = $b;
      break;
    case 4:
      r = Xb;
      break;
    default:
      r = rg;
  }
  (n = r.bind(null, e, n, t)),
    (r = void 0),
    !xp ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? t.addEventListener(e, n, {
            capture: !0,
            passive: r,
          })
        : t.addEventListener(e, n, !0)
      : r !== void 0
      ? t.addEventListener(e, n, {
          passive: r,
        })
      : t.addEventListener(e, n, !1);
}
function $h(t, e, n, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var a = i.tag;
      if (a === 3 || a === 4) {
        var o = i.stateNode.containerInfo;
        if (o === r || (o.nodeType === 8 && o.parentNode === r)) break;
        if (a === 4)
          for (a = i.return; a !== null; ) {
            var l = a.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = a.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            a = a.return;
          }
        for (; o !== null; ) {
          if (((a = ks(o)), a === null)) return;
          if (((l = a.tag), l === 5 || l === 6)) {
            i = s = a;
            continue e;
          }
          o = o.parentNode;
        }
      }
      i = i.return;
    }
  $S(function () {
    var c = s,
      u = eg(n),
      d = [];
    e: {
      var h = Sw.get(t);
      if (h !== void 0) {
        var p = ag,
          v = t;
        switch (t) {
          case "keypress":
            if (ku(n) === 0) break e;
          case "keydown":
          case "keyup":
            p = lA;
            break;
          case "focusin":
            (v = "focus"), (p = Bh);
            break;
          case "focusout":
            (v = "blur"), (p = Bh);
            break;
          case "beforeblur":
          case "afterblur":
            p = Bh;
            break;
          case "click":
            if (n.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            p = e0;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            p = Zb;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            p = dA;
            break;
          case vw:
          case _w:
          case yw:
            p = Qb;
            break;
          case xw:
            p = fA;
            break;
          case "scroll":
            p = qb;
            break;
          case "wheel":
            p = mA;
            break;
          case "copy":
          case "cut":
          case "paste":
            p = tA;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            p = n0;
        }
        var x = (e & 4) !== 0,
          m = !x && t === "scroll",
          f = x ? (h !== null ? h + "Capture" : null) : h;
        x = [];
        for (var y = c, g; y !== null; ) {
          g = y;
          var S = g.stateNode;
          if (
            (g.tag === 5 &&
              S !== null &&
              ((g = S),
              f !== null && ((S = Ll(y, f)), S != null && x.push(Fl(y, S, g)))),
            m)
          )
            break;
          y = y.return;
        }
        0 < x.length &&
          ((h = new p(h, v, null, n, u)),
          d.push({
            event: h,
            listeners: x,
          }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((h = t === "mouseover" || t === "pointerover"),
          (p = t === "mouseout" || t === "pointerout"),
          h &&
            n !== _p &&
            (v = n.relatedTarget || n.fromElement) &&
            (ks(v) || v[hr]))
        )
          break e;
        if (
          (p || h) &&
          ((h =
            u.window === u
              ? u
              : (h = u.ownerDocument)
              ? h.defaultView || h.parentWindow
              : window),
          p
            ? ((v = n.relatedTarget || n.toElement),
              (p = c),
              (v = v ? ks(v) : null),
              v !== null &&
                ((m = ia(v)), v !== m || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((p = null), (v = c)),
          p !== v)
        ) {
          if (
            ((x = e0),
            (S = "onMouseLeave"),
            (f = "onMouseEnter"),
            (y = "mouse"),
            (t === "pointerout" || t === "pointerover") &&
              ((x = n0),
              (S = "onPointerLeave"),
              (f = "onPointerEnter"),
              (y = "pointer")),
            (m = p == null ? h : Ia(p)),
            (g = v == null ? h : Ia(v)),
            (h = new x(S, y + "leave", p, n, u)),
            (h.target = m),
            (h.relatedTarget = g),
            (S = null),
            ks(u) === c &&
              ((x = new x(f, y + "enter", v, n, u)),
              (x.target = g),
              (x.relatedTarget = m),
              (S = x)),
            (m = S),
            p && v)
          )
            t: {
              for (x = p, f = v, y = 0, g = x; g; g = la(g)) y++;
              for (g = 0, S = f; S; S = la(S)) g++;
              for (; 0 < y - g; ) (x = la(x)), y--;
              for (; 0 < g - y; ) (f = la(f)), g--;
              for (; y--; ) {
                if (x === f || (f !== null && x === f.alternate)) break t;
                (x = la(x)), (f = la(f));
              }
              x = null;
            }
          else x = null;
          p !== null && f0(d, h, p, x, !1),
            v !== null && m !== null && f0(d, m, v, x, !0);
        }
      }
      e: {
        if (
          ((h = c ? Ia(c) : window),
          (p = h.nodeName && h.nodeName.toLowerCase()),
          p === "select" || (p === "input" && h.type === "file"))
        )
          var T = wA;
        else if (s0(h))
          if (hw) T = bA;
          else {
            T = TA;
            var A = EA;
          }
        else
          (p = h.nodeName) &&
            p.toLowerCase() === "input" &&
            (h.type === "checkbox" || h.type === "radio") &&
            (T = MA);
        if (T && (T = T(t, c))) {
          dw(d, T, n, u);
          break e;
        }
        A && A(t, h, c),
          t === "focusout" &&
            (A = h._wrapperState) &&
            A.controlled &&
            h.type === "number" &&
            fp(h, "number", h.value);
      }
      switch (((A = c ? Ia(c) : window), t)) {
        case "focusin":
          (s0(A) || A.contentEditable === "true") &&
            ((Da = A), (Mp = c), (ml = null));
          break;
        case "focusout":
          ml = Mp = Da = null;
          break;
        case "mousedown":
          bp = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (bp = !1), u0(d, n, u);
          break;
        case "selectionchange":
          if (RA) break;
        case "keydown":
        case "keyup":
          u0(d, n, u);
      }
      var b;
      if (lg)
        e: {
          switch (t) {
            case "compositionstart":
              var P = "onCompositionStart";
              break e;
            case "compositionend":
              P = "onCompositionEnd";
              break e;
            case "compositionupdate":
              P = "onCompositionUpdate";
              break e;
          }
          P = void 0;
        }
      else
        Na
          ? cw(t, n) && (P = "onCompositionEnd")
          : t === "keydown" && n.keyCode === 229 && (P = "onCompositionStart");
      P &&
        (lw &&
          n.locale !== "ko" &&
          (Na || P !== "onCompositionStart"
            ? P === "onCompositionEnd" && Na && (b = ow())
            : ((Or = u),
              (sg = "value" in Or ? Or.value : Or.textContent),
              (Na = !0))),
        (A = nd(c, P)),
        0 < A.length &&
          ((P = new t0(P, t, null, n, u)),
          d.push({
            event: P,
            listeners: A,
          }),
          b ? (P.data = b) : ((b = uw(n)), b !== null && (P.data = b)))),
        (b = vA ? _A(t, n) : yA(t, n)) &&
          ((c = nd(c, "onBeforeInput")),
          0 < c.length &&
            ((u = new t0("onBeforeInput", "beforeinput", null, n, u)),
            d.push({
              event: u,
              listeners: c,
            }),
            (u.data = b)));
    }
    ww(d, e);
  });
}
function Fl(t, e, n) {
  return {
    instance: t,
    listener: e,
    currentTarget: n,
  };
}
function nd(t, e) {
  for (var n = e + "Capture", i = []; t !== null; ) {
    var r = t,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = Ll(t, n)),
      s != null && i.unshift(Fl(t, s, r)),
      (s = Ll(t, e)),
      s != null && i.push(Fl(t, s, r))),
      (t = t.return);
  }
  return i;
}
function la(t) {
  if (t === null) return null;
  do t = t.return;
  while (t && t.tag !== 5);
  return t || null;
}
function f0(t, e, n, i, r) {
  for (var s = e._reactName, a = []; n !== null && n !== i; ) {
    var o = n,
      l = o.alternate,
      c = o.stateNode;
    if (l !== null && l === i) break;
    o.tag === 5 &&
      c !== null &&
      ((o = c),
      r
        ? ((l = Ll(n, s)), l != null && a.unshift(Fl(n, l, o)))
        : r || ((l = Ll(n, s)), l != null && a.push(Fl(n, l, o)))),
      (n = n.return);
  }
  a.length !== 0 &&
    t.push({
      event: e,
      listeners: a,
    });
}
var DA = /\r\n?/g,
  kA = /\u0000|\uFFFD/g;
function p0(t) {
  return (typeof t == "string" ? t : "" + t)
    .replace(
      DA,
      `
`
    )
    .replace(kA, "");
}
function Gc(t, e, n) {
  if (((e = p0(e)), p0(t) !== e && n)) throw Error(ne(425));
}
function id() {}
var Ap = null,
  Cp = null;
function Rp(t, e) {
  return (
    t === "textarea" ||
    t === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var Pp = typeof setTimeout == "function" ? setTimeout : void 0,
  IA = typeof clearTimeout == "function" ? clearTimeout : void 0,
  m0 = typeof Promise == "function" ? Promise : void 0,
  UA =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof m0 < "u"
      ? function (t) {
          return m0.resolve(null).then(t).catch(OA);
        }
      : Pp;
function OA(t) {
  setTimeout(function () {
    throw t;
  });
}
function Xh(t, e) {
  var n = e,
    i = 0;
  do {
    var r = n.nextSibling;
    if ((t.removeChild(n), r && r.nodeType === 8))
      if (((n = r.data), n === "/$")) {
        if (i === 0) {
          t.removeChild(r), kl(e);
          return;
        }
        i--;
      } else (n !== "$" && n !== "$?" && n !== "$!") || i++;
    n = r;
  } while (n);
  kl(e);
}
function Gr(t) {
  for (; t != null; t = t.nextSibling) {
    var e = t.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = t.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return t;
}
function g0(t) {
  t = t.previousSibling;
  for (var e = 0; t; ) {
    if (t.nodeType === 8) {
      var n = t.data;
      if (n === "$" || n === "$!" || n === "$?") {
        if (e === 0) return t;
        e--;
      } else n === "/$" && e++;
    }
    t = t.previousSibling;
  }
  return null;
}
var Ao = Math.random().toString(36).slice(2),
  Di = "__reactFiber$" + Ao,
  Bl = "__reactProps$" + Ao,
  hr = "__reactContainer$" + Ao,
  Lp = "__reactEvents$" + Ao,
  FA = "__reactListeners$" + Ao,
  BA = "__reactHandles$" + Ao;
function ks(t) {
  var e = t[Di];
  if (e) return e;
  for (var n = t.parentNode; n; ) {
    if ((e = n[hr] || n[Di])) {
      if (
        ((n = e.alternate),
        e.child !== null || (n !== null && n.child !== null))
      )
        for (t = g0(t); t !== null; ) {
          if ((n = t[Di])) return n;
          t = g0(t);
        }
      return e;
    }
    (t = n), (n = t.parentNode);
  }
  return null;
}
function gc(t) {
  return (
    (t = t[Di] || t[hr]),
    !t || (t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3) ? null : t
  );
}
function Ia(t) {
  if (t.tag === 5 || t.tag === 6) return t.stateNode;
  throw Error(ne(33));
}
function qd(t) {
  return t[Bl] || null;
}
var Np = [],
  Ua = -1;
function cs(t) {
  return {
    current: t,
  };
}
function _t(t) {
  0 > Ua || ((t.current = Np[Ua]), (Np[Ua] = null), Ua--);
}
function mt(t, e) {
  Ua++, (Np[Ua] = t.current), (t.current = e);
}
var es = {},
  hn = cs(es),
  Pn = cs(!1),
  $s = es;
function oo(t, e) {
  var n = t.type.contextTypes;
  if (!n) return es;
  var i = t.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in n) r[s] = e[s];
  return (
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = e),
      (t.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Ln(t) {
  return (t = t.childContextTypes), t != null;
}
function rd() {
  _t(Pn), _t(hn);
}
function v0(t, e, n) {
  if (hn.current !== es) throw Error(ne(168));
  mt(hn, e), mt(Pn, n);
}
function Tw(t, e, n) {
  var i = t.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return n;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(ne(108, Eb(t) || "Unknown", r));
  return At({}, n, i);
}
function sd(t) {
  return (
    (t =
      ((t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext) || es),
    ($s = hn.current),
    mt(hn, t),
    mt(Pn, Pn.current),
    !0
  );
}
function _0(t, e, n) {
  var i = t.stateNode;
  if (!i) throw Error(ne(169));
  n
    ? ((t = Tw(t, e, $s)),
      (i.__reactInternalMemoizedMergedChildContext = t),
      _t(Pn),
      _t(hn),
      mt(hn, t))
    : _t(Pn),
    mt(Pn, n);
}
var er = null,
  Yd = !1,
  qh = !1;
function Mw(t) {
  er === null ? (er = [t]) : er.push(t);
}
function zA(t) {
  (Yd = !0), Mw(t);
}
function us() {
  if (!qh && er !== null) {
    qh = !0;
    var t = 0,
      e = ut;
    try {
      var n = er;
      for (ut = 1; t < n.length; t++) {
        var i = n[t];
        do i = i(!0);
        while (i !== null);
      }
      (er = null), (Yd = !1);
    } catch (r) {
      throw (er !== null && (er = er.slice(t + 1)), ZS(tg, us), r);
    } finally {
      (ut = e), (qh = !1);
    }
  }
  return null;
}
var Oa = [],
  Fa = 0,
  ad = null,
  od = 0,
  Qn = [],
  ei = 0,
  Xs = null,
  rr = 1,
  sr = "";
function Ts(t, e) {
  (Oa[Fa++] = od), (Oa[Fa++] = ad), (ad = t), (od = e);
}
function bw(t, e, n) {
  (Qn[ei++] = rr), (Qn[ei++] = sr), (Qn[ei++] = Xs), (Xs = t);
  var i = rr;
  t = sr;
  var r = 32 - xi(i) - 1;
  (i &= ~(1 << r)), (n += 1);
  var s = 32 - xi(e) + r;
  if (30 < s) {
    var a = r - (r % 5);
    (s = (i & ((1 << a) - 1)).toString(32)),
      (i >>= a),
      (r -= a),
      (rr = (1 << (32 - xi(e) + r)) | (n << r) | i),
      (sr = s + t);
  } else (rr = (1 << s) | (n << r) | i), (sr = t);
}
function ug(t) {
  t.return !== null && (Ts(t, 1), bw(t, 1, 0));
}
function dg(t) {
  for (; t === ad; )
    (ad = Oa[--Fa]), (Oa[Fa] = null), (od = Oa[--Fa]), (Oa[Fa] = null);
  for (; t === Xs; )
    (Xs = Qn[--ei]),
      (Qn[ei] = null),
      (sr = Qn[--ei]),
      (Qn[ei] = null),
      (rr = Qn[--ei]),
      (Qn[ei] = null);
}
var Vn = null,
  jn = null,
  St = !1,
  gi = null;
function Aw(t, e) {
  var n = ni(5, null, null, 0);
  (n.elementType = "DELETED"),
    (n.stateNode = e),
    (n.return = t),
    (e = t.deletions),
    e === null ? ((t.deletions = [n]), (t.flags |= 16)) : e.push(n);
}
function y0(t, e) {
  switch (t.tag) {
    case 5:
      var n = t.type;
      return (
        (e =
          e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((t.stateNode = e), (Vn = t), (jn = Gr(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = t.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((t.stateNode = e), (Vn = t), (jn = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((n =
              Xs !== null
                ? {
                    id: rr,
                    overflow: sr,
                  }
                : null),
            (t.memoizedState = {
              dehydrated: e,
              treeContext: n,
              retryLane: 1073741824,
            }),
            (n = ni(18, null, null, 0)),
            (n.stateNode = e),
            (n.return = t),
            (t.child = n),
            (Vn = t),
            (jn = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function Dp(t) {
  return (t.mode & 1) !== 0 && (t.flags & 128) === 0;
}
function kp(t) {
  if (St) {
    var e = jn;
    if (e) {
      var n = e;
      if (!y0(t, e)) {
        if (Dp(t)) throw Error(ne(418));
        e = Gr(n.nextSibling);
        var i = Vn;
        e && y0(t, e)
          ? Aw(i, n)
          : ((t.flags = (t.flags & -4097) | 2), (St = !1), (Vn = t));
      }
    } else {
      if (Dp(t)) throw Error(ne(418));
      (t.flags = (t.flags & -4097) | 2), (St = !1), (Vn = t);
    }
  }
}
function x0(t) {
  for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
    t = t.return;
  Vn = t;
}
function Wc(t) {
  if (t !== Vn) return !1;
  if (!St) return x0(t), (St = !0), !1;
  var e;
  if (
    ((e = t.tag !== 3) &&
      !(e = t.tag !== 5) &&
      ((e = t.type),
      (e = e !== "head" && e !== "body" && !Rp(t.type, t.memoizedProps))),
    e && (e = jn))
  ) {
    if (Dp(t)) throw (Cw(), Error(ne(418)));
    for (; e; ) Aw(t, e), (e = Gr(e.nextSibling));
  }
  if ((x0(t), t.tag === 13)) {
    if (((t = t.memoizedState), (t = t !== null ? t.dehydrated : null), !t))
      throw Error(ne(317));
    e: {
      for (t = t.nextSibling, e = 0; t; ) {
        if (t.nodeType === 8) {
          var n = t.data;
          if (n === "/$") {
            if (e === 0) {
              jn = Gr(t.nextSibling);
              break e;
            }
            e--;
          } else (n !== "$" && n !== "$!" && n !== "$?") || e++;
        }
        t = t.nextSibling;
      }
      jn = null;
    }
  } else jn = Vn ? Gr(t.stateNode.nextSibling) : null;
  return !0;
}
function Cw() {
  for (var t = jn; t; ) t = Gr(t.nextSibling);
}
function lo() {
  (jn = Vn = null), (St = !1);
}
function hg(t) {
  gi === null ? (gi = [t]) : gi.push(t);
}
var jA = vr.ReactCurrentBatchConfig;
function Vo(t, e, n) {
  if (
    ((t = n.ref), t !== null && typeof t != "function" && typeof t != "object")
  ) {
    if (n._owner) {
      if (((n = n._owner), n)) {
        if (n.tag !== 1) throw Error(ne(309));
        var i = n.stateNode;
      }
      if (!i) throw Error(ne(147, t));
      var r = i,
        s = "" + t;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (a) {
            var o = r.refs;
            a === null ? delete o[s] : (o[s] = a);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof t != "string") throw Error(ne(284));
    if (!n._owner) throw Error(ne(290, t));
  }
  return t;
}
function $c(t, e) {
  throw (
    ((t = Object.prototype.toString.call(e)),
    Error(
      ne(
        31,
        t === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : t
      )
    ))
  );
}
function S0(t) {
  var e = t._init;
  return e(t._payload);
}
function Rw(t) {
  function e(f, y) {
    if (t) {
      var g = f.deletions;
      g === null ? ((f.deletions = [y]), (f.flags |= 16)) : g.push(y);
    }
  }
  function n(f, y) {
    if (!t) return null;
    for (; y !== null; ) e(f, y), (y = y.sibling);
    return null;
  }
  function i(f, y) {
    for (f = new Map(); y !== null; )
      y.key !== null ? f.set(y.key, y) : f.set(y.index, y), (y = y.sibling);
    return f;
  }
  function r(f, y) {
    return (f = qr(f, y)), (f.index = 0), (f.sibling = null), f;
  }
  function s(f, y, g) {
    return (
      (f.index = g),
      t
        ? ((g = f.alternate),
          g !== null
            ? ((g = g.index), g < y ? ((f.flags |= 2), y) : g)
            : ((f.flags |= 2), y))
        : ((f.flags |= 1048576), y)
    );
  }
  function a(f) {
    return t && f.alternate === null && (f.flags |= 2), f;
  }
  function o(f, y, g, S) {
    return y === null || y.tag !== 6
      ? ((y = tf(g, f.mode, S)), (y.return = f), y)
      : ((y = r(y, g)), (y.return = f), y);
  }
  function l(f, y, g, S) {
    var T = g.type;
    return T === La
      ? u(f, y, g.props.children, S, g.key)
      : y !== null &&
        (y.elementType === T ||
          (typeof T == "object" &&
            T !== null &&
            T.$$typeof === Pr &&
            S0(T) === y.type))
      ? ((S = r(y, g.props)), (S.ref = Vo(f, y, g)), (S.return = f), S)
      : ((S = ju(g.type, g.key, g.props, null, f.mode, S)),
        (S.ref = Vo(f, y, g)),
        (S.return = f),
        S);
  }
  function c(f, y, g, S) {
    return y === null ||
      y.tag !== 4 ||
      y.stateNode.containerInfo !== g.containerInfo ||
      y.stateNode.implementation !== g.implementation
      ? ((y = nf(g, f.mode, S)), (y.return = f), y)
      : ((y = r(y, g.children || [])), (y.return = f), y);
  }
  function u(f, y, g, S, T) {
    return y === null || y.tag !== 7
      ? ((y = zs(g, f.mode, S, T)), (y.return = f), y)
      : ((y = r(y, g)), (y.return = f), y);
  }
  function d(f, y, g) {
    if ((typeof y == "string" && y !== "") || typeof y == "number")
      return (y = tf("" + y, f.mode, g)), (y.return = f), y;
    if (typeof y == "object" && y !== null) {
      switch (y.$$typeof) {
        case Ic:
          return (
            (g = ju(y.type, y.key, y.props, null, f.mode, g)),
            (g.ref = Vo(f, null, y)),
            (g.return = f),
            g
          );
        case Pa:
          return (y = nf(y, f.mode, g)), (y.return = f), y;
        case Pr:
          var S = y._init;
          return d(f, S(y._payload), g);
      }
      if (tl(y) || Oo(y))
        return (y = zs(y, f.mode, g, null)), (y.return = f), y;
      $c(f, y);
    }
    return null;
  }
  function h(f, y, g, S) {
    var T = y !== null ? y.key : null;
    if ((typeof g == "string" && g !== "") || typeof g == "number")
      return T !== null ? null : o(f, y, "" + g, S);
    if (typeof g == "object" && g !== null) {
      switch (g.$$typeof) {
        case Ic:
          return g.key === T ? l(f, y, g, S) : null;
        case Pa:
          return g.key === T ? c(f, y, g, S) : null;
        case Pr:
          return (T = g._init), h(f, y, T(g._payload), S);
      }
      if (tl(g) || Oo(g)) return T !== null ? null : u(f, y, g, S, null);
      $c(f, g);
    }
    return null;
  }
  function p(f, y, g, S, T) {
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return (f = f.get(g) || null), o(y, f, "" + S, T);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case Ic:
          return (f = f.get(S.key === null ? g : S.key) || null), l(y, f, S, T);
        case Pa:
          return (f = f.get(S.key === null ? g : S.key) || null), c(y, f, S, T);
        case Pr:
          var A = S._init;
          return p(f, y, g, A(S._payload), T);
      }
      if (tl(S) || Oo(S)) return (f = f.get(g) || null), u(y, f, S, T, null);
      $c(y, S);
    }
    return null;
  }
  function v(f, y, g, S) {
    for (
      var T = null, A = null, b = y, P = (y = 0), G = null;
      b !== null && P < g.length;
      P++
    ) {
      b.index > P ? ((G = b), (b = null)) : (G = b.sibling);
      var w = h(f, b, g[P], S);
      if (w === null) {
        b === null && (b = G);
        break;
      }
      t && b && w.alternate === null && e(f, b),
        (y = s(w, y, P)),
        A === null ? (T = w) : (A.sibling = w),
        (A = w),
        (b = G);
    }
    if (P === g.length) return n(f, b), St && Ts(f, P), T;
    if (b === null) {
      for (; P < g.length; P++)
        (b = d(f, g[P], S)),
          b !== null &&
            ((y = s(b, y, P)), A === null ? (T = b) : (A.sibling = b), (A = b));
      return St && Ts(f, P), T;
    }
    for (b = i(f, b); P < g.length; P++)
      (G = p(b, f, P, g[P], S)),
        G !== null &&
          (t && G.alternate !== null && b.delete(G.key === null ? P : G.key),
          (y = s(G, y, P)),
          A === null ? (T = G) : (A.sibling = G),
          (A = G));
    return (
      t &&
        b.forEach(function (R) {
          return e(f, R);
        }),
      St && Ts(f, P),
      T
    );
  }
  function x(f, y, g, S) {
    var T = Oo(g);
    if (typeof T != "function") throw Error(ne(150));
    if (((g = T.call(g)), g == null)) throw Error(ne(151));
    for (
      var A = (T = null), b = y, P = (y = 0), G = null, w = g.next();
      b !== null && !w.done;
      P++, w = g.next()
    ) {
      b.index > P ? ((G = b), (b = null)) : (G = b.sibling);
      var R = h(f, b, w.value, S);
      if (R === null) {
        b === null && (b = G);
        break;
      }
      t && b && R.alternate === null && e(f, b),
        (y = s(R, y, P)),
        A === null ? (T = R) : (A.sibling = R),
        (A = R),
        (b = G);
    }
    if (w.done) return n(f, b), St && Ts(f, P), T;
    if (b === null) {
      for (; !w.done; P++, w = g.next())
        (w = d(f, w.value, S)),
          w !== null &&
            ((y = s(w, y, P)), A === null ? (T = w) : (A.sibling = w), (A = w));
      return St && Ts(f, P), T;
    }
    for (b = i(f, b); !w.done; P++, w = g.next())
      (w = p(b, f, P, w.value, S)),
        w !== null &&
          (t && w.alternate !== null && b.delete(w.key === null ? P : w.key),
          (y = s(w, y, P)),
          A === null ? (T = w) : (A.sibling = w),
          (A = w));
    return (
      t &&
        b.forEach(function (ie) {
          return e(f, ie);
        }),
      St && Ts(f, P),
      T
    );
  }
  function m(f, y, g, S) {
    if (
      (typeof g == "object" &&
        g !== null &&
        g.type === La &&
        g.key === null &&
        (g = g.props.children),
      typeof g == "object" && g !== null)
    ) {
      switch (g.$$typeof) {
        case Ic:
          e: {
            for (var T = g.key, A = y; A !== null; ) {
              if (A.key === T) {
                if (((T = g.type), T === La)) {
                  if (A.tag === 7) {
                    n(f, A.sibling),
                      (y = r(A, g.props.children)),
                      (y.return = f),
                      (f = y);
                    break e;
                  }
                } else if (
                  A.elementType === T ||
                  (typeof T == "object" &&
                    T !== null &&
                    T.$$typeof === Pr &&
                    S0(T) === A.type)
                ) {
                  n(f, A.sibling),
                    (y = r(A, g.props)),
                    (y.ref = Vo(f, A, g)),
                    (y.return = f),
                    (f = y);
                  break e;
                }
                n(f, A);
                break;
              } else e(f, A);
              A = A.sibling;
            }
            g.type === La
              ? ((y = zs(g.props.children, f.mode, S, g.key)),
                (y.return = f),
                (f = y))
              : ((S = ju(g.type, g.key, g.props, null, f.mode, S)),
                (S.ref = Vo(f, y, g)),
                (S.return = f),
                (f = S));
          }
          return a(f);
        case Pa:
          e: {
            for (A = g.key; y !== null; ) {
              if (y.key === A)
                if (
                  y.tag === 4 &&
                  y.stateNode.containerInfo === g.containerInfo &&
                  y.stateNode.implementation === g.implementation
                ) {
                  n(f, y.sibling),
                    (y = r(y, g.children || [])),
                    (y.return = f),
                    (f = y);
                  break e;
                } else {
                  n(f, y);
                  break;
                }
              else e(f, y);
              y = y.sibling;
            }
            (y = nf(g, f.mode, S)), (y.return = f), (f = y);
          }
          return a(f);
        case Pr:
          return (A = g._init), m(f, y, A(g._payload), S);
      }
      if (tl(g)) return v(f, y, g, S);
      if (Oo(g)) return x(f, y, g, S);
      $c(f, g);
    }
    return (typeof g == "string" && g !== "") || typeof g == "number"
      ? ((g = "" + g),
        y !== null && y.tag === 6
          ? (n(f, y.sibling), (y = r(y, g)), (y.return = f), (f = y))
          : (n(f, y), (y = tf(g, f.mode, S)), (y.return = f), (f = y)),
        a(f))
      : n(f, y);
  }
  return m;
}
var co = Rw(!0),
  Pw = Rw(!1),
  ld = cs(null),
  cd = null,
  Ba = null,
  fg = null;
function pg() {
  fg = Ba = cd = null;
}
function mg(t) {
  var e = ld.current;
  _t(ld), (t._currentValue = e);
}
function Ip(t, e, n) {
  for (; t !== null; ) {
    var i = t.alternate;
    if (
      ((t.childLanes & e) !== e
        ? ((t.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      t === n)
    )
      break;
    t = t.return;
  }
}
function eo(t, e) {
  (cd = t),
    (fg = Ba = null),
    (t = t.dependencies),
    t !== null &&
      t.firstContext !== null &&
      (t.lanes & e && (Rn = !0), (t.firstContext = null));
}
function si(t) {
  var e = t._currentValue;
  if (fg !== t)
    if (
      ((t = {
        context: t,
        memoizedValue: e,
        next: null,
      }),
      Ba === null)
    ) {
      if (cd === null) throw Error(ne(308));
      (Ba = t),
        (cd.dependencies = {
          lanes: 0,
          firstContext: t,
        });
    } else Ba = Ba.next = t;
  return e;
}
var Is = null;
function gg(t) {
  Is === null ? (Is = [t]) : Is.push(t);
}
function Lw(t, e, n, i) {
  var r = e.interleaved;
  return (
    r === null ? ((n.next = n), gg(e)) : ((n.next = r.next), (r.next = n)),
    (e.interleaved = n),
    fr(t, i)
  );
}
function fr(t, e) {
  t.lanes |= e;
  var n = t.alternate;
  for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null; )
    (t.childLanes |= e),
      (n = t.alternate),
      n !== null && (n.childLanes |= e),
      (n = t),
      (t = t.return);
  return n.tag === 3 ? n.stateNode : null;
}
var Lr = !1;
function vg(t) {
  t.updateQueue = {
    baseState: t.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: {
      pending: null,
      interleaved: null,
      lanes: 0,
    },
    effects: null,
  };
}
function Nw(t, e) {
  (t = t.updateQueue),
    e.updateQueue === t &&
      (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects,
      });
}
function lr(t, e) {
  return {
    eventTime: t,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Wr(t, e, n) {
  var i = t.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), st & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      fr(t, n)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), gg(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    fr(t, n)
  );
}
function Iu(t, e, n) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (n & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), ng(t, n);
  }
}
function w0(t, e) {
  var n = t.updateQueue,
    i = t.alternate;
  if (i !== null && ((i = i.updateQueue), n === i)) {
    var r = null,
      s = null;
    if (((n = n.firstBaseUpdate), n !== null)) {
      do {
        var a = {
          eventTime: n.eventTime,
          lane: n.lane,
          tag: n.tag,
          payload: n.payload,
          callback: n.callback,
          next: null,
        };
        s === null ? (r = s = a) : (s = s.next = a), (n = n.next);
      } while (n !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (n = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (t.updateQueue = n);
    return;
  }
  (t = n.lastBaseUpdate),
    t === null ? (n.firstBaseUpdate = e) : (t.next = e),
    (n.lastBaseUpdate = e);
}
function ud(t, e, n, i) {
  var r = t.updateQueue;
  Lr = !1;
  var s = r.firstBaseUpdate,
    a = r.lastBaseUpdate,
    o = r.shared.pending;
  if (o !== null) {
    r.shared.pending = null;
    var l = o,
      c = l.next;
    (l.next = null), a === null ? (s = c) : (a.next = c), (a = l);
    var u = t.alternate;
    u !== null &&
      ((u = u.updateQueue),
      (o = u.lastBaseUpdate),
      o !== a &&
        (o === null ? (u.firstBaseUpdate = c) : (o.next = c),
        (u.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = r.baseState;
    (a = 0), (u = c = l = null), (o = s);
    do {
      var h = o.lane,
        p = o.eventTime;
      if ((i & h) === h) {
        u !== null &&
          (u = u.next =
            {
              eventTime: p,
              lane: 0,
              tag: o.tag,
              payload: o.payload,
              callback: o.callback,
              next: null,
            });
        e: {
          var v = t,
            x = o;
          switch (((h = e), (p = n), x.tag)) {
            case 1:
              if (((v = x.payload), typeof v == "function")) {
                d = v.call(p, d, h);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = x.payload),
                (h = typeof v == "function" ? v.call(p, d, h) : v),
                h == null)
              )
                break e;
              d = At({}, d, h);
              break e;
            case 2:
              Lr = !0;
          }
        }
        o.callback !== null &&
          o.lane !== 0 &&
          ((t.flags |= 64),
          (h = r.effects),
          h === null ? (r.effects = [o]) : h.push(o));
      } else
        (p = {
          eventTime: p,
          lane: h,
          tag: o.tag,
          payload: o.payload,
          callback: o.callback,
          next: null,
        }),
          u === null ? ((c = u = p), (l = d)) : (u = u.next = p),
          (a |= h);
      if (((o = o.next), o === null)) {
        if (((o = r.shared.pending), o === null)) break;
        (h = o),
          (o = h.next),
          (h.next = null),
          (r.lastBaseUpdate = h),
          (r.shared.pending = null);
      }
    } while (!0);
    if (
      (u === null && (l = d),
      (r.baseState = l),
      (r.firstBaseUpdate = c),
      (r.lastBaseUpdate = u),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (a |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (Ys |= a), (t.lanes = a), (t.memoizedState = d);
  }
}
function E0(t, e, n) {
  if (((t = e.effects), (e.effects = null), t !== null))
    for (e = 0; e < t.length; e++) {
      var i = t[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = n), typeof r != "function"))
          throw Error(ne(191, r));
        r.call(i);
      }
    }
}
var vc = {},
  Oi = cs(vc),
  zl = cs(vc),
  jl = cs(vc);
function Us(t) {
  if (t === vc) throw Error(ne(174));
  return t;
}
function _g(t, e) {
  switch ((mt(jl, e), mt(zl, t), mt(Oi, vc), (t = e.nodeType), t)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : mp(null, "");
      break;
    default:
      (t = t === 8 ? e.parentNode : e),
        (e = t.namespaceURI || null),
        (t = t.tagName),
        (e = mp(e, t));
  }
  _t(Oi), mt(Oi, e);
}
function uo() {
  _t(Oi), _t(zl), _t(jl);
}
function Dw(t) {
  Us(jl.current);
  var e = Us(Oi.current),
    n = mp(e, t.type);
  e !== n && (mt(zl, t), mt(Oi, n));
}
function yg(t) {
  zl.current === t && (_t(Oi), _t(zl));
}
var Tt = cs(0);
function dd(t) {
  for (var e = t; e !== null; ) {
    if (e.tag === 13) {
      var n = e.memoizedState;
      if (
        n !== null &&
        ((n = n.dehydrated), n === null || n.data === "$?" || n.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === t) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === t) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var Yh = [];
function xg() {
  for (var t = 0; t < Yh.length; t++)
    Yh[t]._workInProgressVersionPrimary = null;
  Yh.length = 0;
}
var Uu = vr.ReactCurrentDispatcher,
  Zh = vr.ReactCurrentBatchConfig,
  qs = 0,
  bt = null,
  Bt = null,
  qt = null,
  hd = !1,
  gl = !1,
  Vl = 0,
  VA = 0;
function rn() {
  throw Error(ne(321));
}
function Sg(t, e) {
  if (e === null) return !1;
  for (var n = 0; n < e.length && n < t.length; n++)
    if (!Ti(t[n], e[n])) return !1;
  return !0;
}
function wg(t, e, n, i, r, s) {
  if (
    ((qs = s),
    (bt = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (Uu.current = t === null || t.memoizedState === null ? $A : XA),
    (t = n(i, r)),
    gl)
  ) {
    s = 0;
    do {
      if (((gl = !1), (Vl = 0), 25 <= s)) throw Error(ne(301));
      (s += 1),
        (qt = Bt = null),
        (e.updateQueue = null),
        (Uu.current = qA),
        (t = n(i, r));
    } while (gl);
  }
  if (
    ((Uu.current = fd),
    (e = Bt !== null && Bt.next !== null),
    (qs = 0),
    (qt = Bt = bt = null),
    (hd = !1),
    e)
  )
    throw Error(ne(300));
  return t;
}
function Eg() {
  var t = Vl !== 0;
  return (Vl = 0), t;
}
function Pi() {
  var t = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return qt === null ? (bt.memoizedState = qt = t) : (qt = qt.next = t), qt;
}
function ai() {
  if (Bt === null) {
    var t = bt.alternate;
    t = t !== null ? t.memoizedState : null;
  } else t = Bt.next;
  var e = qt === null ? bt.memoizedState : qt.next;
  if (e !== null) (qt = e), (Bt = t);
  else {
    if (t === null) throw Error(ne(310));
    (Bt = t),
      (t = {
        memoizedState: Bt.memoizedState,
        baseState: Bt.baseState,
        baseQueue: Bt.baseQueue,
        queue: Bt.queue,
        next: null,
      }),
      qt === null ? (bt.memoizedState = qt = t) : (qt = qt.next = t);
  }
  return qt;
}
function Hl(t, e) {
  return typeof e == "function" ? e(t) : e;
}
function Kh(t) {
  var e = ai(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var i = Bt,
    r = i.baseQueue,
    s = n.pending;
  if (s !== null) {
    if (r !== null) {
      var a = r.next;
      (r.next = s.next), (s.next = a);
    }
    (i.baseQueue = r = s), (n.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var o = (a = null),
      l = null,
      c = s;
    do {
      var u = c.lane;
      if ((qs & u) === u)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (i = c.hasEagerState ? c.eagerState : t(i, c.action));
      else {
        var d = {
          lane: u,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((o = l = d), (a = i)) : (l = l.next = d),
          (bt.lanes |= u),
          (Ys |= u);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (a = i) : (l.next = o),
      Ti(i, e.memoizedState) || (Rn = !0),
      (e.memoizedState = i),
      (e.baseState = a),
      (e.baseQueue = l),
      (n.lastRenderedState = i);
  }
  if (((t = n.interleaved), t !== null)) {
    r = t;
    do (s = r.lane), (bt.lanes |= s), (Ys |= s), (r = r.next);
    while (r !== t);
  } else r === null && (n.lanes = 0);
  return [e.memoizedState, n.dispatch];
}
function Jh(t) {
  var e = ai(),
    n = e.queue;
  if (n === null) throw Error(ne(311));
  n.lastRenderedReducer = t;
  var i = n.dispatch,
    r = n.pending,
    s = e.memoizedState;
  if (r !== null) {
    n.pending = null;
    var a = (r = r.next);
    do (s = t(s, a.action)), (a = a.next);
    while (a !== r);
    Ti(s, e.memoizedState) || (Rn = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (n.lastRenderedState = s);
  }
  return [s, i];
}
function kw() {}
function Iw(t, e) {
  var n = bt,
    i = ai(),
    r = e(),
    s = !Ti(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (Rn = !0)),
    (i = i.queue),
    Tg(Fw.bind(null, n, i, t), [t]),
    i.getSnapshot !== e || s || (qt !== null && qt.memoizedState.tag & 1))
  ) {
    if (
      ((n.flags |= 2048),
      Gl(9, Ow.bind(null, n, i, r, e), void 0, null),
      Yt === null)
    )
      throw Error(ne(349));
    qs & 30 || Uw(n, e, r);
  }
  return r;
}
function Uw(t, e, n) {
  (t.flags |= 16384),
    (t = {
      getSnapshot: e,
      value: n,
    }),
    (e = bt.updateQueue),
    e === null
      ? ((e = {
          lastEffect: null,
          stores: null,
        }),
        (bt.updateQueue = e),
        (e.stores = [t]))
      : ((n = e.stores), n === null ? (e.stores = [t]) : n.push(t));
}
function Ow(t, e, n, i) {
  (e.value = n), (e.getSnapshot = i), Bw(e) && zw(t);
}
function Fw(t, e, n) {
  return n(function () {
    Bw(e) && zw(t);
  });
}
function Bw(t) {
  var e = t.getSnapshot;
  t = t.value;
  try {
    var n = e();
    return !Ti(t, n);
  } catch {
    return !0;
  }
}
function zw(t) {
  var e = fr(t, 1);
  e !== null && Si(e, t, 1, -1);
}
function T0(t) {
  var e = Pi();
  return (
    typeof t == "function" && (t = t()),
    (e.memoizedState = e.baseState = t),
    (t = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Hl,
      lastRenderedState: t,
    }),
    (e.queue = t),
    (t = t.dispatch = WA.bind(null, bt, t)),
    [e.memoizedState, t]
  );
}
function Gl(t, e, n, i) {
  return (
    (t = {
      tag: t,
      create: e,
      destroy: n,
      deps: i,
      next: null,
    }),
    (e = bt.updateQueue),
    e === null
      ? ((e = {
          lastEffect: null,
          stores: null,
        }),
        (bt.updateQueue = e),
        (e.lastEffect = t.next = t))
      : ((n = e.lastEffect),
        n === null
          ? (e.lastEffect = t.next = t)
          : ((i = n.next), (n.next = t), (t.next = i), (e.lastEffect = t))),
    t
  );
}
function jw() {
  return ai().memoizedState;
}
function Ou(t, e, n, i) {
  var r = Pi();
  (bt.flags |= t),
    (r.memoizedState = Gl(1 | e, n, void 0, i === void 0 ? null : i));
}
function Zd(t, e, n, i) {
  var r = ai();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Bt !== null) {
    var a = Bt.memoizedState;
    if (((s = a.destroy), i !== null && Sg(i, a.deps))) {
      r.memoizedState = Gl(e, n, s, i);
      return;
    }
  }
  (bt.flags |= t), (r.memoizedState = Gl(1 | e, n, s, i));
}
function M0(t, e) {
  return Ou(8390656, 8, t, e);
}
function Tg(t, e) {
  return Zd(2048, 8, t, e);
}
function Vw(t, e) {
  return Zd(4, 2, t, e);
}
function Hw(t, e) {
  return Zd(4, 4, t, e);
}
function Gw(t, e) {
  if (typeof e == "function")
    return (
      (t = t()),
      e(t),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (t = t()),
      (e.current = t),
      function () {
        e.current = null;
      }
    );
}
function Ww(t, e, n) {
  return (
    (n = n != null ? n.concat([t]) : null), Zd(4, 4, Gw.bind(null, e, t), n)
  );
}
function Mg() {}
function $w(t, e) {
  var n = ai();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && Sg(e, i[1])
    ? i[0]
    : ((n.memoizedState = [t, e]), t);
}
function Xw(t, e) {
  var n = ai();
  e = e === void 0 ? null : e;
  var i = n.memoizedState;
  return i !== null && e !== null && Sg(e, i[1])
    ? i[0]
    : ((t = t()), (n.memoizedState = [t, e]), t);
}
function qw(t, e, n) {
  return qs & 21
    ? (Ti(n, e) || ((n = QS()), (bt.lanes |= n), (Ys |= n), (t.baseState = !0)),
      e)
    : (t.baseState && ((t.baseState = !1), (Rn = !0)), (t.memoizedState = n));
}
function HA(t, e) {
  var n = ut;
  (ut = n !== 0 && 4 > n ? n : 4), t(!0);
  var i = Zh.transition;
  Zh.transition = {};
  try {
    t(!1), e();
  } finally {
    (ut = n), (Zh.transition = i);
  }
}
function Yw() {
  return ai().memoizedState;
}
function GA(t, e, n) {
  var i = Xr(t);
  if (
    ((n = {
      lane: i,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    Zw(t))
  )
    Kw(e, n);
  else if (((n = Lw(t, e, n, i)), n !== null)) {
    var r = _n();
    Si(n, t, i, r), Jw(n, e, i);
  }
}
function WA(t, e, n) {
  var i = Xr(t),
    r = {
      lane: i,
      action: n,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    };
  if (Zw(t)) Kw(e, r);
  else {
    var s = t.alternate;
    if (
      t.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var a = e.lastRenderedState,
          o = s(a, n);
        if (((r.hasEagerState = !0), (r.eagerState = o), Ti(o, a))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), gg(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (n = Lw(t, e, r, i)),
      n !== null && ((r = _n()), Si(n, t, i, r), Jw(n, e, i));
  }
}
function Zw(t) {
  var e = t.alternate;
  return t === bt || (e !== null && e === bt);
}
function Kw(t, e) {
  gl = hd = !0;
  var n = t.pending;
  n === null ? (e.next = e) : ((e.next = n.next), (n.next = e)),
    (t.pending = e);
}
function Jw(t, e, n) {
  if (n & 4194240) {
    var i = e.lanes;
    (i &= t.pendingLanes), (n |= i), (e.lanes = n), ng(t, n);
  }
}
var fd = {
    readContext: si,
    useCallback: rn,
    useContext: rn,
    useEffect: rn,
    useImperativeHandle: rn,
    useInsertionEffect: rn,
    useLayoutEffect: rn,
    useMemo: rn,
    useReducer: rn,
    useRef: rn,
    useState: rn,
    useDebugValue: rn,
    useDeferredValue: rn,
    useTransition: rn,
    useMutableSource: rn,
    useSyncExternalStore: rn,
    useId: rn,
    unstable_isNewReconciler: !1,
  },
  $A = {
    readContext: si,
    useCallback: function (t, e) {
      return (Pi().memoizedState = [t, e === void 0 ? null : e]), t;
    },
    useContext: si,
    useEffect: M0,
    useImperativeHandle: function (t, e, n) {
      return (
        (n = n != null ? n.concat([t]) : null),
        Ou(4194308, 4, Gw.bind(null, e, t), n)
      );
    },
    useLayoutEffect: function (t, e) {
      return Ou(4194308, 4, t, e);
    },
    useInsertionEffect: function (t, e) {
      return Ou(4, 2, t, e);
    },
    useMemo: function (t, e) {
      var n = Pi();
      return (
        (e = e === void 0 ? null : e), (t = t()), (n.memoizedState = [t, e]), t
      );
    },
    useReducer: function (t, e, n) {
      var i = Pi();
      return (
        (e = n !== void 0 ? n(e) : e),
        (i.memoizedState = i.baseState = e),
        (t = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: t,
          lastRenderedState: e,
        }),
        (i.queue = t),
        (t = t.dispatch = GA.bind(null, bt, t)),
        [i.memoizedState, t]
      );
    },
    useRef: function (t) {
      var e = Pi();
      return (
        (t = {
          current: t,
        }),
        (e.memoizedState = t)
      );
    },
    useState: T0,
    useDebugValue: Mg,
    useDeferredValue: function (t) {
      return (Pi().memoizedState = t);
    },
    useTransition: function () {
      var t = T0(!1),
        e = t[0];
      return (t = HA.bind(null, t[1])), (Pi().memoizedState = t), [e, t];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (t, e, n) {
      var i = bt,
        r = Pi();
      if (St) {
        if (n === void 0) throw Error(ne(407));
        n = n();
      } else {
        if (((n = e()), Yt === null)) throw Error(ne(349));
        qs & 30 || Uw(i, e, n);
      }
      r.memoizedState = n;
      var s = {
        value: n,
        getSnapshot: e,
      };
      return (
        (r.queue = s),
        M0(Fw.bind(null, i, s, t), [t]),
        (i.flags |= 2048),
        Gl(9, Ow.bind(null, i, s, n, e), void 0, null),
        n
      );
    },
    useId: function () {
      var t = Pi(),
        e = Yt.identifierPrefix;
      if (St) {
        var n = sr,
          i = rr;
        (n = (i & ~(1 << (32 - xi(i) - 1))).toString(32) + n),
          (e = ":" + e + "R" + n),
          (n = Vl++),
          0 < n && (e += "H" + n.toString(32)),
          (e += ":");
      } else (n = VA++), (e = ":" + e + "r" + n.toString(32) + ":");
      return (t.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  XA = {
    readContext: si,
    useCallback: $w,
    useContext: si,
    useEffect: Tg,
    useImperativeHandle: Ww,
    useInsertionEffect: Vw,
    useLayoutEffect: Hw,
    useMemo: Xw,
    useReducer: Kh,
    useRef: jw,
    useState: function () {
      return Kh(Hl);
    },
    useDebugValue: Mg,
    useDeferredValue: function (t) {
      var e = ai();
      return qw(e, Bt.memoizedState, t);
    },
    useTransition: function () {
      var t = Kh(Hl)[0],
        e = ai().memoizedState;
      return [t, e];
    },
    useMutableSource: kw,
    useSyncExternalStore: Iw,
    useId: Yw,
    unstable_isNewReconciler: !1,
  },
  qA = {
    readContext: si,
    useCallback: $w,
    useContext: si,
    useEffect: Tg,
    useImperativeHandle: Ww,
    useInsertionEffect: Vw,
    useLayoutEffect: Hw,
    useMemo: Xw,
    useReducer: Jh,
    useRef: jw,
    useState: function () {
      return Jh(Hl);
    },
    useDebugValue: Mg,
    useDeferredValue: function (t) {
      var e = ai();
      return Bt === null ? (e.memoizedState = t) : qw(e, Bt.memoizedState, t);
    },
    useTransition: function () {
      var t = Jh(Hl)[0],
        e = ai().memoizedState;
      return [t, e];
    },
    useMutableSource: kw,
    useSyncExternalStore: Iw,
    useId: Yw,
    unstable_isNewReconciler: !1,
  };
function fi(t, e) {
  if (t && t.defaultProps) {
    (e = At({}, e)), (t = t.defaultProps);
    for (var n in t) e[n] === void 0 && (e[n] = t[n]);
    return e;
  }
  return e;
}
function Up(t, e, n, i) {
  (e = t.memoizedState),
    (n = n(i, e)),
    (n = n == null ? e : At({}, e, n)),
    (t.memoizedState = n),
    t.lanes === 0 && (t.updateQueue.baseState = n);
}
var Kd = {
  isMounted: function (t) {
    return (t = t._reactInternals) ? ia(t) === t : !1;
  },
  enqueueSetState: function (t, e, n) {
    t = t._reactInternals;
    var i = _n(),
      r = Xr(t),
      s = lr(i, r);
    (s.payload = e),
      n != null && (s.callback = n),
      (e = Wr(t, s, r)),
      e !== null && (Si(e, t, r, i), Iu(e, t, r));
  },
  enqueueReplaceState: function (t, e, n) {
    t = t._reactInternals;
    var i = _n(),
      r = Xr(t),
      s = lr(i, r);
    (s.tag = 1),
      (s.payload = e),
      n != null && (s.callback = n),
      (e = Wr(t, s, r)),
      e !== null && (Si(e, t, r, i), Iu(e, t, r));
  },
  enqueueForceUpdate: function (t, e) {
    t = t._reactInternals;
    var n = _n(),
      i = Xr(t),
      r = lr(n, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = Wr(t, r, i)),
      e !== null && (Si(e, t, i, n), Iu(e, t, i));
  },
};
function b0(t, e, n, i, r, s, a) {
  return (
    (t = t.stateNode),
    typeof t.shouldComponentUpdate == "function"
      ? t.shouldComponentUpdate(i, s, a)
      : e.prototype && e.prototype.isPureReactComponent
      ? !Ul(n, i) || !Ul(r, s)
      : !0
  );
}
function Qw(t, e, n) {
  var i = !1,
    r = es,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = si(s))
      : ((r = Ln(e) ? $s : hn.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? oo(t, r) : es)),
    (e = new e(n, s)),
    (t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = Kd),
    (t.stateNode = e),
    (e._reactInternals = t),
    i &&
      ((t = t.stateNode),
      (t.__reactInternalMemoizedUnmaskedChildContext = r),
      (t.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function A0(t, e, n, i) {
  (t = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(n, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(n, i),
    e.state !== t && Kd.enqueueReplaceState(e, e.state, null);
}
function Op(t, e, n, i) {
  var r = t.stateNode;
  (r.props = n), (r.state = t.memoizedState), (r.refs = {}), vg(t);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = si(s))
    : ((s = Ln(e) ? $s : hn.current), (r.context = oo(t, s))),
    (r.state = t.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (Up(t, e, s, n), (r.state = t.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && Kd.enqueueReplaceState(r, r.state, null),
      ud(t, n, r, i),
      (r.state = t.memoizedState)),
    typeof r.componentDidMount == "function" && (t.flags |= 4194308);
}
function ho(t, e) {
  try {
    var n = "",
      i = e;
    do (n += wb(i)), (i = i.return);
    while (i);
    var r = n;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return {
    value: t,
    source: e,
    stack: r,
    digest: null,
  };
}
function Qh(t, e, n) {
  return {
    value: t,
    source: null,
    stack: n ?? null,
    digest: e ?? null,
  };
}
function Fp(t, e) {
  try {
    console.error(e.value);
  } catch (n) {
    setTimeout(function () {
      throw n;
    });
  }
}
var YA = typeof WeakMap == "function" ? WeakMap : Map;
function eE(t, e, n) {
  (n = lr(-1, n)),
    (n.tag = 3),
    (n.payload = {
      element: null,
    });
  var i = e.value;
  return (
    (n.callback = function () {
      md || ((md = !0), (qp = i)), Fp(t, e);
    }),
    n
  );
}
function tE(t, e, n) {
  (n = lr(-1, n)), (n.tag = 3);
  var i = t.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (n.payload = function () {
      return i(r);
    }),
      (n.callback = function () {
        Fp(t, e);
      });
  }
  var s = t.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (n.callback = function () {
        Fp(t, e),
          typeof i != "function" &&
            ($r === null ? ($r = new Set([this])) : $r.add(this));
        var a = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: a !== null ? a : "",
        });
      }),
    n
  );
}
function C0(t, e, n) {
  var i = t.pingCache;
  if (i === null) {
    i = t.pingCache = new YA();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(n) || (r.add(n), (t = cC.bind(null, t, e, n)), e.then(t, t));
}
function R0(t) {
  do {
    var e;
    if (
      ((e = t.tag === 13) &&
        ((e = t.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return t;
    t = t.return;
  } while (t !== null);
  return null;
}
function P0(t, e, n, i, r) {
  return t.mode & 1
    ? ((t.flags |= 65536), (t.lanes = r), t)
    : (t === e
        ? (t.flags |= 65536)
        : ((t.flags |= 128),
          (n.flags |= 131072),
          (n.flags &= -52805),
          n.tag === 1 &&
            (n.alternate === null
              ? (n.tag = 17)
              : ((e = lr(-1, 1)), (e.tag = 2), Wr(n, e, 1))),
          (n.lanes |= 1)),
      t);
}
var ZA = vr.ReactCurrentOwner,
  Rn = !1;
function gn(t, e, n, i) {
  e.child = t === null ? Pw(e, null, n, i) : co(e, t.child, n, i);
}
function L0(t, e, n, i, r) {
  n = n.render;
  var s = e.ref;
  return (
    eo(e, r),
    (i = wg(t, e, n, i, s, r)),
    (n = Eg()),
    t !== null && !Rn
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~r),
        pr(t, e, r))
      : (St && n && ug(e), (e.flags |= 1), gn(t, e, i, r), e.child)
  );
}
function N0(t, e, n, i, r) {
  if (t === null) {
    var s = n.type;
    return typeof s == "function" &&
      !Dg(s) &&
      s.defaultProps === void 0 &&
      n.compare === null &&
      n.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), nE(t, e, s, i, r))
      : ((t = ju(n.type, null, i, e, e.mode, r)),
        (t.ref = e.ref),
        (t.return = e),
        (e.child = t));
  }
  if (((s = t.child), !(t.lanes & r))) {
    var a = s.memoizedProps;
    if (
      ((n = n.compare), (n = n !== null ? n : Ul), n(a, i) && t.ref === e.ref)
    )
      return pr(t, e, r);
  }
  return (
    (e.flags |= 1),
    (t = qr(s, i)),
    (t.ref = e.ref),
    (t.return = e),
    (e.child = t)
  );
}
function nE(t, e, n, i, r) {
  if (t !== null) {
    var s = t.memoizedProps;
    if (Ul(s, i) && t.ref === e.ref)
      if (((Rn = !1), (e.pendingProps = i = s), (t.lanes & r) !== 0))
        t.flags & 131072 && (Rn = !0);
      else return (e.lanes = t.lanes), pr(t, e, r);
  }
  return Bp(t, e, n, i, r);
}
function iE(t, e, n) {
  var i = e.pendingProps,
    r = i.children,
    s = t !== null ? t.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null,
      }),
        mt(ja, zn),
        (zn |= n);
    else {
      if (!(n & 1073741824))
        return (
          (t = s !== null ? s.baseLanes | n : n),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: t,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          mt(ja, zn),
          (zn |= t),
          null
        );
      (e.memoizedState = {
        baseLanes: 0,
        cachePool: null,
        transitions: null,
      }),
        (i = s !== null ? s.baseLanes : n),
        mt(ja, zn),
        (zn |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | n), (e.memoizedState = null)) : (i = n),
      mt(ja, zn),
      (zn |= i);
  return gn(t, e, r, n), e.child;
}
function rE(t, e) {
  var n = e.ref;
  ((t === null && n !== null) || (t !== null && t.ref !== n)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Bp(t, e, n, i, r) {
  var s = Ln(n) ? $s : hn.current;
  return (
    (s = oo(e, s)),
    eo(e, r),
    (n = wg(t, e, n, i, s, r)),
    (i = Eg()),
    t !== null && !Rn
      ? ((e.updateQueue = t.updateQueue),
        (e.flags &= -2053),
        (t.lanes &= ~r),
        pr(t, e, r))
      : (St && i && ug(e), (e.flags |= 1), gn(t, e, n, r), e.child)
  );
}
function D0(t, e, n, i, r) {
  if (Ln(n)) {
    var s = !0;
    sd(e);
  } else s = !1;
  if ((eo(e, r), e.stateNode === null))
    Fu(t, e), Qw(e, n, i), Op(e, n, i, r), (i = !0);
  else if (t === null) {
    var a = e.stateNode,
      o = e.memoizedProps;
    a.props = o;
    var l = a.context,
      c = n.contextType;
    typeof c == "object" && c !== null
      ? (c = si(c))
      : ((c = Ln(n) ? $s : hn.current), (c = oo(e, c)));
    var u = n.getDerivedStateFromProps,
      d =
        typeof u == "function" ||
        typeof a.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((o !== i || l !== c) && A0(e, a, i, c)),
      (Lr = !1);
    var h = e.memoizedState;
    (a.state = h),
      ud(e, i, a, r),
      (l = e.memoizedState),
      o !== i || h !== l || Pn.current || Lr
        ? (typeof u == "function" && (Up(e, n, u, i), (l = e.memoizedState)),
          (o = Lr || b0(e, n, o, i, h, l, c))
            ? (d ||
                (typeof a.UNSAFE_componentWillMount != "function" &&
                  typeof a.componentWillMount != "function") ||
                (typeof a.componentWillMount == "function" &&
                  a.componentWillMount(),
                typeof a.UNSAFE_componentWillMount == "function" &&
                  a.UNSAFE_componentWillMount()),
              typeof a.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (a.props = i),
          (a.state = l),
          (a.context = c),
          (i = o))
        : (typeof a.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (a = e.stateNode),
      Nw(t, e),
      (o = e.memoizedProps),
      (c = e.type === e.elementType ? o : fi(e.type, o)),
      (a.props = c),
      (d = e.pendingProps),
      (h = a.context),
      (l = n.contextType),
      typeof l == "object" && l !== null
        ? (l = si(l))
        : ((l = Ln(n) ? $s : hn.current), (l = oo(e, l)));
    var p = n.getDerivedStateFromProps;
    (u =
      typeof p == "function" ||
      typeof a.getSnapshotBeforeUpdate == "function") ||
      (typeof a.UNSAFE_componentWillReceiveProps != "function" &&
        typeof a.componentWillReceiveProps != "function") ||
      ((o !== d || h !== l) && A0(e, a, i, l)),
      (Lr = !1),
      (h = e.memoizedState),
      (a.state = h),
      ud(e, i, a, r);
    var v = e.memoizedState;
    o !== d || h !== v || Pn.current || Lr
      ? (typeof p == "function" && (Up(e, n, p, i), (v = e.memoizedState)),
        (c = Lr || b0(e, n, c, i, h, v, l) || !1)
          ? (u ||
              (typeof a.UNSAFE_componentWillUpdate != "function" &&
                typeof a.componentWillUpdate != "function") ||
              (typeof a.componentWillUpdate == "function" &&
                a.componentWillUpdate(i, v, l),
              typeof a.UNSAFE_componentWillUpdate == "function" &&
                a.UNSAFE_componentWillUpdate(i, v, l)),
            typeof a.componentDidUpdate == "function" && (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof a.componentDidUpdate != "function" ||
              (o === t.memoizedProps && h === t.memoizedState) ||
              (e.flags |= 4),
            typeof a.getSnapshotBeforeUpdate != "function" ||
              (o === t.memoizedProps && h === t.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = v)),
        (a.props = i),
        (a.state = v),
        (a.context = l),
        (i = c))
      : (typeof a.componentDidUpdate != "function" ||
          (o === t.memoizedProps && h === t.memoizedState) ||
          (e.flags |= 4),
        typeof a.getSnapshotBeforeUpdate != "function" ||
          (o === t.memoizedProps && h === t.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return zp(t, e, n, i, s, r);
}
function zp(t, e, n, i, r, s) {
  rE(t, e);
  var a = (e.flags & 128) !== 0;
  if (!i && !a) return r && _0(e, n, !1), pr(t, e, s);
  (i = e.stateNode), (ZA.current = e);
  var o =
    a && typeof n.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    t !== null && a
      ? ((e.child = co(e, t.child, null, s)), (e.child = co(e, null, o, s)))
      : gn(t, e, o, s),
    (e.memoizedState = i.state),
    r && _0(e, n, !0),
    e.child
  );
}
function sE(t) {
  var e = t.stateNode;
  e.pendingContext
    ? v0(t, e.pendingContext, e.pendingContext !== e.context)
    : e.context && v0(t, e.context, !1),
    _g(t, e.containerInfo);
}
function k0(t, e, n, i, r) {
  return lo(), hg(r), (e.flags |= 256), gn(t, e, n, i), e.child;
}
var jp = {
  dehydrated: null,
  treeContext: null,
  retryLane: 0,
};
function Vp(t) {
  return {
    baseLanes: t,
    cachePool: null,
    transitions: null,
  };
}
function aE(t, e, n) {
  var i = e.pendingProps,
    r = Tt.current,
    s = !1,
    a = (e.flags & 128) !== 0,
    o;
  if (
    ((o = a) ||
      (o = t !== null && t.memoizedState === null ? !1 : (r & 2) !== 0),
    o
      ? ((s = !0), (e.flags &= -129))
      : (t === null || t.memoizedState !== null) && (r |= 1),
    mt(Tt, r & 1),
    t === null)
  )
    return (
      kp(e),
      (t = e.memoizedState),
      t !== null && ((t = t.dehydrated), t !== null)
        ? (e.mode & 1
            ? t.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((a = i.children),
          (t = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (a = {
                mode: "hidden",
                children: a,
              }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = a))
                : (s = eh(a, i, 0, null)),
              (t = zs(t, i, n, null)),
              (s.return = e),
              (t.return = e),
              (s.sibling = t),
              (e.child = s),
              (e.child.memoizedState = Vp(n)),
              (e.memoizedState = jp),
              t)
            : bg(e, a))
    );
  if (((r = t.memoizedState), r !== null && ((o = r.dehydrated), o !== null)))
    return KA(t, e, a, i, o, r, n);
  if (s) {
    (s = i.fallback), (a = e.mode), (r = t.child), (o = r.sibling);
    var l = {
      mode: "hidden",
      children: i.children,
    };
    return (
      !(a & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = qr(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      o !== null ? (s = qr(o, s)) : ((s = zs(s, a, n, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (a = t.child.memoizedState),
      (a =
        a === null
          ? Vp(n)
          : {
              baseLanes: a.baseLanes | n,
              cachePool: null,
              transitions: a.transitions,
            }),
      (s.memoizedState = a),
      (s.childLanes = t.childLanes & ~n),
      (e.memoizedState = jp),
      i
    );
  }
  return (
    (s = t.child),
    (t = s.sibling),
    (i = qr(s, {
      mode: "visible",
      children: i.children,
    })),
    !(e.mode & 1) && (i.lanes = n),
    (i.return = e),
    (i.sibling = null),
    t !== null &&
      ((n = e.deletions),
      n === null ? ((e.deletions = [t]), (e.flags |= 16)) : n.push(t)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function bg(t, e) {
  return (
    (e = eh(
      {
        mode: "visible",
        children: e,
      },
      t.mode,
      0,
      null
    )),
    (e.return = t),
    (t.child = e)
  );
}
function Xc(t, e, n, i) {
  return (
    i !== null && hg(i),
    co(e, t.child, null, n),
    (t = bg(e, e.pendingProps.children)),
    (t.flags |= 2),
    (e.memoizedState = null),
    t
  );
}
function KA(t, e, n, i, r, s, a) {
  if (n)
    return e.flags & 256
      ? ((e.flags &= -257), (i = Qh(Error(ne(422)))), Xc(t, e, a, i))
      : e.memoizedState !== null
      ? ((e.child = t.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = eh(
          {
            mode: "visible",
            children: i.children,
          },
          r,
          0,
          null
        )),
        (s = zs(s, r, a, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && co(e, t.child, null, a),
        (e.child.memoizedState = Vp(a)),
        (e.memoizedState = jp),
        s);
  if (!(e.mode & 1)) return Xc(t, e, a, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var o = i.dgst;
    return (
      (i = o), (s = Error(ne(419))), (i = Qh(s, i, void 0)), Xc(t, e, a, i)
    );
  }
  if (((o = (a & t.childLanes) !== 0), Rn || o)) {
    if (((i = Yt), i !== null)) {
      switch (a & -a) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | a) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), fr(t, r), Si(i, t, r, -1));
    }
    return Ng(), (i = Qh(Error(ne(421)))), Xc(t, e, a, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = t.child),
      (e = uC.bind(null, t)),
      (r._reactRetry = e),
      null)
    : ((t = s.treeContext),
      (jn = Gr(r.nextSibling)),
      (Vn = e),
      (St = !0),
      (gi = null),
      t !== null &&
        ((Qn[ei++] = rr),
        (Qn[ei++] = sr),
        (Qn[ei++] = Xs),
        (rr = t.id),
        (sr = t.overflow),
        (Xs = e)),
      (e = bg(e, i.children)),
      (e.flags |= 4096),
      e);
}
function I0(t, e, n) {
  t.lanes |= e;
  var i = t.alternate;
  i !== null && (i.lanes |= e), Ip(t.return, e, n);
}
function ef(t, e, n, i, r) {
  var s = t.memoizedState;
  s === null
    ? (t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: n,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = n),
      (s.tailMode = r));
}
function oE(t, e, n) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((gn(t, e, i.children, n), (i = Tt.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (t !== null && t.flags & 128)
      e: for (t = e.child; t !== null; ) {
        if (t.tag === 13) t.memoizedState !== null && I0(t, n, e);
        else if (t.tag === 19) I0(t, n, e);
        else if (t.child !== null) {
          (t.child.return = t), (t = t.child);
          continue;
        }
        if (t === e) break e;
        for (; t.sibling === null; ) {
          if (t.return === null || t.return === e) break e;
          t = t.return;
        }
        (t.sibling.return = t.return), (t = t.sibling);
      }
    i &= 1;
  }
  if ((mt(Tt, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (n = e.child, r = null; n !== null; )
          (t = n.alternate),
            t !== null && dd(t) === null && (r = n),
            (n = n.sibling);
        (n = r),
          n === null
            ? ((r = e.child), (e.child = null))
            : ((r = n.sibling), (n.sibling = null)),
          ef(e, !1, r, n, s);
        break;
      case "backwards":
        for (n = null, r = e.child, e.child = null; r !== null; ) {
          if (((t = r.alternate), t !== null && dd(t) === null)) {
            e.child = r;
            break;
          }
          (t = r.sibling), (r.sibling = n), (n = r), (r = t);
        }
        ef(e, !0, n, null, s);
        break;
      case "together":
        ef(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function Fu(t, e) {
  !(e.mode & 1) &&
    t !== null &&
    ((t.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function pr(t, e, n) {
  if (
    (t !== null && (e.dependencies = t.dependencies),
    (Ys |= e.lanes),
    !(n & e.childLanes))
  )
    return null;
  if (t !== null && e.child !== t.child) throw Error(ne(153));
  if (e.child !== null) {
    for (
      t = e.child, n = qr(t, t.pendingProps), e.child = n, n.return = e;
      t.sibling !== null;

    )
      (t = t.sibling), (n = n.sibling = qr(t, t.pendingProps)), (n.return = e);
    n.sibling = null;
  }
  return e.child;
}
function JA(t, e, n) {
  switch (e.tag) {
    case 3:
      sE(e), lo();
      break;
    case 5:
      Dw(e);
      break;
    case 1:
      Ln(e.type) && sd(e);
      break;
    case 4:
      _g(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      mt(ld, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (mt(Tt, Tt.current & 1), (e.flags |= 128), null)
          : n & e.child.childLanes
          ? aE(t, e, n)
          : (mt(Tt, Tt.current & 1),
            (t = pr(t, e, n)),
            t !== null ? t.sibling : null);
      mt(Tt, Tt.current & 1);
      break;
    case 19:
      if (((i = (n & e.childLanes) !== 0), t.flags & 128)) {
        if (i) return oE(t, e, n);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        mt(Tt, Tt.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), iE(t, e, n);
  }
  return pr(t, e, n);
}
var lE, Hp, cE, uE;
lE = function (t, e) {
  for (var n = e.child; n !== null; ) {
    if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode);
    else if (n.tag !== 4 && n.child !== null) {
      (n.child.return = n), (n = n.child);
      continue;
    }
    if (n === e) break;
    for (; n.sibling === null; ) {
      if (n.return === null || n.return === e) return;
      n = n.return;
    }
    (n.sibling.return = n.return), (n = n.sibling);
  }
};
Hp = function () {};
cE = function (t, e, n, i) {
  var r = t.memoizedProps;
  if (r !== i) {
    (t = e.stateNode), Us(Oi.current);
    var s = null;
    switch (n) {
      case "input":
        (r = dp(t, r)), (i = dp(t, i)), (s = []);
        break;
      case "select":
        (r = At({}, r, {
          value: void 0,
        })),
          (i = At({}, i, {
            value: void 0,
          })),
          (s = []);
        break;
      case "textarea":
        (r = pp(t, r)), (i = pp(t, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (t.onclick = id);
    }
    gp(n, i);
    var a;
    n = null;
    for (c in r)
      if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
        if (c === "style") {
          var o = r[c];
          for (a in o) o.hasOwnProperty(a) && (n || (n = {}), (n[a] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Rl.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in i) {
      var l = i[c];
      if (
        ((o = r != null ? r[c] : void 0),
        i.hasOwnProperty(c) && l !== o && (l != null || o != null))
      )
        if (c === "style")
          if (o) {
            for (a in o)
              !o.hasOwnProperty(a) ||
                (l && l.hasOwnProperty(a)) ||
                (n || (n = {}), (n[a] = ""));
            for (a in l)
              l.hasOwnProperty(a) &&
                o[a] !== l[a] &&
                (n || (n = {}), (n[a] = l[a]));
          } else n || (s || (s = []), s.push(c, n)), (n = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (o = o ? o.__html : void 0),
              l != null && o !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (Rl.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && gt("scroll", t),
                  s || o === l || (s = []))
                : (s = s || []).push(c, l));
    }
    n && (s = s || []).push("style", n);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
uE = function (t, e, n, i) {
  n !== i && (e.flags |= 4);
};
function Ho(t, e) {
  if (!St)
    switch (t.tailMode) {
      case "hidden":
        e = t.tail;
        for (var n = null; e !== null; )
          e.alternate !== null && (n = e), (e = e.sibling);
        n === null ? (t.tail = null) : (n.sibling = null);
        break;
      case "collapsed":
        n = t.tail;
        for (var i = null; n !== null; )
          n.alternate !== null && (i = n), (n = n.sibling);
        i === null
          ? e || t.tail === null
            ? (t.tail = null)
            : (t.tail.sibling = null)
          : (i.sibling = null);
    }
}
function sn(t) {
  var e = t.alternate !== null && t.alternate.child === t.child,
    n = 0,
    i = 0;
  if (e)
    for (var r = t.child; r !== null; )
      (n |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = t),
        (r = r.sibling);
  else
    for (r = t.child; r !== null; )
      (n |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = t),
        (r = r.sibling);
  return (t.subtreeFlags |= i), (t.childLanes = n), e;
}
function QA(t, e, n) {
  var i = e.pendingProps;
  switch ((dg(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return sn(e), null;
    case 1:
      return Ln(e.type) && rd(), sn(e), null;
    case 3:
      return (
        (i = e.stateNode),
        uo(),
        _t(Pn),
        _t(hn),
        xg(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (t === null || t.child === null) &&
          (Wc(e)
            ? (e.flags |= 4)
            : t === null ||
              (t.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), gi !== null && (Kp(gi), (gi = null)))),
        Hp(t, e),
        sn(e),
        null
      );
    case 5:
      yg(e);
      var r = Us(jl.current);
      if (((n = e.type), t !== null && e.stateNode != null))
        cE(t, e, n, i, r),
          t.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(ne(166));
          return sn(e), null;
        }
        if (((t = Us(Oi.current)), Wc(e))) {
          (i = e.stateNode), (n = e.type);
          var s = e.memoizedProps;
          switch (((i[Di] = e), (i[Bl] = s), (t = (e.mode & 1) !== 0), n)) {
            case "dialog":
              gt("cancel", i), gt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              gt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < il.length; r++) gt(il[r], i);
              break;
            case "source":
              gt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              gt("error", i), gt("load", i);
              break;
            case "details":
              gt("toggle", i);
              break;
            case "input":
              Gv(i, s), gt("invalid", i);
              break;
            case "select":
              (i._wrapperState = {
                wasMultiple: !!s.multiple,
              }),
                gt("invalid", i);
              break;
            case "textarea":
              $v(i, s), gt("invalid", i);
          }
          gp(n, s), (r = null);
          for (var a in s)
            if (s.hasOwnProperty(a)) {
              var o = s[a];
              a === "children"
                ? typeof o == "string"
                  ? i.textContent !== o &&
                    (s.suppressHydrationWarning !== !0 &&
                      Gc(i.textContent, o, t),
                    (r = ["children", o]))
                  : typeof o == "number" &&
                    i.textContent !== "" + o &&
                    (s.suppressHydrationWarning !== !0 &&
                      Gc(i.textContent, o, t),
                    (r = ["children", "" + o]))
                : Rl.hasOwnProperty(a) &&
                  o != null &&
                  a === "onScroll" &&
                  gt("scroll", i);
            }
          switch (n) {
            case "input":
              Uc(i), Wv(i, s, !0);
              break;
            case "textarea":
              Uc(i), Xv(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = id);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (a = r.nodeType === 9 ? r : r.ownerDocument),
            t === "http://www.w3.org/1999/xhtml" && (t = FS(n)),
            t === "http://www.w3.org/1999/xhtml"
              ? n === "script"
                ? ((t = a.createElement("div")),
                  (t.innerHTML = "<script></script>"),
                  (t = t.removeChild(t.firstChild)))
                : typeof i.is == "string"
                ? (t = a.createElement(n, {
                    is: i.is,
                  }))
                : ((t = a.createElement(n)),
                  n === "select" &&
                    ((a = t),
                    i.multiple
                      ? (a.multiple = !0)
                      : i.size && (a.size = i.size)))
              : (t = a.createElementNS(t, n)),
            (t[Di] = e),
            (t[Bl] = i),
            lE(t, e, !1, !1),
            (e.stateNode = t);
          e: {
            switch (((a = vp(n, i)), n)) {
              case "dialog":
                gt("cancel", t), gt("close", t), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                gt("load", t), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < il.length; r++) gt(il[r], t);
                r = i;
                break;
              case "source":
                gt("error", t), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                gt("error", t), gt("load", t), (r = i);
                break;
              case "details":
                gt("toggle", t), (r = i);
                break;
              case "input":
                Gv(t, i), (r = dp(t, i)), gt("invalid", t);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (t._wrapperState = {
                  wasMultiple: !!i.multiple,
                }),
                  (r = At({}, i, {
                    value: void 0,
                  })),
                  gt("invalid", t);
                break;
              case "textarea":
                $v(t, i), (r = pp(t, i)), gt("invalid", t);
                break;
              default:
                r = i;
            }
            gp(n, r), (o = r);
            for (s in o)
              if (o.hasOwnProperty(s)) {
                var l = o[s];
                s === "style"
                  ? jS(t, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && BS(t, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (n !== "textarea" || l !== "") && Pl(t, l)
                    : typeof l == "number" && Pl(t, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (Rl.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && gt("scroll", t)
                      : l != null && Zm(t, s, l, a));
              }
            switch (n) {
              case "input":
                Uc(t), Wv(t, i, !1);
                break;
              case "textarea":
                Uc(t), Xv(t);
                break;
              case "option":
                i.value != null && t.setAttribute("value", "" + Qr(i.value));
                break;
              case "select":
                (t.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? Za(t, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      Za(t, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (t.onclick = id);
            }
            switch (n) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return sn(e), null;
    case 6:
      if (t && e.stateNode != null) uE(t, e, t.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(ne(166));
        if (((n = Us(jl.current)), Us(Oi.current), Wc(e))) {
          if (
            ((i = e.stateNode),
            (n = e.memoizedProps),
            (i[Di] = e),
            (s = i.nodeValue !== n) && ((t = Vn), t !== null))
          )
            switch (t.tag) {
              case 3:
                Gc(i.nodeValue, n, (t.mode & 1) !== 0);
                break;
              case 5:
                t.memoizedProps.suppressHydrationWarning !== !0 &&
                  Gc(i.nodeValue, n, (t.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(i)),
            (i[Di] = e),
            (e.stateNode = i);
      }
      return sn(e), null;
    case 13:
      if (
        (_t(Tt),
        (i = e.memoizedState),
        t === null ||
          (t.memoizedState !== null && t.memoizedState.dehydrated !== null))
      ) {
        if (St && jn !== null && e.mode & 1 && !(e.flags & 128))
          Cw(), lo(), (e.flags |= 98560), (s = !1);
        else if (((s = Wc(e)), i !== null && i.dehydrated !== null)) {
          if (t === null) {
            if (!s) throw Error(ne(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(ne(317));
            s[Di] = e;
          } else
            lo(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          sn(e), (s = !1);
        } else gi !== null && (Kp(gi), (gi = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = n), e)
        : ((i = i !== null),
          i !== (t !== null && t.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (t === null || Tt.current & 1 ? zt === 0 && (zt = 3) : Ng())),
          e.updateQueue !== null && (e.flags |= 4),
          sn(e),
          null);
    case 4:
      return (
        uo(), Hp(t, e), t === null && Ol(e.stateNode.containerInfo), sn(e), null
      );
    case 10:
      return mg(e.type._context), sn(e), null;
    case 17:
      return Ln(e.type) && rd(), sn(e), null;
    case 19:
      if ((_t(Tt), (s = e.memoizedState), s === null)) return sn(e), null;
      if (((i = (e.flags & 128) !== 0), (a = s.rendering), a === null))
        if (i) Ho(s, !1);
        else {
          if (zt !== 0 || (t !== null && t.flags & 128))
            for (t = e.child; t !== null; ) {
              if (((a = dd(t)), a !== null)) {
                for (
                  e.flags |= 128,
                    Ho(s, !1),
                    i = a.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = n,
                    n = e.child;
                  n !== null;

                )
                  (s = n),
                    (t = i),
                    (s.flags &= 14680066),
                    (a = s.alternate),
                    a === null
                      ? ((s.childLanes = 0),
                        (s.lanes = t),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = a.childLanes),
                        (s.lanes = a.lanes),
                        (s.child = a.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = a.memoizedProps),
                        (s.memoizedState = a.memoizedState),
                        (s.updateQueue = a.updateQueue),
                        (s.type = a.type),
                        (t = a.dependencies),
                        (s.dependencies =
                          t === null
                            ? null
                            : {
                                lanes: t.lanes,
                                firstContext: t.firstContext,
                              })),
                    (n = n.sibling);
                return mt(Tt, (Tt.current & 1) | 2), e.child;
              }
              t = t.sibling;
            }
          s.tail !== null &&
            Dt() > fo &&
            ((e.flags |= 128), (i = !0), Ho(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((t = dd(a)), t !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (n = t.updateQueue),
              n !== null && ((e.updateQueue = n), (e.flags |= 4)),
              Ho(s, !0),
              s.tail === null && s.tailMode === "hidden" && !a.alternate && !St)
            )
              return sn(e), null;
          } else
            2 * Dt() - s.renderingStartTime > fo &&
              n !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Ho(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((a.sibling = e.child), (e.child = a))
          : ((n = s.last),
            n !== null ? (n.sibling = a) : (e.child = a),
            (s.last = a));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = Dt()),
          (e.sibling = null),
          (n = Tt.current),
          mt(Tt, i ? (n & 1) | 2 : n & 1),
          e)
        : (sn(e), null);
    case 22:
    case 23:
      return (
        Lg(),
        (i = e.memoizedState !== null),
        t !== null && (t.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? zn & 1073741824 && (sn(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : sn(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(ne(156, e.tag));
}
function eC(t, e) {
  switch ((dg(e), e.tag)) {
    case 1:
      return (
        Ln(e.type) && rd(),
        (t = e.flags),
        t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 3:
      return (
        uo(),
        _t(Pn),
        _t(hn),
        xg(),
        (t = e.flags),
        t & 65536 && !(t & 128) ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 5:
      return yg(e), null;
    case 13:
      if (
        (_t(Tt), (t = e.memoizedState), t !== null && t.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(ne(340));
        lo();
      }
      return (
        (t = e.flags), t & 65536 ? ((e.flags = (t & -65537) | 128), e) : null
      );
    case 19:
      return _t(Tt), null;
    case 4:
      return uo(), null;
    case 10:
      return mg(e.type._context), null;
    case 22:
    case 23:
      return Lg(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var qc = !1,
  un = !1,
  tC = typeof WeakSet == "function" ? WeakSet : Set,
  ve = null;
function za(t, e) {
  var n = t.ref;
  if (n !== null)
    if (typeof n == "function")
      try {
        n(null);
      } catch (i) {
        Rt(t, e, i);
      }
    else n.current = null;
}
function Gp(t, e, n) {
  try {
    n();
  } catch (i) {
    Rt(t, e, i);
  }
}
var U0 = !1;
function nC(t, e) {
  if (((Ap = ed), (t = mw()), cg(t))) {
    if ("selectionStart" in t)
      var n = {
        start: t.selectionStart,
        end: t.selectionEnd,
      };
    else
      e: {
        n = ((n = t.ownerDocument) && n.defaultView) || window;
        var i = n.getSelection && n.getSelection();
        if (i && i.rangeCount !== 0) {
          n = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            n.nodeType, s.nodeType;
          } catch {
            n = null;
            break e;
          }
          var a = 0,
            o = -1,
            l = -1,
            c = 0,
            u = 0,
            d = t,
            h = null;
          t: for (;;) {
            for (
              var p;
              d !== n || (r !== 0 && d.nodeType !== 3) || (o = a + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (l = a + i),
                d.nodeType === 3 && (a += d.nodeValue.length),
                (p = d.firstChild) !== null;

            )
              (h = d), (d = p);
            for (;;) {
              if (d === t) break t;
              if (
                (h === n && ++c === r && (o = a),
                h === s && ++u === i && (l = a),
                (p = d.nextSibling) !== null)
              )
                break;
              (d = h), (h = d.parentNode);
            }
            d = p;
          }
          n =
            o === -1 || l === -1
              ? null
              : {
                  start: o,
                  end: l,
                };
        } else n = null;
      }
    n = n || {
      start: 0,
      end: 0,
    };
  } else n = null;
  for (
    Cp = {
      focusedElem: t,
      selectionRange: n,
    },
      ed = !1,
      ve = e;
    ve !== null;

  )
    if (((e = ve), (t = e.child), (e.subtreeFlags & 1028) !== 0 && t !== null))
      (t.return = e), (ve = t);
    else
      for (; ve !== null; ) {
        e = ve;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var x = v.memoizedProps,
                    m = v.memoizedState,
                    f = e.stateNode,
                    y = f.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? x : fi(e.type, x),
                      m
                    );
                  f.__reactInternalSnapshotBeforeUpdate = y;
                }
                break;
              case 3:
                var g = e.stateNode.containerInfo;
                g.nodeType === 1
                  ? (g.textContent = "")
                  : g.nodeType === 9 &&
                    g.documentElement &&
                    g.removeChild(g.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(ne(163));
            }
        } catch (S) {
          Rt(e, e.return, S);
        }
        if (((t = e.sibling), t !== null)) {
          (t.return = e.return), (ve = t);
          break;
        }
        ve = e.return;
      }
  return (v = U0), (U0 = !1), v;
}
function vl(t, e, n) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & t) === t) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Gp(e, n, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function Jd(t, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var n = (e = e.next);
    do {
      if ((n.tag & t) === t) {
        var i = n.create;
        n.destroy = i();
      }
      n = n.next;
    } while (n !== e);
  }
}
function Wp(t) {
  var e = t.ref;
  if (e !== null) {
    var n = t.stateNode;
    switch (t.tag) {
      case 5:
        t = n;
        break;
      default:
        t = n;
    }
    typeof e == "function" ? e(t) : (e.current = t);
  }
}
function dE(t) {
  var e = t.alternate;
  e !== null && ((t.alternate = null), dE(e)),
    (t.child = null),
    (t.deletions = null),
    (t.sibling = null),
    t.tag === 5 &&
      ((e = t.stateNode),
      e !== null &&
        (delete e[Di], delete e[Bl], delete e[Lp], delete e[FA], delete e[BA])),
    (t.stateNode = null),
    (t.return = null),
    (t.dependencies = null),
    (t.memoizedProps = null),
    (t.memoizedState = null),
    (t.pendingProps = null),
    (t.stateNode = null),
    (t.updateQueue = null);
}
function hE(t) {
  return t.tag === 5 || t.tag === 3 || t.tag === 4;
}
function O0(t) {
  e: for (;;) {
    for (; t.sibling === null; ) {
      if (t.return === null || hE(t.return)) return null;
      t = t.return;
    }
    for (
      t.sibling.return = t.return, t = t.sibling;
      t.tag !== 5 && t.tag !== 6 && t.tag !== 18;

    ) {
      if (t.flags & 2 || t.child === null || t.tag === 4) continue e;
      (t.child.return = t), (t = t.child);
    }
    if (!(t.flags & 2)) return t.stateNode;
  }
}
function $p(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode),
      e
        ? n.nodeType === 8
          ? n.parentNode.insertBefore(t, e)
          : n.insertBefore(t, e)
        : (n.nodeType === 8
            ? ((e = n.parentNode), e.insertBefore(t, n))
            : ((e = n), e.appendChild(t)),
          (n = n._reactRootContainer),
          n != null || e.onclick !== null || (e.onclick = id));
  else if (i !== 4 && ((t = t.child), t !== null))
    for ($p(t, e, n), t = t.sibling; t !== null; ) $p(t, e, n), (t = t.sibling);
}
function Xp(t, e, n) {
  var i = t.tag;
  if (i === 5 || i === 6)
    (t = t.stateNode), e ? n.insertBefore(t, e) : n.appendChild(t);
  else if (i !== 4 && ((t = t.child), t !== null))
    for (Xp(t, e, n), t = t.sibling; t !== null; ) Xp(t, e, n), (t = t.sibling);
}
var Jt = null,
  pi = !1;
function yr(t, e, n) {
  for (n = n.child; n !== null; ) fE(t, e, n), (n = n.sibling);
}
function fE(t, e, n) {
  if (Ui && typeof Ui.onCommitFiberUnmount == "function")
    try {
      Ui.onCommitFiberUnmount(Gd, n);
    } catch {}
  switch (n.tag) {
    case 5:
      un || za(n, e);
    case 6:
      var i = Jt,
        r = pi;
      (Jt = null),
        yr(t, e, n),
        (Jt = i),
        (pi = r),
        Jt !== null &&
          (pi
            ? ((t = Jt),
              (n = n.stateNode),
              t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n))
            : Jt.removeChild(n.stateNode));
      break;
    case 18:
      Jt !== null &&
        (pi
          ? ((t = Jt),
            (n = n.stateNode),
            t.nodeType === 8
              ? Xh(t.parentNode, n)
              : t.nodeType === 1 && Xh(t, n),
            kl(t))
          : Xh(Jt, n.stateNode));
      break;
    case 4:
      (i = Jt),
        (r = pi),
        (Jt = n.stateNode.containerInfo),
        (pi = !0),
        yr(t, e, n),
        (Jt = i),
        (pi = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !un &&
        ((i = n.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            a = s.destroy;
          (s = s.tag),
            a !== void 0 && (s & 2 || s & 4) && Gp(n, e, a),
            (r = r.next);
        } while (r !== i);
      }
      yr(t, e, n);
      break;
    case 1:
      if (
        !un &&
        (za(n, e),
        (i = n.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = n.memoizedProps),
            (i.state = n.memoizedState),
            i.componentWillUnmount();
        } catch (o) {
          Rt(n, e, o);
        }
      yr(t, e, n);
      break;
    case 21:
      yr(t, e, n);
      break;
    case 22:
      n.mode & 1
        ? ((un = (i = un) || n.memoizedState !== null), yr(t, e, n), (un = i))
        : yr(t, e, n);
      break;
    default:
      yr(t, e, n);
  }
}
function F0(t) {
  var e = t.updateQueue;
  if (e !== null) {
    t.updateQueue = null;
    var n = t.stateNode;
    n === null && (n = t.stateNode = new tC()),
      e.forEach(function (i) {
        var r = dC.bind(null, t, i);
        n.has(i) || (n.add(i), i.then(r, r));
      });
  }
}
function oi(t, e) {
  var n = e.deletions;
  if (n !== null)
    for (var i = 0; i < n.length; i++) {
      var r = n[i];
      try {
        var s = t,
          a = e,
          o = a;
        e: for (; o !== null; ) {
          switch (o.tag) {
            case 5:
              (Jt = o.stateNode), (pi = !1);
              break e;
            case 3:
              (Jt = o.stateNode.containerInfo), (pi = !0);
              break e;
            case 4:
              (Jt = o.stateNode.containerInfo), (pi = !0);
              break e;
          }
          o = o.return;
        }
        if (Jt === null) throw Error(ne(160));
        fE(s, a, r), (Jt = null), (pi = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (c) {
        Rt(r, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) pE(e, t), (e = e.sibling);
}
function pE(t, e) {
  var n = t.alternate,
    i = t.flags;
  switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((oi(e, t), Ci(t), i & 4)) {
        try {
          vl(3, t, t.return), Jd(3, t);
        } catch (x) {
          Rt(t, t.return, x);
        }
        try {
          vl(5, t, t.return);
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      break;
    case 1:
      oi(e, t), Ci(t), i & 512 && n !== null && za(n, n.return);
      break;
    case 5:
      if (
        (oi(e, t),
        Ci(t),
        i & 512 && n !== null && za(n, n.return),
        t.flags & 32)
      ) {
        var r = t.stateNode;
        try {
          Pl(r, "");
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      if (i & 4 && ((r = t.stateNode), r != null)) {
        var s = t.memoizedProps,
          a = n !== null ? n.memoizedProps : s,
          o = t.type,
          l = t.updateQueue;
        if (((t.updateQueue = null), l !== null))
          try {
            o === "input" && s.type === "radio" && s.name != null && US(r, s),
              vp(o, a);
            var c = vp(o, s);
            for (a = 0; a < l.length; a += 2) {
              var u = l[a],
                d = l[a + 1];
              u === "style"
                ? jS(r, d)
                : u === "dangerouslySetInnerHTML"
                ? BS(r, d)
                : u === "children"
                ? Pl(r, d)
                : Zm(r, u, d, c);
            }
            switch (o) {
              case "input":
                hp(r, s);
                break;
              case "textarea":
                OS(r, s);
                break;
              case "select":
                var h = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var p = s.value;
                p != null
                  ? Za(r, !!s.multiple, p, !1)
                  : h !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Za(r, !!s.multiple, s.defaultValue, !0)
                      : Za(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Bl] = s;
          } catch (x) {
            Rt(t, t.return, x);
          }
      }
      break;
    case 6:
      if ((oi(e, t), Ci(t), i & 4)) {
        if (t.stateNode === null) throw Error(ne(162));
        (r = t.stateNode), (s = t.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (x) {
          Rt(t, t.return, x);
        }
      }
      break;
    case 3:
      if (
        (oi(e, t), Ci(t), i & 4 && n !== null && n.memoizedState.isDehydrated)
      )
        try {
          kl(e.containerInfo);
        } catch (x) {
          Rt(t, t.return, x);
        }
      break;
    case 4:
      oi(e, t), Ci(t);
      break;
    case 13:
      oi(e, t),
        Ci(t),
        (r = t.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (Rg = Dt())),
        i & 4 && F0(t);
      break;
    case 22:
      if (
        ((u = n !== null && n.memoizedState !== null),
        t.mode & 1 ? ((un = (c = un) || u), oi(e, t), (un = c)) : oi(e, t),
        Ci(t),
        i & 8192)
      ) {
        if (
          ((c = t.memoizedState !== null),
          (t.stateNode.isHidden = c) && !u && t.mode & 1)
        )
          for (ve = t, u = t.child; u !== null; ) {
            for (d = ve = u; ve !== null; ) {
              switch (((h = ve), (p = h.child), h.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  vl(4, h, h.return);
                  break;
                case 1:
                  za(h, h.return);
                  var v = h.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (i = h), (n = h.return);
                    try {
                      (e = i),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (x) {
                      Rt(i, n, x);
                    }
                  }
                  break;
                case 5:
                  za(h, h.return);
                  break;
                case 22:
                  if (h.memoizedState !== null) {
                    z0(d);
                    continue;
                  }
              }
              p !== null ? ((p.return = h), (ve = p)) : z0(d);
            }
            u = u.sibling;
          }
        e: for (u = null, d = t; ; ) {
          if (d.tag === 5) {
            if (u === null) {
              u = d;
              try {
                (r = d.stateNode),
                  c
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((o = d.stateNode),
                      (l = d.memoizedProps.style),
                      (a =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (o.style.display = zS("display", a)));
              } catch (x) {
                Rt(t, t.return, x);
              }
            }
          } else if (d.tag === 6) {
            if (u === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (x) {
                Rt(t, t.return, x);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === t) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === t) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === t) break e;
            u === d && (u = null), (d = d.return);
          }
          u === d && (u = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      oi(e, t), Ci(t), i & 4 && F0(t);
      break;
    case 21:
      break;
    default:
      oi(e, t), Ci(t);
  }
}
function Ci(t) {
  var e = t.flags;
  if (e & 2) {
    try {
      e: {
        for (var n = t.return; n !== null; ) {
          if (hE(n)) {
            var i = n;
            break e;
          }
          n = n.return;
        }
        throw Error(ne(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Pl(r, ""), (i.flags &= -33));
          var s = O0(t);
          Xp(t, s, r);
          break;
        case 3:
        case 4:
          var a = i.stateNode.containerInfo,
            o = O0(t);
          $p(t, o, a);
          break;
        default:
          throw Error(ne(161));
      }
    } catch (l) {
      Rt(t, t.return, l);
    }
    t.flags &= -3;
  }
  e & 4096 && (t.flags &= -4097);
}
function iC(t, e, n) {
  (ve = t), mE(t);
}
function mE(t, e, n) {
  for (var i = (t.mode & 1) !== 0; ve !== null; ) {
    var r = ve,
      s = r.child;
    if (r.tag === 22 && i) {
      var a = r.memoizedState !== null || qc;
      if (!a) {
        var o = r.alternate,
          l = (o !== null && o.memoizedState !== null) || un;
        o = qc;
        var c = un;
        if (((qc = a), (un = l) && !c))
          for (ve = r; ve !== null; )
            (a = ve),
              (l = a.child),
              a.tag === 22 && a.memoizedState !== null
                ? j0(r)
                : l !== null
                ? ((l.return = a), (ve = l))
                : j0(r);
        for (; s !== null; ) (ve = s), mE(s), (s = s.sibling);
        (ve = r), (qc = o), (un = c);
      }
      B0(t);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (ve = s)) : B0(t);
  }
}
function B0(t) {
  for (; ve !== null; ) {
    var e = ve;
    if (e.flags & 8772) {
      var n = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              un || Jd(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !un)
                if (n === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? n.memoizedProps
                      : fi(e.type, n.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    n.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && E0(e, s, i);
              break;
            case 3:
              var a = e.updateQueue;
              if (a !== null) {
                if (((n = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      n = e.child.stateNode;
                      break;
                    case 1:
                      n = e.child.stateNode;
                  }
                E0(e, a, n);
              }
              break;
            case 5:
              var o = e.stateNode;
              if (n === null && e.flags & 4) {
                n = o;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && n.focus();
                    break;
                  case "img":
                    l.src && (n.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var u = c.memoizedState;
                  if (u !== null) {
                    var d = u.dehydrated;
                    d !== null && kl(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(ne(163));
          }
        un || (e.flags & 512 && Wp(e));
      } catch (h) {
        Rt(e, e.return, h);
      }
    }
    if (e === t) {
      ve = null;
      break;
    }
    if (((n = e.sibling), n !== null)) {
      (n.return = e.return), (ve = n);
      break;
    }
    ve = e.return;
  }
}
function z0(t) {
  for (; ve !== null; ) {
    var e = ve;
    if (e === t) {
      ve = null;
      break;
    }
    var n = e.sibling;
    if (n !== null) {
      (n.return = e.return), (ve = n);
      break;
    }
    ve = e.return;
  }
}
function j0(t) {
  for (; ve !== null; ) {
    var e = ve;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var n = e.return;
          try {
            Jd(4, e);
          } catch (l) {
            Rt(e, n, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              Rt(e, r, l);
            }
          }
          var s = e.return;
          try {
            Wp(e);
          } catch (l) {
            Rt(e, s, l);
          }
          break;
        case 5:
          var a = e.return;
          try {
            Wp(e);
          } catch (l) {
            Rt(e, a, l);
          }
      }
    } catch (l) {
      Rt(e, e.return, l);
    }
    if (e === t) {
      ve = null;
      break;
    }
    var o = e.sibling;
    if (o !== null) {
      (o.return = e.return), (ve = o);
      break;
    }
    ve = e.return;
  }
}
var rC = Math.ceil,
  pd = vr.ReactCurrentDispatcher,
  Ag = vr.ReactCurrentOwner,
  ii = vr.ReactCurrentBatchConfig,
  st = 0,
  Yt = null,
  Ut = null,
  en = 0,
  zn = 0,
  ja = cs(0),
  zt = 0,
  Wl = null,
  Ys = 0,
  Qd = 0,
  Cg = 0,
  _l = null,
  bn = null,
  Rg = 0,
  fo = 1 / 0,
  Ji = null,
  md = !1,
  qp = null,
  $r = null,
  Yc = !1,
  Fr = null,
  gd = 0,
  yl = 0,
  Yp = null,
  Bu = -1,
  zu = 0;
function _n() {
  return st & 6 ? Dt() : Bu !== -1 ? Bu : (Bu = Dt());
}
function Xr(t) {
  return t.mode & 1
    ? st & 2 && en !== 0
      ? en & -en
      : jA.transition !== null
      ? (zu === 0 && (zu = QS()), zu)
      : ((t = ut),
        t !== 0 || ((t = window.event), (t = t === void 0 ? 16 : aw(t.type))),
        t)
    : 1;
}
function Si(t, e, n, i) {
  if (50 < yl) throw ((yl = 0), (Yp = null), Error(ne(185)));
  pc(t, n, i),
    (!(st & 2) || t !== Yt) &&
      (t === Yt && (!(st & 2) && (Qd |= n), zt === 4 && kr(t, en)),
      Nn(t, i),
      n === 1 && st === 0 && !(e.mode & 1) && ((fo = Dt() + 500), Yd && us()));
}
function Nn(t, e) {
  var n = t.callbackNode;
  jb(t, e);
  var i = Qu(t, t === Yt ? en : 0);
  if (i === 0)
    n !== null && Zv(n), (t.callbackNode = null), (t.callbackPriority = 0);
  else if (((e = i & -i), t.callbackPriority !== e)) {
    if ((n != null && Zv(n), e === 1))
      t.tag === 0 ? zA(V0.bind(null, t)) : Mw(V0.bind(null, t)),
        UA(function () {
          !(st & 6) && us();
        }),
        (n = null);
    else {
      switch (ew(i)) {
        case 1:
          n = tg;
          break;
        case 4:
          n = KS;
          break;
        case 16:
          n = Ju;
          break;
        case 536870912:
          n = JS;
          break;
        default:
          n = Ju;
      }
      n = EE(n, gE.bind(null, t));
    }
    (t.callbackPriority = e), (t.callbackNode = n);
  }
}
function gE(t, e) {
  if (((Bu = -1), (zu = 0), st & 6)) throw Error(ne(327));
  var n = t.callbackNode;
  if (to() && t.callbackNode !== n) return null;
  var i = Qu(t, t === Yt ? en : 0);
  if (i === 0) return null;
  if (i & 30 || i & t.expiredLanes || e) e = vd(t, i);
  else {
    e = i;
    var r = st;
    st |= 2;
    var s = _E();
    (Yt !== t || en !== e) && ((Ji = null), (fo = Dt() + 500), Bs(t, e));
    do
      try {
        oC();
        break;
      } catch (o) {
        vE(t, o);
      }
    while (!0);
    pg(),
      (pd.current = s),
      (st = r),
      Ut !== null ? (e = 0) : ((Yt = null), (en = 0), (e = zt));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = wp(t)), r !== 0 && ((i = r), (e = Zp(t, r)))), e === 1)
    )
      throw ((n = Wl), Bs(t, 0), kr(t, i), Nn(t, Dt()), n);
    if (e === 6) kr(t, i);
    else {
      if (
        ((r = t.current.alternate),
        !(i & 30) &&
          !sC(r) &&
          ((e = vd(t, i)),
          e === 2 && ((s = wp(t)), s !== 0 && ((i = s), (e = Zp(t, s)))),
          e === 1))
      )
        throw ((n = Wl), Bs(t, 0), kr(t, i), Nn(t, Dt()), n);
      switch (((t.finishedWork = r), (t.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(ne(345));
        case 2:
          Ms(t, bn, Ji);
          break;
        case 3:
          if (
            (kr(t, i), (i & 130023424) === i && ((e = Rg + 500 - Dt()), 10 < e))
          ) {
            if (Qu(t, 0) !== 0) break;
            if (((r = t.suspendedLanes), (r & i) !== i)) {
              _n(), (t.pingedLanes |= t.suspendedLanes & r);
              break;
            }
            t.timeoutHandle = Pp(Ms.bind(null, t, bn, Ji), e);
            break;
          }
          Ms(t, bn, Ji);
          break;
        case 4:
          if ((kr(t, i), (i & 4194240) === i)) break;
          for (e = t.eventTimes, r = -1; 0 < i; ) {
            var a = 31 - xi(i);
            (s = 1 << a), (a = e[a]), a > r && (r = a), (i &= ~s);
          }
          if (
            ((i = r),
            (i = Dt() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * rC(i / 1960)) - i),
            10 < i)
          ) {
            t.timeoutHandle = Pp(Ms.bind(null, t, bn, Ji), i);
            break;
          }
          Ms(t, bn, Ji);
          break;
        case 5:
          Ms(t, bn, Ji);
          break;
        default:
          throw Error(ne(329));
      }
    }
  }
  return Nn(t, Dt()), t.callbackNode === n ? gE.bind(null, t) : null;
}
function Zp(t, e) {
  var n = _l;
  return (
    t.current.memoizedState.isDehydrated && (Bs(t, e).flags |= 256),
    (t = vd(t, e)),
    t !== 2 && ((e = bn), (bn = n), e !== null && Kp(e)),
    t
  );
}
function Kp(t) {
  bn === null ? (bn = t) : bn.push.apply(bn, t);
}
function sC(t) {
  for (var e = t; ; ) {
    if (e.flags & 16384) {
      var n = e.updateQueue;
      if (n !== null && ((n = n.stores), n !== null))
        for (var i = 0; i < n.length; i++) {
          var r = n[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!Ti(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((n = e.child), e.subtreeFlags & 16384 && n !== null))
      (n.return = e), (e = n);
    else {
      if (e === t) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === t) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function kr(t, e) {
  for (
    e &= ~Cg,
      e &= ~Qd,
      t.suspendedLanes |= e,
      t.pingedLanes &= ~e,
      t = t.expirationTimes;
    0 < e;

  ) {
    var n = 31 - xi(e),
      i = 1 << n;
    (t[n] = -1), (e &= ~i);
  }
}
function V0(t) {
  if (st & 6) throw Error(ne(327));
  to();
  var e = Qu(t, 0);
  if (!(e & 1)) return Nn(t, Dt()), null;
  var n = vd(t, e);
  if (t.tag !== 0 && n === 2) {
    var i = wp(t);
    i !== 0 && ((e = i), (n = Zp(t, i)));
  }
  if (n === 1) throw ((n = Wl), Bs(t, 0), kr(t, e), Nn(t, Dt()), n);
  if (n === 6) throw Error(ne(345));
  return (
    (t.finishedWork = t.current.alternate),
    (t.finishedLanes = e),
    Ms(t, bn, Ji),
    Nn(t, Dt()),
    null
  );
}
function Pg(t, e) {
  var n = st;
  st |= 1;
  try {
    return t(e);
  } finally {
    (st = n), st === 0 && ((fo = Dt() + 500), Yd && us());
  }
}
function Zs(t) {
  Fr !== null && Fr.tag === 0 && !(st & 6) && to();
  var e = st;
  st |= 1;
  var n = ii.transition,
    i = ut;
  try {
    if (((ii.transition = null), (ut = 1), t)) return t();
  } finally {
    (ut = i), (ii.transition = n), (st = e), !(st & 6) && us();
  }
}
function Lg() {
  (zn = ja.current), _t(ja);
}
function Bs(t, e) {
  (t.finishedWork = null), (t.finishedLanes = 0);
  var n = t.timeoutHandle;
  if ((n !== -1 && ((t.timeoutHandle = -1), IA(n)), Ut !== null))
    for (n = Ut.return; n !== null; ) {
      var i = n;
      switch ((dg(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && rd();
          break;
        case 3:
          uo(), _t(Pn), _t(hn), xg();
          break;
        case 5:
          yg(i);
          break;
        case 4:
          uo();
          break;
        case 13:
          _t(Tt);
          break;
        case 19:
          _t(Tt);
          break;
        case 10:
          mg(i.type._context);
          break;
        case 22:
        case 23:
          Lg();
      }
      n = n.return;
    }
  if (
    ((Yt = t),
    (Ut = t = qr(t.current, null)),
    (en = zn = e),
    (zt = 0),
    (Wl = null),
    (Cg = Qd = Ys = 0),
    (bn = _l = null),
    Is !== null)
  ) {
    for (e = 0; e < Is.length; e++)
      if (((n = Is[e]), (i = n.interleaved), i !== null)) {
        n.interleaved = null;
        var r = i.next,
          s = n.pending;
        if (s !== null) {
          var a = s.next;
          (s.next = r), (i.next = a);
        }
        n.pending = i;
      }
    Is = null;
  }
  return t;
}
function vE(t, e) {
  do {
    var n = Ut;
    try {
      if ((pg(), (Uu.current = fd), hd)) {
        for (var i = bt.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        hd = !1;
      }
      if (
        ((qs = 0),
        (qt = Bt = bt = null),
        (gl = !1),
        (Vl = 0),
        (Ag.current = null),
        n === null || n.return === null)
      ) {
        (zt = 1), (Wl = e), (Ut = null);
        break;
      }
      e: {
        var s = t,
          a = n.return,
          o = n,
          l = e;
        if (
          ((e = en),
          (o.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            u = o,
            d = u.tag;
          if (!(u.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var h = u.alternate;
            h
              ? ((u.updateQueue = h.updateQueue),
                (u.memoizedState = h.memoizedState),
                (u.lanes = h.lanes))
              : ((u.updateQueue = null), (u.memoizedState = null));
          }
          var p = R0(a);
          if (p !== null) {
            (p.flags &= -257),
              P0(p, a, o, s, e),
              p.mode & 1 && C0(s, c, e),
              (e = p),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var x = new Set();
              x.add(l), (e.updateQueue = x);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              C0(s, c, e), Ng();
              break e;
            }
            l = Error(ne(426));
          }
        } else if (St && o.mode & 1) {
          var m = R0(a);
          if (m !== null) {
            !(m.flags & 65536) && (m.flags |= 256),
              P0(m, a, o, s, e),
              hg(ho(l, o));
            break e;
          }
        }
        (s = l = ho(l, o)),
          zt !== 4 && (zt = 2),
          _l === null ? (_l = [s]) : _l.push(s),
          (s = a);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var f = eE(s, l, e);
              w0(s, f);
              break e;
            case 1:
              o = l;
              var y = s.type,
                g = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof y.getDerivedStateFromError == "function" ||
                  (g !== null &&
                    typeof g.componentDidCatch == "function" &&
                    ($r === null || !$r.has(g))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var S = tE(s, o, e);
                w0(s, S);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      xE(n);
    } catch (T) {
      (e = T), Ut === n && n !== null && (Ut = n = n.return);
      continue;
    }
    break;
  } while (!0);
}
function _E() {
  var t = pd.current;
  return (pd.current = fd), t === null ? fd : t;
}
function Ng() {
  (zt === 0 || zt === 3 || zt === 2) && (zt = 4),
    Yt === null || (!(Ys & 268435455) && !(Qd & 268435455)) || kr(Yt, en);
}
function vd(t, e) {
  var n = st;
  st |= 2;
  var i = _E();
  (Yt !== t || en !== e) && ((Ji = null), Bs(t, e));
  do
    try {
      aC();
      break;
    } catch (r) {
      vE(t, r);
    }
  while (!0);
  if ((pg(), (st = n), (pd.current = i), Ut !== null)) throw Error(ne(261));
  return (Yt = null), (en = 0), zt;
}
function aC() {
  for (; Ut !== null; ) yE(Ut);
}
function oC() {
  for (; Ut !== null && !Nb(); ) yE(Ut);
}
function yE(t) {
  var e = wE(t.alternate, t, zn);
  (t.memoizedProps = t.pendingProps),
    e === null ? xE(t) : (Ut = e),
    (Ag.current = null);
}
function xE(t) {
  var e = t;
  do {
    var n = e.alternate;
    if (((t = e.return), e.flags & 32768)) {
      if (((n = eC(n, e)), n !== null)) {
        (n.flags &= 32767), (Ut = n);
        return;
      }
      if (t !== null)
        (t.flags |= 32768), (t.subtreeFlags = 0), (t.deletions = null);
      else {
        (zt = 6), (Ut = null);
        return;
      }
    } else if (((n = QA(n, e, zn)), n !== null)) {
      Ut = n;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      Ut = e;
      return;
    }
    Ut = e = t;
  } while (e !== null);
  zt === 0 && (zt = 5);
}
function Ms(t, e, n) {
  var i = ut,
    r = ii.transition;
  try {
    (ii.transition = null), (ut = 1), lC(t, e, n, i);
  } finally {
    (ii.transition = r), (ut = i);
  }
  return null;
}
function lC(t, e, n, i) {
  do to();
  while (Fr !== null);
  if (st & 6) throw Error(ne(327));
  n = t.finishedWork;
  var r = t.finishedLanes;
  if (n === null) return null;
  if (((t.finishedWork = null), (t.finishedLanes = 0), n === t.current))
    throw Error(ne(177));
  (t.callbackNode = null), (t.callbackPriority = 0);
  var s = n.lanes | n.childLanes;
  if (
    (Vb(t, s),
    t === Yt && ((Ut = Yt = null), (en = 0)),
    (!(n.subtreeFlags & 2064) && !(n.flags & 2064)) ||
      Yc ||
      ((Yc = !0),
      EE(Ju, function () {
        return to(), null;
      })),
    (s = (n.flags & 15990) !== 0),
    n.subtreeFlags & 15990 || s)
  ) {
    (s = ii.transition), (ii.transition = null);
    var a = ut;
    ut = 1;
    var o = st;
    (st |= 4),
      (Ag.current = null),
      nC(t, n),
      pE(n, t),
      CA(Cp),
      (ed = !!Ap),
      (Cp = Ap = null),
      (t.current = n),
      iC(n),
      Db(),
      (st = o),
      (ut = a),
      (ii.transition = s);
  } else t.current = n;
  if (
    (Yc && ((Yc = !1), (Fr = t), (gd = r)),
    (s = t.pendingLanes),
    s === 0 && ($r = null),
    Ub(n.stateNode),
    Nn(t, Dt()),
    e !== null)
  )
    for (i = t.onRecoverableError, n = 0; n < e.length; n++)
      (r = e[n]),
        i(r.value, {
          componentStack: r.stack,
          digest: r.digest,
        });
  if (md) throw ((md = !1), (t = qp), (qp = null), t);
  return (
    gd & 1 && t.tag !== 0 && to(),
    (s = t.pendingLanes),
    s & 1 ? (t === Yp ? yl++ : ((yl = 0), (Yp = t))) : (yl = 0),
    us(),
    null
  );
}
function to() {
  if (Fr !== null) {
    var t = ew(gd),
      e = ii.transition,
      n = ut;
    try {
      if (((ii.transition = null), (ut = 16 > t ? 16 : t), Fr === null))
        var i = !1;
      else {
        if (((t = Fr), (Fr = null), (gd = 0), st & 6)) throw Error(ne(331));
        var r = st;
        for (st |= 4, ve = t.current; ve !== null; ) {
          var s = ve,
            a = s.child;
          if (ve.flags & 16) {
            var o = s.deletions;
            if (o !== null) {
              for (var l = 0; l < o.length; l++) {
                var c = o[l];
                for (ve = c; ve !== null; ) {
                  var u = ve;
                  switch (u.tag) {
                    case 0:
                    case 11:
                    case 15:
                      vl(8, u, s);
                  }
                  var d = u.child;
                  if (d !== null) (d.return = u), (ve = d);
                  else
                    for (; ve !== null; ) {
                      u = ve;
                      var h = u.sibling,
                        p = u.return;
                      if ((dE(u), u === c)) {
                        ve = null;
                        break;
                      }
                      if (h !== null) {
                        (h.return = p), (ve = h);
                        break;
                      }
                      ve = p;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var x = v.child;
                if (x !== null) {
                  v.child = null;
                  do {
                    var m = x.sibling;
                    (x.sibling = null), (x = m);
                  } while (x !== null);
                }
              }
              ve = s;
            }
          }
          if (s.subtreeFlags & 2064 && a !== null) (a.return = s), (ve = a);
          else
            e: for (; ve !== null; ) {
              if (((s = ve), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    vl(9, s, s.return);
                }
              var f = s.sibling;
              if (f !== null) {
                (f.return = s.return), (ve = f);
                break e;
              }
              ve = s.return;
            }
        }
        var y = t.current;
        for (ve = y; ve !== null; ) {
          a = ve;
          var g = a.child;
          if (a.subtreeFlags & 2064 && g !== null) (g.return = a), (ve = g);
          else
            e: for (a = y; ve !== null; ) {
              if (((o = ve), o.flags & 2048))
                try {
                  switch (o.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Jd(9, o);
                  }
                } catch (T) {
                  Rt(o, o.return, T);
                }
              if (o === a) {
                ve = null;
                break e;
              }
              var S = o.sibling;
              if (S !== null) {
                (S.return = o.return), (ve = S);
                break e;
              }
              ve = o.return;
            }
        }
        if (
          ((st = r), us(), Ui && typeof Ui.onPostCommitFiberRoot == "function")
        )
          try {
            Ui.onPostCommitFiberRoot(Gd, t);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (ut = n), (ii.transition = e);
    }
  }
  return !1;
}
function H0(t, e, n) {
  (e = ho(n, e)),
    (e = eE(t, e, 1)),
    (t = Wr(t, e, 1)),
    (e = _n()),
    t !== null && (pc(t, 1, e), Nn(t, e));
}
function Rt(t, e, n) {
  if (t.tag === 3) H0(t, t, n);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        H0(e, t, n);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            ($r === null || !$r.has(i)))
        ) {
          (t = ho(n, t)),
            (t = tE(e, t, 1)),
            (e = Wr(e, t, 1)),
            (t = _n()),
            e !== null && (pc(e, 1, t), Nn(e, t));
          break;
        }
      }
      e = e.return;
    }
}
function cC(t, e, n) {
  var i = t.pingCache;
  i !== null && i.delete(e),
    (e = _n()),
    (t.pingedLanes |= t.suspendedLanes & n),
    Yt === t &&
      (en & n) === n &&
      (zt === 4 || (zt === 3 && (en & 130023424) === en && 500 > Dt() - Rg)
        ? Bs(t, 0)
        : (Cg |= n)),
    Nn(t, e);
}
function SE(t, e) {
  e === 0 &&
    (t.mode & 1
      ? ((e = Bc), (Bc <<= 1), !(Bc & 130023424) && (Bc = 4194304))
      : (e = 1));
  var n = _n();
  (t = fr(t, e)), t !== null && (pc(t, e, n), Nn(t, n));
}
function uC(t) {
  var e = t.memoizedState,
    n = 0;
  e !== null && (n = e.retryLane), SE(t, n);
}
function dC(t, e) {
  var n = 0;
  switch (t.tag) {
    case 13:
      var i = t.stateNode,
        r = t.memoizedState;
      r !== null && (n = r.retryLane);
      break;
    case 19:
      i = t.stateNode;
      break;
    default:
      throw Error(ne(314));
  }
  i !== null && i.delete(e), SE(t, n);
}
var wE;
wE = function (t, e, n) {
  if (t !== null)
    if (t.memoizedProps !== e.pendingProps || Pn.current) Rn = !0;
    else {
      if (!(t.lanes & n) && !(e.flags & 128)) return (Rn = !1), JA(t, e, n);
      Rn = !!(t.flags & 131072);
    }
  else (Rn = !1), St && e.flags & 1048576 && bw(e, od, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      Fu(t, e), (t = e.pendingProps);
      var r = oo(e, hn.current);
      eo(e, n), (r = wg(null, e, i, t, r, n));
      var s = Eg();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Ln(i) ? ((s = !0), sd(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            vg(e),
            (r.updater = Kd),
            (e.stateNode = r),
            (r._reactInternals = e),
            Op(e, i, t, n),
            (e = zp(null, e, i, !0, s, n)))
          : ((e.tag = 0), St && s && ug(e), gn(null, e, r, n), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (Fu(t, e),
          (t = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = fC(i)),
          (t = fi(i, t)),
          r)
        ) {
          case 0:
            e = Bp(null, e, i, t, n);
            break e;
          case 1:
            e = D0(null, e, i, t, n);
            break e;
          case 11:
            e = L0(null, e, i, t, n);
            break e;
          case 14:
            e = N0(null, e, i, fi(i.type, t), n);
            break e;
        }
        throw Error(ne(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : fi(i, r)),
        Bp(t, e, i, r, n)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : fi(i, r)),
        D0(t, e, i, r, n)
      );
    case 3:
      e: {
        if ((sE(e), t === null)) throw Error(ne(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          Nw(t, e),
          ud(e, i, null, n);
        var a = e.memoizedState;
        if (((i = a.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: a.cache,
              pendingSuspenseBoundaries: a.pendingSuspenseBoundaries,
              transitions: a.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = ho(Error(ne(423)), e)), (e = k0(t, e, i, n, r));
            break e;
          } else if (i !== r) {
            (r = ho(Error(ne(424)), e)), (e = k0(t, e, i, n, r));
            break e;
          } else
            for (
              jn = Gr(e.stateNode.containerInfo.firstChild),
                Vn = e,
                St = !0,
                gi = null,
                n = Pw(e, null, i, n),
                e.child = n;
              n;

            )
              (n.flags = (n.flags & -3) | 4096), (n = n.sibling);
        else {
          if ((lo(), i === r)) {
            e = pr(t, e, n);
            break e;
          }
          gn(t, e, i, n);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        Dw(e),
        t === null && kp(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = t !== null ? t.memoizedProps : null),
        (a = r.children),
        Rp(i, r) ? (a = null) : s !== null && Rp(i, s) && (e.flags |= 32),
        rE(t, e),
        gn(t, e, a, n),
        e.child
      );
    case 6:
      return t === null && kp(e), null;
    case 13:
      return aE(t, e, n);
    case 4:
      return (
        _g(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        t === null ? (e.child = co(e, null, i, n)) : gn(t, e, i, n),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : fi(i, r)),
        L0(t, e, i, r, n)
      );
    case 7:
      return gn(t, e, e.pendingProps, n), e.child;
    case 8:
      return gn(t, e, e.pendingProps.children, n), e.child;
    case 12:
      return gn(t, e, e.pendingProps.children, n), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (a = r.value),
          mt(ld, i._currentValue),
          (i._currentValue = a),
          s !== null)
        )
          if (Ti(s.value, a)) {
            if (s.children === r.children && !Pn.current) {
              e = pr(t, e, n);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var o = s.dependencies;
              if (o !== null) {
                a = s.child;
                for (var l = o.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = lr(-1, n & -n)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var u = c.pending;
                        u === null
                          ? (l.next = l)
                          : ((l.next = u.next), (u.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= n),
                      (l = s.alternate),
                      l !== null && (l.lanes |= n),
                      Ip(s.return, n, e),
                      (o.lanes |= n);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) a = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((a = s.return), a === null)) throw Error(ne(341));
                (a.lanes |= n),
                  (o = a.alternate),
                  o !== null && (o.lanes |= n),
                  Ip(a, n, e),
                  (a = s.sibling);
              } else a = s.child;
              if (a !== null) a.return = s;
              else
                for (a = s; a !== null; ) {
                  if (a === e) {
                    a = null;
                    break;
                  }
                  if (((s = a.sibling), s !== null)) {
                    (s.return = a.return), (a = s);
                    break;
                  }
                  a = a.return;
                }
              s = a;
            }
        gn(t, e, r.children, n), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        eo(e, n),
        (r = si(r)),
        (i = i(r)),
        (e.flags |= 1),
        gn(t, e, i, n),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = fi(i, e.pendingProps)),
        (r = fi(i.type, r)),
        N0(t, e, i, r, n)
      );
    case 15:
      return nE(t, e, e.type, e.pendingProps, n);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : fi(i, r)),
        Fu(t, e),
        (e.tag = 1),
        Ln(i) ? ((t = !0), sd(e)) : (t = !1),
        eo(e, n),
        Qw(e, i, r),
        Op(e, i, r, n),
        zp(null, e, i, !0, t, n)
      );
    case 19:
      return oE(t, e, n);
    case 22:
      return iE(t, e, n);
  }
  throw Error(ne(156, e.tag));
};
function EE(t, e) {
  return ZS(t, e);
}
function hC(t, e, n, i) {
  (this.tag = t),
    (this.key = n),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function ni(t, e, n, i) {
  return new hC(t, e, n, i);
}
function Dg(t) {
  return (t = t.prototype), !(!t || !t.isReactComponent);
}
function fC(t) {
  if (typeof t == "function") return Dg(t) ? 1 : 0;
  if (t != null) {
    if (((t = t.$$typeof), t === Jm)) return 11;
    if (t === Qm) return 14;
  }
  return 2;
}
function qr(t, e) {
  var n = t.alternate;
  return (
    n === null
      ? ((n = ni(t.tag, e, t.key, t.mode)),
        (n.elementType = t.elementType),
        (n.type = t.type),
        (n.stateNode = t.stateNode),
        (n.alternate = t),
        (t.alternate = n))
      : ((n.pendingProps = e),
        (n.type = t.type),
        (n.flags = 0),
        (n.subtreeFlags = 0),
        (n.deletions = null)),
    (n.flags = t.flags & 14680064),
    (n.childLanes = t.childLanes),
    (n.lanes = t.lanes),
    (n.child = t.child),
    (n.memoizedProps = t.memoizedProps),
    (n.memoizedState = t.memoizedState),
    (n.updateQueue = t.updateQueue),
    (e = t.dependencies),
    (n.dependencies =
      e === null
        ? null
        : {
            lanes: e.lanes,
            firstContext: e.firstContext,
          }),
    (n.sibling = t.sibling),
    (n.index = t.index),
    (n.ref = t.ref),
    n
  );
}
function ju(t, e, n, i, r, s) {
  var a = 2;
  if (((i = t), typeof t == "function")) Dg(t) && (a = 1);
  else if (typeof t == "string") a = 5;
  else
    e: switch (t) {
      case La:
        return zs(n.children, r, s, e);
      case Km:
        (a = 8), (r |= 8);
        break;
      case op:
        return (
          (t = ni(12, n, e, r | 2)), (t.elementType = op), (t.lanes = s), t
        );
      case lp:
        return (t = ni(13, n, e, r)), (t.elementType = lp), (t.lanes = s), t;
      case cp:
        return (t = ni(19, n, e, r)), (t.elementType = cp), (t.lanes = s), t;
      case DS:
        return eh(n, r, s, e);
      default:
        if (typeof t == "object" && t !== null)
          switch (t.$$typeof) {
            case LS:
              a = 10;
              break e;
            case NS:
              a = 9;
              break e;
            case Jm:
              a = 11;
              break e;
            case Qm:
              a = 14;
              break e;
            case Pr:
              (a = 16), (i = null);
              break e;
          }
        throw Error(ne(130, t == null ? t : typeof t, ""));
    }
  return (
    (e = ni(a, n, e, r)), (e.elementType = t), (e.type = i), (e.lanes = s), e
  );
}
function zs(t, e, n, i) {
  return (t = ni(7, t, i, e)), (t.lanes = n), t;
}
function eh(t, e, n, i) {
  return (
    (t = ni(22, t, i, e)),
    (t.elementType = DS),
    (t.lanes = n),
    (t.stateNode = {
      isHidden: !1,
    }),
    t
  );
}
function tf(t, e, n) {
  return (t = ni(6, t, null, e)), (t.lanes = n), t;
}
function nf(t, e, n) {
  return (
    (e = ni(4, t.children !== null ? t.children : [], t.key, e)),
    (e.lanes = n),
    (e.stateNode = {
      containerInfo: t.containerInfo,
      pendingChildren: null,
      implementation: t.implementation,
    }),
    e
  );
}
function pC(t, e, n, i, r) {
  (this.tag = e),
    (this.containerInfo = t),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = Uh(0)),
    (this.expirationTimes = Uh(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = Uh(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function kg(t, e, n, i, r, s, a, o, l) {
  return (
    (t = new pC(t, e, n, o, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = ni(3, null, null, e)),
    (t.current = s),
    (s.stateNode = t),
    (s.memoizedState = {
      element: i,
      isDehydrated: n,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    vg(s),
    t
  );
}
function mC(t, e, n) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: Pa,
    key: i == null ? null : "" + i,
    children: t,
    containerInfo: e,
    implementation: n,
  };
}
function TE(t) {
  if (!t) return es;
  t = t._reactInternals;
  e: {
    if (ia(t) !== t || t.tag !== 1) throw Error(ne(170));
    var e = t;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Ln(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(ne(171));
  }
  if (t.tag === 1) {
    var n = t.type;
    if (Ln(n)) return Tw(t, n, e);
  }
  return e;
}
function ME(t, e, n, i, r, s, a, o, l) {
  return (
    (t = kg(n, i, !0, t, r, s, a, o, l)),
    (t.context = TE(null)),
    (n = t.current),
    (i = _n()),
    (r = Xr(n)),
    (s = lr(i, r)),
    (s.callback = e ?? null),
    Wr(n, s, r),
    (t.current.lanes = r),
    pc(t, r, i),
    Nn(t, i),
    t
  );
}
function th(t, e, n, i) {
  var r = e.current,
    s = _n(),
    a = Xr(r);
  return (
    (n = TE(n)),
    e.context === null ? (e.context = n) : (e.pendingContext = n),
    (e = lr(s, a)),
    (e.payload = {
      element: t,
    }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (t = Wr(r, e, a)),
    t !== null && (Si(t, r, a, s), Iu(t, r, a)),
    a
  );
}
function _d(t) {
  if (((t = t.current), !t.child)) return null;
  switch (t.child.tag) {
    case 5:
      return t.child.stateNode;
    default:
      return t.child.stateNode;
  }
}
function G0(t, e) {
  if (((t = t.memoizedState), t !== null && t.dehydrated !== null)) {
    var n = t.retryLane;
    t.retryLane = n !== 0 && n < e ? n : e;
  }
}
function Ig(t, e) {
  G0(t, e), (t = t.alternate) && G0(t, e);
}
function gC() {
  return null;
}
var bE =
  typeof reportError == "function"
    ? reportError
    : function (t) {
        console.error(t);
      };
function Ug(t) {
  this._internalRoot = t;
}
nh.prototype.render = Ug.prototype.render = function (t) {
  var e = this._internalRoot;
  if (e === null) throw Error(ne(409));
  th(t, e, null, null);
};
nh.prototype.unmount = Ug.prototype.unmount = function () {
  var t = this._internalRoot;
  if (t !== null) {
    this._internalRoot = null;
    var e = t.containerInfo;
    Zs(function () {
      th(null, t, null, null);
    }),
      (e[hr] = null);
  }
};
function nh(t) {
  this._internalRoot = t;
}
nh.prototype.unstable_scheduleHydration = function (t) {
  if (t) {
    var e = iw();
    t = {
      blockedOn: null,
      target: t,
      priority: e,
    };
    for (var n = 0; n < Dr.length && e !== 0 && e < Dr[n].priority; n++);
    Dr.splice(n, 0, t), n === 0 && sw(t);
  }
};
function Og(t) {
  return !(!t || (t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11));
}
function ih(t) {
  return !(
    !t ||
    (t.nodeType !== 1 &&
      t.nodeType !== 9 &&
      t.nodeType !== 11 &&
      (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
  );
}
function W0() {}
function vC(t, e, n, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var c = _d(a);
        s.call(c);
      };
    }
    var a = ME(e, i, t, 0, null, !1, !1, "", W0);
    return (
      (t._reactRootContainer = a),
      (t[hr] = a.current),
      Ol(t.nodeType === 8 ? t.parentNode : t),
      Zs(),
      a
    );
  }
  for (; (r = t.lastChild); ) t.removeChild(r);
  if (typeof i == "function") {
    var o = i;
    i = function () {
      var c = _d(l);
      o.call(c);
    };
  }
  var l = kg(t, 0, !1, null, null, !1, !1, "", W0);
  return (
    (t._reactRootContainer = l),
    (t[hr] = l.current),
    Ol(t.nodeType === 8 ? t.parentNode : t),
    Zs(function () {
      th(e, l, n, i);
    }),
    l
  );
}
function rh(t, e, n, i, r) {
  var s = n._reactRootContainer;
  if (s) {
    var a = s;
    if (typeof r == "function") {
      var o = r;
      r = function () {
        var l = _d(a);
        o.call(l);
      };
    }
    th(e, a, t, r);
  } else a = vC(n, e, t, r, i);
  return _d(a);
}
tw = function (t) {
  switch (t.tag) {
    case 3:
      var e = t.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var n = nl(e.pendingLanes);
        n !== 0 &&
          (ng(e, n | 1), Nn(e, Dt()), !(st & 6) && ((fo = Dt() + 500), us()));
      }
      break;
    case 13:
      Zs(function () {
        var i = fr(t, 1);
        if (i !== null) {
          var r = _n();
          Si(i, t, 1, r);
        }
      }),
        Ig(t, 1);
  }
};
ig = function (t) {
  if (t.tag === 13) {
    var e = fr(t, 134217728);
    if (e !== null) {
      var n = _n();
      Si(e, t, 134217728, n);
    }
    Ig(t, 134217728);
  }
};
nw = function (t) {
  if (t.tag === 13) {
    var e = Xr(t),
      n = fr(t, e);
    if (n !== null) {
      var i = _n();
      Si(n, t, e, i);
    }
    Ig(t, e);
  }
};
iw = function () {
  return ut;
};
rw = function (t, e) {
  var n = ut;
  try {
    return (ut = t), e();
  } finally {
    ut = n;
  }
};
yp = function (t, e, n) {
  switch (e) {
    case "input":
      if ((hp(t, n), (e = n.name), n.type === "radio" && e != null)) {
        for (n = t; n.parentNode; ) n = n.parentNode;
        for (
          n = n.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < n.length;
          e++
        ) {
          var i = n[e];
          if (i !== t && i.form === t.form) {
            var r = qd(i);
            if (!r) throw Error(ne(90));
            IS(i), hp(i, r);
          }
        }
      }
      break;
    case "textarea":
      OS(t, n);
      break;
    case "select":
      (e = n.value), e != null && Za(t, !!n.multiple, e, !1);
  }
};
GS = Pg;
WS = Zs;
var _C = {
    usingClientEntryPoint: !1,
    Events: [gc, Ia, qd, VS, HS, Pg],
  },
  Go = {
    findFiberByHostInstance: ks,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom",
  },
  yC = {
    bundleType: Go.bundleType,
    version: Go.version,
    rendererPackageName: Go.rendererPackageName,
    rendererConfig: Go.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: vr.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (t) {
      return (t = qS(t)), t === null ? null : t.stateNode;
    },
    findFiberByHostInstance: Go.findFiberByHostInstance || gC,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var Zc = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!Zc.isDisabled && Zc.supportsFiber)
    try {
      (Gd = Zc.inject(yC)), (Ui = Zc);
    } catch {}
}
$n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = _C;
$n.createPortal = function (t, e) {
  var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!Og(e)) throw Error(ne(200));
  return mC(t, e, null, n);
};
$n.createRoot = function (t, e) {
  if (!Og(t)) throw Error(ne(299));
  var n = !1,
    i = "",
    r = bE;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (n = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = kg(t, 1, !1, null, null, n, !1, i, r)),
    (t[hr] = e.current),
    Ol(t.nodeType === 8 ? t.parentNode : t),
    new Ug(e)
  );
};
$n.findDOMNode = function (t) {
  if (t == null) return null;
  if (t.nodeType === 1) return t;
  var e = t._reactInternals;
  if (e === void 0)
    throw typeof t.render == "function"
      ? Error(ne(188))
      : ((t = Object.keys(t).join(",")), Error(ne(268, t)));
  return (t = qS(e)), (t = t === null ? null : t.stateNode), t;
};
$n.flushSync = function (t) {
  return Zs(t);
};
$n.hydrate = function (t, e, n) {
  if (!ih(e)) throw Error(ne(200));
  return rh(null, t, e, !0, n);
};
$n.hydrateRoot = function (t, e, n) {
  if (!Og(t)) throw Error(ne(405));
  var i = (n != null && n.hydratedSources) || null,
    r = !1,
    s = "",
    a = bE;
  if (
    (n != null &&
      (n.unstable_strictMode === !0 && (r = !0),
      n.identifierPrefix !== void 0 && (s = n.identifierPrefix),
      n.onRecoverableError !== void 0 && (a = n.onRecoverableError)),
    (e = ME(e, null, t, 1, n ?? null, r, !1, s, a)),
    (t[hr] = e.current),
    Ol(t),
    i)
  )
    for (t = 0; t < i.length; t++)
      (n = i[t]),
        (r = n._getVersion),
        (r = r(n._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [n, r])
          : e.mutableSourceEagerHydrationData.push(n, r);
  return new nh(e);
};
$n.render = function (t, e, n) {
  if (!ih(e)) throw Error(ne(200));
  return rh(null, t, e, !1, n);
};
$n.unmountComponentAtNode = function (t) {
  if (!ih(t)) throw Error(ne(40));
  return t._reactRootContainer
    ? (Zs(function () {
        rh(null, null, t, !1, function () {
          (t._reactRootContainer = null), (t[hr] = null);
        });
      }),
      !0)
    : !1;
};
$n.unstable_batchedUpdates = Pg;
$n.unstable_renderSubtreeIntoContainer = function (t, e, n, i) {
  if (!ih(n)) throw Error(ne(200));
  if (t == null || t._reactInternals === void 0) throw Error(ne(38));
  return rh(t, e, n, !1, i);
};
$n.version = "18.3.1-next-f1338f8080-20240426";
function AE() {
  if (
    !(
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
    )
  )
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(AE);
    } catch (t) {
      console.error(t);
    }
}
AE(), (AS.exports = $n);
var xC = AS.exports,
  CE,
  $0 = xC;
(CE = $0.createRoot), $0.hydrateRoot;
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function $l() {
  return (
    ($l = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        }),
    $l.apply(this, arguments)
  );
}
var Br;
(function (t) {
  (t.Pop = "POP"), (t.Push = "PUSH"), (t.Replace = "REPLACE");
})(Br || (Br = {}));
const X0 = "popstate";
function SC(t) {
  t === void 0 && (t = {});
  function e(i, r) {
    let { pathname: s, search: a, hash: o } = i.location;
    return Jp(
      "",
      {
        pathname: s,
        search: a,
        hash: o,
      },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function n(i, r) {
    return typeof r == "string" ? r : yd(r);
  }
  return EC(e, n, null, t);
}
function Ot(t, e) {
  if (t === !1 || t === null || typeof t > "u") throw new Error(e);
}
function RE(t, e) {
  if (!t) {
    typeof console < "u" && console.warn(e);
    try {
      throw new Error(e);
    } catch {}
  }
}
function wC() {
  return Math.random().toString(36).substr(2, 8);
}
function q0(t, e) {
  return {
    usr: t.state,
    key: t.key,
    idx: e,
  };
}
function Jp(t, e, n, i) {
  return (
    n === void 0 && (n = null),
    $l(
      {
        pathname: typeof t == "string" ? t : t.pathname,
        search: "",
        hash: "",
      },
      typeof e == "string" ? Co(e) : e,
      {
        state: n,
        key: (e && e.key) || i || wC(),
      }
    )
  );
}
function yd(t) {
  let { pathname: e = "/", search: n = "", hash: i = "" } = t;
  return (
    n && n !== "?" && (e += n.charAt(0) === "?" ? n : "?" + n),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
  );
}
function Co(t) {
  let e = {};
  if (t) {
    let n = t.indexOf("#");
    n >= 0 && ((e.hash = t.substr(n)), (t = t.substr(0, n)));
    let i = t.indexOf("?");
    i >= 0 && ((e.search = t.substr(i)), (t = t.substr(0, i))),
      t && (e.pathname = t);
  }
  return e;
}
function EC(t, e, n, i) {
  i === void 0 && (i = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    a = r.history,
    o = Br.Pop,
    l = null,
    c = u();
  c == null &&
    ((c = 0),
    a.replaceState(
      $l({}, a.state, {
        idx: c,
      }),
      ""
    ));
  function u() {
    return (
      a.state || {
        idx: null,
      }
    ).idx;
  }
  function d() {
    o = Br.Pop;
    let m = u(),
      f = m == null ? null : m - c;
    (c = m),
      l &&
        l({
          action: o,
          location: x.location,
          delta: f,
        });
  }
  function h(m, f) {
    o = Br.Push;
    let y = Jp(x.location, m, f);
    c = u() + 1;
    let g = q0(y, c),
      S = x.createHref(y);
    try {
      a.pushState(g, "", S);
    } catch (T) {
      if (T instanceof DOMException && T.name === "DataCloneError") throw T;
      r.location.assign(S);
    }
    s &&
      l &&
      l({
        action: o,
        location: x.location,
        delta: 1,
      });
  }
  function p(m, f) {
    o = Br.Replace;
    let y = Jp(x.location, m, f);
    c = u();
    let g = q0(y, c),
      S = x.createHref(y);
    a.replaceState(g, "", S),
      s &&
        l &&
        l({
          action: o,
          location: x.location,
          delta: 0,
        });
  }
  function v(m) {
    let f = r.location.origin !== "null" ? r.location.origin : r.location.href,
      y = typeof m == "string" ? m : yd(m);
    return (
      (y = y.replace(/ $/, "%20")),
      Ot(
        f,
        "No window.location.(origin|href) available to create URL for href: " +
          y
      ),
      new URL(y, f)
    );
  }
  let x = {
    get action() {
      return o;
    },
    get location() {
      return t(r, a);
    },
    listen(m) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(X0, d),
        (l = m),
        () => {
          r.removeEventListener(X0, d), (l = null);
        }
      );
    },
    createHref(m) {
      return e(r, m);
    },
    createURL: v,
    encodeLocation(m) {
      let f = v(m);
      return {
        pathname: f.pathname,
        search: f.search,
        hash: f.hash,
      };
    },
    push: h,
    replace: p,
    go(m) {
      return a.go(m);
    },
  };
  return x;
}
var Y0;
(function (t) {
  (t.data = "data"),
    (t.deferred = "deferred"),
    (t.redirect = "redirect"),
    (t.error = "error");
})(Y0 || (Y0 = {}));
function TC(t, e, n) {
  return n === void 0 && (n = "/"), MC(t, e, n, !1);
}
function MC(t, e, n, i) {
  let r = typeof e == "string" ? Co(e) : e,
    s = Fg(r.pathname || "/", n);
  if (s == null) return null;
  let a = PE(t);
  bC(a);
  let o = null;
  for (let l = 0; o == null && l < a.length; ++l) {
    let c = OC(s);
    o = IC(a[l], c, i);
  }
  return o;
}
function PE(t, e, n, i) {
  e === void 0 && (e = []), n === void 0 && (n = []), i === void 0 && (i = "");
  let r = (s, a, o) => {
    let l = {
      relativePath: o === void 0 ? s.path || "" : o,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: a,
      route: s,
    };
    l.relativePath.startsWith("/") &&
      (Ot(
        l.relativePath.startsWith(i),
        'Absolute route path "' +
          l.relativePath +
          '" nested under path ' +
          ('"' + i + '" is not valid. An absolute child route path ') +
          "must start with the combined path of all its parent routes."
      ),
      (l.relativePath = l.relativePath.slice(i.length)));
    let c = Yr([i, l.relativePath]),
      u = n.concat(l);
    s.children &&
      s.children.length > 0 &&
      (Ot(
        s.index !== !0,
        "Index routes must not have child routes. Please remove " +
          ('all child routes from route path "' + c + '".')
      ),
      PE(s.children, e, u, c)),
      !(s.path == null && !s.index) &&
        e.push({
          path: c,
          score: DC(c, s.index),
          routesMeta: u,
        });
  };
  return (
    t.forEach((s, a) => {
      var o;
      if (s.path === "" || !((o = s.path) != null && o.includes("?"))) r(s, a);
      else for (let l of LE(s.path)) r(s, a, l);
    }),
    e
  );
}
function LE(t) {
  let e = t.split("/");
  if (e.length === 0) return [];
  let [n, ...i] = e,
    r = n.endsWith("?"),
    s = n.replace(/\?$/, "");
  if (i.length === 0) return r ? [s, ""] : [s];
  let a = LE(i.join("/")),
    o = [];
  return (
    o.push(...a.map((l) => (l === "" ? s : [s, l].join("/")))),
    r && o.push(...a),
    o.map((l) => (t.startsWith("/") && l === "" ? "/" : l))
  );
}
function bC(t) {
  t.sort((e, n) =>
    e.score !== n.score
      ? n.score - e.score
      : kC(
          e.routesMeta.map((i) => i.childrenIndex),
          n.routesMeta.map((i) => i.childrenIndex)
        )
  );
}
const AC = /^:[\w-]+$/,
  CC = 3,
  RC = 2,
  PC = 1,
  LC = 10,
  NC = -2,
  Z0 = (t) => t === "*";
function DC(t, e) {
  let n = t.split("/"),
    i = n.length;
  return (
    n.some(Z0) && (i += NC),
    e && (i += RC),
    n
      .filter((r) => !Z0(r))
      .reduce((r, s) => r + (AC.test(s) ? CC : s === "" ? PC : LC), i)
  );
}
function kC(t, e) {
  return t.length === e.length && t.slice(0, -1).every((i, r) => i === e[r])
    ? t[t.length - 1] - e[e.length - 1]
    : 0;
}
function IC(t, e, n) {
  let { routesMeta: i } = t,
    r = {},
    s = "/",
    a = [];
  for (let o = 0; o < i.length; ++o) {
    let l = i[o],
      c = o === i.length - 1,
      u = s === "/" ? e : e.slice(s.length) || "/",
      d = K0(
        {
          path: l.relativePath,
          caseSensitive: l.caseSensitive,
          end: c,
        },
        u
      ),
      h = l.route;
    if (
      (!d &&
        c &&
        n &&
        !i[i.length - 1].route.index &&
        (d = K0(
          {
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1,
          },
          u
        )),
      !d)
    )
      return null;
    Object.assign(r, d.params),
      a.push({
        params: r,
        pathname: Yr([s, d.pathname]),
        pathnameBase: jC(Yr([s, d.pathnameBase])),
        route: h,
      }),
      d.pathnameBase !== "/" && (s = Yr([s, d.pathnameBase]));
  }
  return a;
}
function K0(t, e) {
  typeof t == "string" &&
    (t = {
      path: t,
      caseSensitive: !1,
      end: !0,
    });
  let [n, i] = UC(t.path, t.caseSensitive, t.end),
    r = e.match(n);
  if (!r) return null;
  let s = r[0],
    a = s.replace(/(.)\/+$/, "$1"),
    o = r.slice(1);
  return {
    params: i.reduce((c, u, d) => {
      let { paramName: h, isOptional: p } = u;
      if (h === "*") {
        let x = o[d] || "";
        a = s.slice(0, s.length - x.length).replace(/(.)\/+$/, "$1");
      }
      const v = o[d];
      return (
        p && !v ? (c[h] = void 0) : (c[h] = (v || "").replace(/%2F/g, "/")), c
      );
    }, {}),
    pathname: s,
    pathnameBase: a,
    pattern: t,
  };
}
function UC(t, e, n) {
  e === void 0 && (e = !1),
    n === void 0 && (n = !0),
    RE(
      t === "*" || !t.endsWith("*") || t.endsWith("/*"),
      'Route path "' +
        t +
        '" will be treated as if it were ' +
        ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') +
        "always follow a `/` in the pattern. To get rid of this warning, " +
        ('please change the route path to "' + t.replace(/\*$/, "/*") + '".')
    );
  let i = [],
    r =
      "^" +
      t
        .replace(/\/*\*?$/, "")
        .replace(/^\/*/, "/")
        .replace(/[\\.*+^${}|()[\]]/g, "\\$&")
        .replace(
          /\/:([\w-]+)(\?)?/g,
          (a, o, l) => (
            i.push({
              paramName: o,
              isOptional: l != null,
            }),
            l ? "/?([^\\/]+)?" : "/([^\\/]+)"
          )
        );
  return (
    t.endsWith("*")
      ? (i.push({
          paramName: "*",
        }),
        (r += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$"))
      : n
      ? (r += "\\/*$")
      : t !== "" && t !== "/" && (r += "(?:(?=\\/|$))"),
    [new RegExp(r, e ? void 0 : "i"), i]
  );
}
function OC(t) {
  try {
    return t
      .split("/")
      .map((e) => decodeURIComponent(e).replace(/\//g, "%2F"))
      .join("/");
  } catch (e) {
    return (
      RE(
        !1,
        'The URL path "' +
          t +
          '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' +
          ("encoding (" + e + ").")
      ),
      t
    );
  }
}
function Fg(t, e) {
  if (e === "/") return t;
  if (!t.toLowerCase().startsWith(e.toLowerCase())) return null;
  let n = e.endsWith("/") ? e.length - 1 : e.length,
    i = t.charAt(n);
  return i && i !== "/" ? null : t.slice(n) || "/";
}
function FC(t, e) {
  e === void 0 && (e = "/");
  let {
    pathname: n,
    search: i = "",
    hash: r = "",
  } = typeof t == "string" ? Co(t) : t;
  return {
    pathname: n ? (n.startsWith("/") ? n : BC(n, e)) : e,
    search: VC(i),
    hash: HC(r),
  };
}
function BC(t, e) {
  let n = e.replace(/\/+$/, "").split("/");
  return (
    t.split("/").forEach((r) => {
      r === ".." ? n.length > 1 && n.pop() : r !== "." && n.push(r);
    }),
    n.length > 1 ? n.join("/") : "/"
  );
}
function rf(t, e, n, i) {
  return (
    "Cannot include a '" +
    t +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(i) +
      "].  Please separate it out to the ") +
    ("`to." + n + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function zC(t) {
  return t.filter(
    (e, n) => n === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function NE(t, e) {
  let n = zC(t);
  return e
    ? n.map((i, r) => (r === n.length - 1 ? i.pathname : i.pathnameBase))
    : n.map((i) => i.pathnameBase);
}
function DE(t, e, n, i) {
  i === void 0 && (i = !1);
  let r;
  typeof t == "string"
    ? (r = Co(t))
    : ((r = $l({}, t)),
      Ot(
        !r.pathname || !r.pathname.includes("?"),
        rf("?", "pathname", "search", r)
      ),
      Ot(
        !r.pathname || !r.pathname.includes("#"),
        rf("#", "pathname", "hash", r)
      ),
      Ot(!r.search || !r.search.includes("#"), rf("#", "search", "hash", r)));
  let s = t === "" || r.pathname === "",
    a = s ? "/" : r.pathname,
    o;
  if (a == null) o = n;
  else {
    let d = e.length - 1;
    if (!i && a.startsWith("..")) {
      let h = a.split("/");
      for (; h[0] === ".."; ) h.shift(), (d -= 1);
      r.pathname = h.join("/");
    }
    o = d >= 0 ? e[d] : "/";
  }
  let l = FC(r, o),
    c = a && a !== "/" && a.endsWith("/"),
    u = (s || a === ".") && n.endsWith("/");
  return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"), l;
}
const Yr = (t) => t.join("/").replace(/\/\/+/g, "/"),
  jC = (t) => t.replace(/\/+$/, "").replace(/^\/*/, "/"),
  VC = (t) => (!t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t),
  HC = (t) => (!t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t);
function GC(t) {
  return (
    t != null &&
    typeof t.status == "number" &&
    typeof t.statusText == "string" &&
    typeof t.internal == "boolean" &&
    "data" in t
  );
}
const kE = ["post", "put", "patch", "delete"];
new Set(kE);
const WC = ["get", ...kE];
new Set(WC);
/**
 * React Router v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function Xl() {
  return (
    (Xl = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        }),
    Xl.apply(this, arguments)
  );
}
const Bg = O.createContext(null),
  $C = O.createContext(null),
  ra = O.createContext(null),
  sh = O.createContext(null),
  sa = O.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1,
  }),
  IE = O.createContext(null);
function XC(t, e) {
  let { relative: n } = e === void 0 ? {} : e;
  _c() || Ot(!1);
  let { basename: i, navigator: r } = O.useContext(ra),
    {
      hash: s,
      pathname: a,
      search: o,
    } = FE(t, {
      relative: n,
    }),
    l = a;
  return (
    i !== "/" && (l = a === "/" ? i : Yr([i, a])),
    r.createHref({
      pathname: l,
      search: o,
      hash: s,
    })
  );
}
function _c() {
  return O.useContext(sh) != null;
}
function yc() {
  return _c() || Ot(!1), O.useContext(sh).location;
}
function UE(t) {
  O.useContext(ra).static || O.useLayoutEffect(t);
}
function OE() {
  let { isDataRoute: t } = O.useContext(sa);
  return t ? aR() : qC();
}
function qC() {
  _c() || Ot(!1);
  let t = O.useContext(Bg),
    { basename: e, future: n, navigator: i } = O.useContext(ra),
    { matches: r } = O.useContext(sa),
    { pathname: s } = yc(),
    a = JSON.stringify(NE(r, n.v7_relativeSplatPath)),
    o = O.useRef(!1);
  return (
    UE(() => {
      o.current = !0;
    }),
    O.useCallback(
      function (c, u) {
        if ((u === void 0 && (u = {}), !o.current)) return;
        if (typeof c == "number") {
          i.go(c);
          return;
        }
        let d = DE(c, JSON.parse(a), s, u.relative === "path");
        t == null &&
          e !== "/" &&
          (d.pathname = d.pathname === "/" ? e : Yr([e, d.pathname])),
          (u.replace ? i.replace : i.push)(d, u.state, u);
      },
      [e, i, a, s, t]
    )
  );
}
function FE(t, e) {
  let { relative: n } = e === void 0 ? {} : e,
    { future: i } = O.useContext(ra),
    { matches: r } = O.useContext(sa),
    { pathname: s } = yc(),
    a = JSON.stringify(NE(r, i.v7_relativeSplatPath));
  return O.useMemo(() => DE(t, JSON.parse(a), s, n === "path"), [t, a, s, n]);
}
function YC(t, e) {
  return ZC(t, e);
}
function ZC(t, e, n, i) {
  _c() || Ot(!1);
  let { navigator: r, static: s } = O.useContext(ra),
    { matches: a } = O.useContext(sa),
    o = a[a.length - 1],
    l = o ? o.params : {};
  o && o.pathname;
  let c = o ? o.pathnameBase : "/";
  o && o.route;
  let u = yc(),
    d;
  if (e) {
    var h;
    let f = typeof e == "string" ? Co(e) : e;
    c === "/" || ((h = f.pathname) != null && h.startsWith(c)) || Ot(!1),
      (d = f);
  } else d = u;
  let p = d.pathname || "/",
    v = p;
  if (c !== "/") {
    let f = c.replace(/^\//, "").split("/");
    v = "/" + p.replace(/^\//, "").split("/").slice(f.length).join("/");
  }
  let x =
      !s && n && n.matches && n.matches.length > 0
        ? n.matches
        : TC(t, {
            pathname: v,
          }),
    m = tR(
      x &&
        x.map((f) =>
          Object.assign({}, f, {
            params: Object.assign({}, l, f.params),
            pathname: Yr([
              c,
              r.encodeLocation
                ? r.encodeLocation(f.pathname).pathname
                : f.pathname,
            ]),
            pathnameBase:
              f.pathnameBase === "/"
                ? c
                : Yr([
                    c,
                    r.encodeLocation
                      ? r.encodeLocation(f.pathnameBase).pathname
                      : f.pathnameBase,
                  ]),
          })
        ),
      a,
      n,
      i
    );
  return e && m
    ? O.createElement(
        sh.Provider,
        {
          value: {
            location: Xl(
              {
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default",
              },
              d
            ),
            navigationType: Br.Pop,
          },
        },
        m
      )
    : m;
}
function KC() {
  let t = sR(),
    e = GC(t)
      ? t.status + " " + t.statusText
      : t instanceof Error
      ? t.message
      : JSON.stringify(t),
    n = t instanceof Error ? t.stack : null,
    r = {
      padding: "0.5rem",
      backgroundColor: "rgba(200,200,200, 0.5)",
    };
  return O.createElement(
    O.Fragment,
    null,
    O.createElement("h2", null, "Unexpected Application Error!"),
    O.createElement(
      "h3",
      {
        style: {
          fontStyle: "italic",
        },
      },
      e
    ),
    n
      ? O.createElement(
          "pre",
          {
            style: r,
          },
          n
        )
      : null,
    null
  );
}
const JC = O.createElement(KC, null);
class QC extends O.Component {
  constructor(e) {
    super(e),
      (this.state = {
        location: e.location,
        revalidation: e.revalidation,
        error: e.error,
      });
  }
  static getDerivedStateFromError(e) {
    return {
      error: e,
    };
  }
  static getDerivedStateFromProps(e, n) {
    return n.location !== e.location ||
      (n.revalidation !== "idle" && e.revalidation === "idle")
      ? {
          error: e.error,
          location: e.location,
          revalidation: e.revalidation,
        }
      : {
          error: e.error !== void 0 ? e.error : n.error,
          location: n.location,
          revalidation: e.revalidation || n.revalidation,
        };
  }
  componentDidCatch(e, n) {
    console.error(
      "React Router caught the following error during render",
      e,
      n
    );
  }
  render() {
    return this.state.error !== void 0
      ? O.createElement(
          sa.Provider,
          {
            value: this.props.routeContext,
          },
          O.createElement(IE.Provider, {
            value: this.state.error,
            children: this.props.component,
          })
        )
      : this.props.children;
  }
}
function eR(t) {
  let { routeContext: e, match: n, children: i } = t,
    r = O.useContext(Bg);
  return (
    r &&
      r.static &&
      r.staticContext &&
      (n.route.errorElement || n.route.ErrorBoundary) &&
      (r.staticContext._deepestRenderedBoundaryId = n.route.id),
    O.createElement(
      sa.Provider,
      {
        value: e,
      },
      i
    )
  );
}
function tR(t, e, n, i) {
  var r;
  if (
    (e === void 0 && (e = []),
    n === void 0 && (n = null),
    i === void 0 && (i = null),
    t == null)
  ) {
    var s;
    if (!n) return null;
    if (n.errors) t = n.matches;
    else if (
      (s = i) != null &&
      s.v7_partialHydration &&
      e.length === 0 &&
      !n.initialized &&
      n.matches.length > 0
    )
      t = n.matches;
    else return null;
  }
  let a = t,
    o = (r = n) == null ? void 0 : r.errors;
  if (o != null) {
    let u = a.findIndex(
      (d) => d.route.id && (o == null ? void 0 : o[d.route.id]) !== void 0
    );
    u >= 0 || Ot(!1), (a = a.slice(0, Math.min(a.length, u + 1)));
  }
  let l = !1,
    c = -1;
  if (n && i && i.v7_partialHydration)
    for (let u = 0; u < a.length; u++) {
      let d = a[u];
      if (
        ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (c = u),
        d.route.id)
      ) {
        let { loaderData: h, errors: p } = n,
          v =
            d.route.loader &&
            h[d.route.id] === void 0 &&
            (!p || p[d.route.id] === void 0);
        if (d.route.lazy || v) {
          (l = !0), c >= 0 ? (a = a.slice(0, c + 1)) : (a = [a[0]]);
          break;
        }
      }
    }
  return a.reduceRight((u, d, h) => {
    let p,
      v = !1,
      x = null,
      m = null;
    n &&
      ((p = o && d.route.id ? o[d.route.id] : void 0),
      (x = d.route.errorElement || JC),
      l &&
        (c < 0 && h === 0
          ? ((v = !0), (m = null))
          : c === h &&
            ((v = !0), (m = d.route.hydrateFallbackElement || null))));
    let f = e.concat(a.slice(0, h + 1)),
      y = () => {
        let g;
        return (
          p
            ? (g = x)
            : v
            ? (g = m)
            : d.route.Component
            ? (g = O.createElement(d.route.Component, null))
            : d.route.element
            ? (g = d.route.element)
            : (g = u),
          O.createElement(eR, {
            match: d,
            routeContext: {
              outlet: u,
              matches: f,
              isDataRoute: n != null,
            },
            children: g,
          })
        );
      };
    return n && (d.route.ErrorBoundary || d.route.errorElement || h === 0)
      ? O.createElement(QC, {
          location: n.location,
          revalidation: n.revalidation,
          component: x,
          error: p,
          children: y(),
          routeContext: {
            outlet: null,
            matches: f,
            isDataRoute: !0,
          },
        })
      : y();
  }, null);
}
var BE = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      t
    );
  })(BE || {}),
  xd = (function (t) {
    return (
      (t.UseBlocker = "useBlocker"),
      (t.UseLoaderData = "useLoaderData"),
      (t.UseActionData = "useActionData"),
      (t.UseRouteError = "useRouteError"),
      (t.UseNavigation = "useNavigation"),
      (t.UseRouteLoaderData = "useRouteLoaderData"),
      (t.UseMatches = "useMatches"),
      (t.UseRevalidator = "useRevalidator"),
      (t.UseNavigateStable = "useNavigate"),
      (t.UseRouteId = "useRouteId"),
      t
    );
  })(xd || {});
function nR(t) {
  let e = O.useContext(Bg);
  return e || Ot(!1), e;
}
function iR(t) {
  let e = O.useContext($C);
  return e || Ot(!1), e;
}
function rR(t) {
  let e = O.useContext(sa);
  return e || Ot(!1), e;
}
function zE(t) {
  let e = rR(),
    n = e.matches[e.matches.length - 1];
  return n.route.id || Ot(!1), n.route.id;
}
function sR() {
  var t;
  let e = O.useContext(IE),
    n = iR(xd.UseRouteError),
    i = zE(xd.UseRouteError);
  return e !== void 0 ? e : (t = n.errors) == null ? void 0 : t[i];
}
function aR() {
  let { router: t } = nR(BE.UseNavigateStable),
    e = zE(xd.UseNavigateStable),
    n = O.useRef(!1);
  return (
    UE(() => {
      n.current = !0;
    }),
    O.useCallback(
      function (r, s) {
        s === void 0 && (s = {}),
          n.current &&
            (typeof r == "number"
              ? t.navigate(r)
              : t.navigate(
                  r,
                  Xl(
                    {
                      fromRouteId: e,
                    },
                    s
                  )
                ));
      },
      [t, e]
    )
  );
}
function oR(t, e) {
  t == null || t.v7_startTransition, t == null || t.v7_relativeSplatPath;
}
function rl(t) {
  Ot(!1);
}
function lR(t) {
  let {
    basename: e = "/",
    children: n = null,
    location: i,
    navigationType: r = Br.Pop,
    navigator: s,
    static: a = !1,
    future: o,
  } = t;
  _c() && Ot(!1);
  let l = e.replace(/^\/*/, "/"),
    c = O.useMemo(
      () => ({
        basename: l,
        navigator: s,
        static: a,
        future: Xl(
          {
            v7_relativeSplatPath: !1,
          },
          o
        ),
      }),
      [l, o, s, a]
    );
  typeof i == "string" && (i = Co(i));
  let {
      pathname: u = "/",
      search: d = "",
      hash: h = "",
      state: p = null,
      key: v = "default",
    } = i,
    x = O.useMemo(() => {
      let m = Fg(u, l);
      return m == null
        ? null
        : {
            location: {
              pathname: m,
              search: d,
              hash: h,
              state: p,
              key: v,
            },
            navigationType: r,
          };
    }, [l, u, d, h, p, v, r]);
  return x == null
    ? null
    : O.createElement(
        ra.Provider,
        {
          value: c,
        },
        O.createElement(sh.Provider, {
          children: n,
          value: x,
        })
      );
}
function cR(t) {
  let { children: e, location: n } = t;
  return YC(Qp(e), n);
}
new Promise(() => {});
function Qp(t, e) {
  e === void 0 && (e = []);
  let n = [];
  return (
    O.Children.forEach(t, (i, r) => {
      if (!O.isValidElement(i)) return;
      let s = [...e, r];
      if (i.type === O.Fragment) {
        n.push.apply(n, Qp(i.props.children, s));
        return;
      }
      i.type !== rl && Ot(!1), !i.props.index || !i.props.children || Ot(!1);
      let a = {
        id: i.props.id || s.join("-"),
        caseSensitive: i.props.caseSensitive,
        element: i.props.element,
        Component: i.props.Component,
        index: i.props.index,
        path: i.props.path,
        loader: i.props.loader,
        action: i.props.action,
        errorElement: i.props.errorElement,
        ErrorBoundary: i.props.ErrorBoundary,
        hasErrorBoundary:
          i.props.ErrorBoundary != null || i.props.errorElement != null,
        shouldRevalidate: i.props.shouldRevalidate,
        handle: i.props.handle,
        lazy: i.props.lazy,
      };
      i.props.children && (a.children = Qp(i.props.children, s)), n.push(a);
    }),
    n
  );
}
/**
 * React Router DOM v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */

function em() {
  return (
    (em = Object.assign
      ? Object.assign.bind()
      : function (t) {
          for (var e = 1; e < arguments.length; e++) {
            var n = arguments[e];
            for (var i in n)
              Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
          }
          return t;
        }),
    em.apply(this, arguments)
  );
}
function uR(t, e) {
  if (t == null) return {};
  var n = {},
    i = Object.keys(t),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (n[r] = t[r]);
  return n;
}
function dR(t) {
  return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
}
function hR(t, e) {
  return t.button === 0 && (!e || e === "_self") && !dR(t);
}
const fR = [
    "onClick",
    "relative",
    "reloadDocument",
    "replace",
    "state",
    "target",
    "to",
    "preventScrollReset",
    "viewTransition",
  ],
  pR = "6";
try {
  window.__reactRouterVersion = pR;
} catch {}
const mR = "startTransition",
  J0 = cb[mR];
function gR(t) {
  let { basename: e, children: n, future: i, window: r } = t,
    s = O.useRef();
  s.current == null &&
    (s.current = SC({
      window: r,
      v5Compat: !0,
    }));
  let a = s.current,
    [o, l] = O.useState({
      action: a.action,
      location: a.location,
    }),
    { v7_startTransition: c } = i || {},
    u = O.useCallback(
      (d) => {
        c && J0 ? J0(() => l(d)) : l(d);
      },
      [l, c]
    );
  return (
    O.useLayoutEffect(() => a.listen(u), [a, u]),
    O.useEffect(() => oR(i), [i]),
    O.createElement(lR, {
      basename: e,
      children: n,
      location: o.location,
      navigationType: o.action,
      navigator: a,
      future: i,
    })
  );
}
const vR =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  _R = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  Vu = O.forwardRef(function (e, n) {
    let {
        onClick: i,
        relative: r,
        reloadDocument: s,
        replace: a,
        state: o,
        target: l,
        to: c,
        preventScrollReset: u,
        viewTransition: d,
      } = e,
      h = uR(e, fR),
      { basename: p } = O.useContext(ra),
      v,
      x = !1;
    if (typeof c == "string" && _R.test(c) && ((v = c), vR))
      try {
        let g = new URL(window.location.href),
          S = c.startsWith("//") ? new URL(g.protocol + c) : new URL(c),
          T = Fg(S.pathname, p);
        S.origin === g.origin && T != null
          ? (c = T + S.search + S.hash)
          : (x = !0);
      } catch {}
    let m = XC(c, {
        relative: r,
      }),
      f = yR(c, {
        replace: a,
        state: o,
        target: l,
        preventScrollReset: u,
        relative: r,
        viewTransition: d,
      });
    function y(g) {
      i && i(g), g.defaultPrevented || f(g);
    }
    return O.createElement(
      "a",
      em({}, h, {
        href: v || m,
        onClick: x || s ? i : y,
        ref: n,
        target: l,
      })
    );
  });
var Q0;
(function (t) {
  (t.UseScrollRestoration = "useScrollRestoration"),
    (t.UseSubmit = "useSubmit"),
    (t.UseSubmitFetcher = "useSubmitFetcher"),
    (t.UseFetcher = "useFetcher"),
    (t.useViewTransitionState = "useViewTransitionState");
})(Q0 || (Q0 = {}));
var e_;
(function (t) {
  (t.UseFetcher = "useFetcher"),
    (t.UseFetchers = "useFetchers"),
    (t.UseScrollRestoration = "useScrollRestoration");
})(e_ || (e_ = {}));
function yR(t, e) {
  let {
      target: n,
      replace: i,
      state: r,
      preventScrollReset: s,
      relative: a,
      viewTransition: o,
    } = e === void 0 ? {} : e,
    l = OE(),
    c = yc(),
    u = FE(t, {
      relative: a,
    });
  return O.useCallback(
    (d) => {
      if (hR(d, n)) {
        d.preventDefault();
        let h = i !== void 0 ? i : yd(c) === yd(u);
        l(t, {
          replace: h,
          state: r,
          preventScrollReset: s,
          relative: a,
          viewTransition: o,
        });
      }
    },
    [c, l, u, i, r, n, t, s, a, o]
  );
}
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

var xR = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round",
};
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const SR = (t) =>
    t
      .replace(/([a-z0-9])([A-Z])/g, "$1-$2")
      .toLowerCase()
      .trim(),
  Ht = (t, e) => {
    const n = O.forwardRef(
      (
        {
          color: i = "currentColor",
          size: r = 24,
          strokeWidth: s = 2,
          absoluteStrokeWidth: a,
          className: o = "",
          children: l,
          ...c
        },
        u
      ) =>
        O.createElement(
          "svg",
          {
            ref: u,
            ...xR,
            width: r,
            height: r,
            stroke: i,
            strokeWidth: a ? (Number(s) * 24) / Number(r) : s,
            className: ["lucide", `lucide-${SR(t)}`, o].join(" "),
            ...c,
          },
          [
            ...e.map(([d, h]) => O.createElement(d, h)),
            ...(Array.isArray(l) ? l : [l]),
          ]
        )
    );
    return (n.displayName = `${t}`), n;
  };
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const t_ = Ht("AlertCircle", [
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay",
    },
  ],
  [
    "line",
    {
      x1: "12",
      x2: "12",
      y1: "8",
      y2: "12",
      key: "1pkeuh",
    },
  ],
  [
    "line",
    {
      x1: "12",
      x2: "12.01",
      y1: "16",
      y2: "16",
      key: "4dfq90",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const jE = Ht("Award", [
  [
    "circle",
    {
      cx: "12",
      cy: "8",
      r: "6",
      key: "1vp47v",
    },
  ],
  [
    "path",
    {
      d: "M15.477 12.89 17 22l-5-3-5 3 1.523-9.11",
      key: "em7aur",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const wR = Ht("Calendar", [
  [
    "path",
    {
      d: "M8 2v4",
      key: "1cmpym",
    },
  ],
  [
    "path",
    {
      d: "M16 2v4",
      key: "4m81vk",
    },
  ],
  [
    "rect",
    {
      width: "18",
      height: "18",
      x: "3",
      y: "4",
      rx: "2",
      key: "1hopcy",
    },
  ],
  [
    "path",
    {
      d: "M3 10h18",
      key: "8toen8",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const n_ = Ht("CheckCircle2", [
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay",
    },
  ],
  [
    "path",
    {
      d: "m9 12 2 2 4-4",
      key: "dzmm74",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const ER = Ht("Clock", [
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay",
    },
  ],
  [
    "polyline",
    {
      points: "12 6 12 12 16 14",
      key: "68esgv",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const TR = Ht("Flag", [
  [
    "path",
    {
      d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z",
      key: "i9b6wo",
    },
  ],
  [
    "line",
    {
      x1: "4",
      x2: "4",
      y1: "22",
      y2: "15",
      key: "1cm3nv",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const MR = Ht("Gift", [
  [
    "rect",
    {
      x: "3",
      y: "8",
      width: "18",
      height: "4",
      rx: "1",
      key: "bkv52",
    },
  ],
  [
    "path",
    {
      d: "M12 8v13",
      key: "1c76mn",
    },
  ],
  [
    "path",
    {
      d: "M19 12v7a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2v-7",
      key: "6wjy6b",
    },
  ],
  [
    "path",
    {
      d: "M7.5 8a2.5 2.5 0 0 1 0-5A4.8 8 0 0 1 12 8a4.8 8 0 0 1 4.5-5 2.5 2.5 0 0 1 0 5",
      key: "1ihvrl",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const VE = Ht("Heart", [
  [
    "path",
    {
      d: "M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z",
      key: "c3ymky",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const bR = Ht("Instagram", [
  [
    "rect",
    {
      width: "20",
      height: "20",
      x: "2",
      y: "2",
      rx: "5",
      ry: "5",
      key: "2e1cvw",
    },
  ],
  [
    "path",
    {
      d: "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z",
      key: "9exkf1",
    },
  ],
  [
    "line",
    {
      x1: "17.5",
      x2: "17.51",
      y1: "6.5",
      y2: "6.5",
      key: "r4j83e",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const HE = Ht("MapPin", [
  [
    "path",
    {
      d: "M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z",
      key: "2oe9fu",
    },
  ],
  [
    "circle",
    {
      cx: "12",
      cy: "10",
      r: "3",
      key: "ilqhr7",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const AR = Ht("Menu", [
  [
    "line",
    {
      x1: "4",
      x2: "20",
      y1: "12",
      y2: "12",
      key: "1e0a9i",
    },
  ],
  [
    "line",
    {
      x1: "4",
      x2: "20",
      y1: "6",
      y2: "6",
      key: "1owob3",
    },
  ],
  [
    "line",
    {
      x1: "4",
      x2: "20",
      y1: "18",
      y2: "18",
      key: "yk5zj1",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const CR = Ht("Phone", [
  [
    "path",
    {
      d: "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z",
      key: "foiqr5",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const di = Ht("Star", [
  [
    "polygon",
    {
      points:
        "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2",
      key: "8f66p6",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const RR = Ht("Target", [
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "10",
      key: "1mglay",
    },
  ],
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "6",
      key: "1vlfrh",
    },
  ],
  [
    "circle",
    {
      cx: "12",
      cy: "12",
      r: "2",
      key: "1c9p78",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const PR = Ht("Timer", [
  [
    "line",
    {
      x1: "10",
      x2: "14",
      y1: "2",
      y2: "2",
      key: "14vaq8",
    },
  ],
  [
    "line",
    {
      x1: "12",
      x2: "15",
      y1: "14",
      y2: "11",
      key: "17fdiu",
    },
  ],
  [
    "circle",
    {
      cx: "12",
      cy: "14",
      r: "8",
      key: "1e1u0o",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const GE = Ht("Trophy", [
  [
    "path",
    {
      d: "M6 9H4.5a2.5 2.5 0 0 1 0-5H6",
      key: "17hqa7",
    },
  ],
  [
    "path",
    {
      d: "M18 9h1.5a2.5 2.5 0 0 0 0-5H18",
      key: "lmptdp",
    },
  ],
  [
    "path",
    {
      d: "M4 22h16",
      key: "57wxv0",
    },
  ],
  [
    "path",
    {
      d: "M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22",
      key: "1nw9bq",
    },
  ],
  [
    "path",
    {
      d: "M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22",
      key: "1np0yb",
    },
  ],
  [
    "path",
    {
      d: "M18 2H6v7a6 6 0 0 0 12 0V2Z",
      key: "u46fv3",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const i_ = Ht("Users", [
  [
    "path",
    {
      d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2",
      key: "1yyitq",
    },
  ],
  [
    "circle",
    {
      cx: "9",
      cy: "7",
      r: "4",
      key: "nufk8",
    },
  ],
  [
    "path",
    {
      d: "M22 21v-2a4 4 0 0 0-3-3.87",
      key: "kshegd",
    },
  ],
  [
    "path",
    {
      d: "M16 3.13a4 4 0 0 1 0 7.75",
      key: "1da9ce",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const WE = Ht("X", [
  [
    "path",
    {
      d: "M18 6 6 18",
      key: "1bl5f8",
    },
  ],
  [
    "path",
    {
      d: "m6 6 12 12",
      key: "d8bk6v",
    },
  ],
]);
/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */

const zg = Ht("Zap", [
    [
      "polygon",
      {
        points: "13 2 3 14 12 14 11 22 21 10 12 10 13 2",
        key: "45s27k",
      },
    ],
  ]),
  LR = () => {
    const [t, e] = O.useState(!1),
      n = [
        {
          name: "Inicio",
          href: "/",
        },
        {
          name: "Acerca de",
          href: "/acerca-de",
        },
        {
          name: "Patrocinadores",
          href: "/patrocinadores",
        },
        {
          name: "Inscripcin",
          href: "/registro",
        },
        {
          name: "Contacto",
          href: "https://wa.me/5213319426363",
          external: !0,
        },
      ];
    return _.jsx("div", {
      className: "fixed top-0 left-0 right-0 z-50 px-4",
      children: _.jsxs("nav", {
        className:
          "max-w-7xl mx-auto mt-4 bg-verde/95 backdrop-blur-sm rounded-2xl shadow-lg",
        children: [
          _.jsxs("div", {
            className: "container flex items-center justify-between h-16",
            children: [
              _.jsx(Vu, {
                to: "/",
                className: "flex items-center",
                children: _.jsx("span", {
                  className: "text-xl font-bold font-heading text-marfil",
                  children: "Padeln",
                }),
              }),
              _.jsx("div", {
                className:
                  "hidden md:flex items-center justify-center space-x-8",
                children: n.map((i) =>
                  i.external
                    ? _.jsx(
                        "a",
                        {
                          href: i.href,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className:
                            "text-sm font-medium text-marfil hover:text-beige transition-colors duration-300",
                          children: i.name,
                        },
                        i.name
                      )
                    : _.jsx(
                        Vu,
                        {
                          to: i.href,
                          className:
                            "text-sm font-medium text-marfil hover:text-beige transition-colors duration-300",
                          children: i.name,
                        },
                        i.name
                      )
                ),
              }),
              _.jsx("button", {
                className: "md:hidden text-marfil",
                onClick: () => e(!t),
                children: t
                  ? _.jsx(WE, {
                      size: 24,
                    })
                  : _.jsx(AR, {
                      size: 24,
                    }),
              }),
            ],
          }),
          t &&
            _.jsx("div", {
              className: "md:hidden bg-verde/95 backdrop-blur-sm rounded-b-2xl",
              children: _.jsx("div", {
                className: "px-2 pt-2 pb-3 space-y-1",
                children: n.map((i) =>
                  i.external
                    ? _.jsx(
                        "a",
                        {
                          href: i.href,
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className:
                            "block px-3 py-2 text-base font-medium text-marfil hover:text-beige transition-colors duration-300",
                          onClick: () => e(!1),
                          children: i.name,
                        },
                        i.name
                      )
                    : _.jsx(
                        Vu,
                        {
                          to: i.href,
                          className:
                            "block px-3 py-2 text-base font-medium text-marfil hover:text-beige transition-colors duration-300",
                          onClick: () => e(!1),
                          children: i.name,
                        },
                        i.name
                      )
                ),
              }),
            }),
        ],
      }),
    });
  },
  NR = ({ className: t }) =>
    _.jsx("img", {
      src: "imagenes/logo_bw.png",
      alt: "Padeln Logo",
      className: t,
      style: {
        objectFit: "contain",
      },
    }),
  jg = O.createContext({});
function Ro(t) {
  const e = O.useRef(null);
  return e.current === null && (e.current = t()), e.current;
}
const ah = O.createContext(null),
  oh = O.createContext({
    transformPagePoint: (t) => t,
    isStatic: !1,
    reducedMotion: "never",
  });
class DR extends O.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const i = this.props.sizeRef.current;
      (i.height = n.offsetHeight || 0),
        (i.width = n.offsetWidth || 0),
        (i.top = n.offsetTop),
        (i.left = n.offsetLeft);
    }
    return null;
  }
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function kR({ children: t, isPresent: e }) {
  const n = O.useId(),
    i = O.useRef(null),
    r = O.useRef({
      width: 0,
      height: 0,
      top: 0,
      left: 0,
    }),
    { nonce: s } = O.useContext(oh);
  return (
    O.useInsertionEffect(() => {
      const { width: a, height: o, top: l, left: c } = r.current;
      if (e || !i.current || !a || !o) return;
      i.current.dataset.motionPopId = n;
      const u = document.createElement("style");
      return (
        s && (u.nonce = s),
        document.head.appendChild(u),
        u.sheet &&
          u.sheet.insertRule(`
          [data-motion-pop-id="${n}"] {
            position: absolute !important;
            width: ${a}px !important;
            height: ${o}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `),
        () => {
          document.head.removeChild(u);
        }
      );
    }, [e]),
    _.jsx(DR, {
      isPresent: e,
      childRef: i,
      sizeRef: r,
      children: O.cloneElement(t, {
        ref: i,
      }),
    })
  );
}
const IR = ({
  children: t,
  initial: e,
  isPresent: n,
  onExitComplete: i,
  custom: r,
  presenceAffectsLayout: s,
  mode: a,
}) => {
  const o = Ro(UR),
    l = O.useId(),
    c = O.useCallback(
      (d) => {
        o.set(d, !0);
        for (const h of o.values()) if (!h) return;
        i && i();
      },
      [o, i]
    ),
    u = O.useMemo(
      () => ({
        id: l,
        initial: e,
        isPresent: n,
        custom: r,
        onExitComplete: c,
        register: (d) => (o.set(d, !1), () => o.delete(d)),
      }),
      s ? [Math.random(), c] : [n, c]
    );
  return (
    O.useMemo(() => {
      o.forEach((d, h) => o.set(h, !1));
    }, [n]),
    O.useEffect(() => {
      !n && !o.size && i && i();
    }, [n]),
    a === "popLayout" &&
      (t = _.jsx(kR, {
        isPresent: n,
        children: t,
      })),
    _.jsx(ah.Provider, {
      value: u,
      children: t,
    })
  );
};
function UR() {
  return new Map();
}
function $E(t = !0) {
  const e = O.useContext(ah);
  if (e === null) return [!0, null];
  const { isPresent: n, onExitComplete: i, register: r } = e,
    s = O.useId();
  O.useEffect(() => {
    t && r(s);
  }, [t]);
  const a = O.useCallback(() => t && i && i(s), [s, i, t]);
  return !n && i ? [!1, a] : [!0];
}
const Kc = (t) => t.key || "";
function r_(t) {
  const e = [];
  return (
    O.Children.forEach(t, (n) => {
      O.isValidElement(n) && e.push(n);
    }),
    e
  );
}
const Vg = typeof window < "u",
  lh = Vg ? O.useLayoutEffect : O.useEffect,
  OR = ({
    children: t,
    custom: e,
    initial: n = !0,
    onExitComplete: i,
    presenceAffectsLayout: r = !0,
    mode: s = "sync",
    propagate: a = !1,
  }) => {
    const [o, l] = $E(a),
      c = O.useMemo(() => r_(t), [t]),
      u = a && !o ? [] : c.map(Kc),
      d = O.useRef(!0),
      h = O.useRef(c),
      p = Ro(() => new Map()),
      [v, x] = O.useState(c),
      [m, f] = O.useState(c);
    lh(() => {
      (d.current = !1), (h.current = c);
      for (let S = 0; S < m.length; S++) {
        const T = Kc(m[S]);
        u.includes(T) ? p.delete(T) : p.get(T) !== !0 && p.set(T, !1);
      }
    }, [m, u.length, u.join("-")]);
    const y = [];
    if (c !== v) {
      let S = [...c];
      for (let T = 0; T < m.length; T++) {
        const A = m[T],
          b = Kc(A);
        u.includes(b) || (S.splice(T, 0, A), y.push(A));
      }
      s === "wait" && y.length && (S = y), f(r_(S)), x(c);
      return;
    }
    const { forceRender: g } = O.useContext(jg);
    return _.jsx(_.Fragment, {
      children: m.map((S) => {
        const T = Kc(S),
          A = a && !o ? !1 : c === m || u.includes(T),
          b = () => {
            if (p.has(T)) p.set(T, !0);
            else return;
            let P = !0;
            p.forEach((G) => {
              G || (P = !1);
            }),
              P &&
                (g == null || g(),
                f(h.current),
                a && (l == null || l()),
                i && i());
          };
        return _.jsx(
          IR,
          {
            isPresent: A,
            initial: !d.current || n ? void 0 : !1,
            custom: A ? void 0 : e,
            presenceAffectsLayout: r,
            mode: s,
            onExitComplete: A ? void 0 : b,
            children: S,
          },
          T
        );
      }),
    });
  },
  yn = (t) => t;
let FR = yn,
  tm = yn;
function Hg(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const Ks = (t, e, n) => {
    const i = e - t;
    return i === 0 ? 1 : (n - t) / i;
  },
  cr = (t) => t * 1e3,
  ur = (t) => t / 1e3,
  BR = {
    skipAnimations: !1,
    useManualTiming: !1,
  };
function zR(t) {
  let e = new Set(),
    n = new Set(),
    i = !1,
    r = !1;
  const s = new WeakSet();
  let a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1,
  };
  function o(c) {
    s.has(c) && (l.schedule(c), t()), c(a);
  }
  const l = {
    schedule: (c, u = !1, d = !1) => {
      const p = d && i ? e : n;
      return u && s.add(c), p.has(c) || p.add(c), c;
    },
    cancel: (c) => {
      n.delete(c), s.delete(c);
    },
    process: (c) => {
      if (((a = c), i)) {
        r = !0;
        return;
      }
      (i = !0),
        ([e, n] = [n, e]),
        e.forEach(o),
        e.clear(),
        (i = !1),
        r && ((r = !1), l.process(c));
    },
  };
  return l;
}
const Jc = [
    "read",
    "resolveKeyframes",
    "update",
    "preRender",
    "render",
    "postRender",
  ],
  jR = 40;
function XE(t, e) {
  let n = !1,
    i = !0;
  const r = {
      delta: 0,
      timestamp: 0,
      isProcessing: !1,
    },
    s = () => (n = !0),
    a = Jc.reduce((f, y) => ((f[y] = zR(s)), f), {}),
    {
      read: o,
      resolveKeyframes: l,
      update: c,
      preRender: u,
      render: d,
      postRender: h,
    } = a,
    p = () => {
      const f = performance.now();
      (n = !1),
        (r.delta = i ? 1e3 / 60 : Math.max(Math.min(f - r.timestamp, jR), 1)),
        (r.timestamp = f),
        (r.isProcessing = !0),
        o.process(r),
        l.process(r),
        c.process(r),
        u.process(r),
        d.process(r),
        h.process(r),
        (r.isProcessing = !1),
        n && e && ((i = !1), t(p));
    },
    v = () => {
      (n = !0), (i = !0), r.isProcessing || t(p);
    };
  return {
    schedule: Jc.reduce((f, y) => {
      const g = a[y];
      return (f[y] = (S, T = !1, A = !1) => (n || v(), g.schedule(S, T, A))), f;
    }, {}),
    cancel: (f) => {
      for (let y = 0; y < Jc.length; y++) a[Jc[y]].cancel(f);
    },
    state: r,
    steps: a,
  };
}
const {
    schedule: at,
    cancel: Mi,
    state: Xt,
    steps: sf,
  } = XE(typeof requestAnimationFrame < "u" ? requestAnimationFrame : yn, !0),
  qE = O.createContext({
    strict: !1,
  }),
  s_ = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  po = {};
for (const t in s_)
  po[t] = {
    isEnabled: (e) => s_[t].some((n) => !!e[n]),
  };
function VR(t) {
  for (const e in t)
    po[e] = {
      ...po[e],
      ...t[e],
    };
}
const HR = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport",
]);
function Sd(t) {
  return (
    t.startsWith("while") ||
    (t.startsWith("drag") && t !== "draggable") ||
    t.startsWith("layout") ||
    t.startsWith("onTap") ||
    t.startsWith("onPan") ||
    t.startsWith("onLayout") ||
    HR.has(t)
  );
}
let YE = (t) => !Sd(t);
function GR(t) {
  t && (YE = (e) => (e.startsWith("on") ? !Sd(e) : t(e)));
}
try {
  GR(require("@emotion/is-prop-valid").default);
} catch {}
function WR(t, e, n) {
  const i = {};
  for (const r in t)
    (r === "values" && typeof t.values == "object") ||
      ((YE(r) ||
        (n === !0 && Sd(r)) ||
        (!e && !Sd(r)) ||
        (t.draggable && r.startsWith("onDrag"))) &&
        (i[r] = t[r]));
  return i;
}
function $R(t) {
  if (typeof Proxy > "u") return t;
  const e = new Map(),
    n = (...i) => t(...i);
  return new Proxy(n, {
    get: (i, r) =>
      r === "create" ? t : (e.has(r) || e.set(r, t(r)), e.get(r)),
  });
}
const ch = O.createContext({});
function ql(t) {
  return typeof t == "string" || Array.isArray(t);
}
function uh(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
const Gg = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  Wg = ["initial", ...Gg];
function dh(t) {
  return uh(t.animate) || Wg.some((e) => ql(t[e]));
}
function ZE(t) {
  return !!(dh(t) || t.variants);
}
function XR(t, e) {
  if (dh(t)) {
    const { initial: n, animate: i } = t;
    return {
      initial: n === !1 || ql(n) ? n : void 0,
      animate: ql(i) ? i : void 0,
    };
  }
  return t.inherit !== !1 ? e : {};
}
function qR(t) {
  const { initial: e, animate: n } = XR(t, O.useContext(ch));
  return O.useMemo(
    () => ({
      initial: e,
      animate: n,
    }),
    [a_(e), a_(n)]
  );
}
function a_(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const YR = Symbol.for("motionComponentSymbol");
function Va(t) {
  return (
    t &&
    typeof t == "object" &&
    Object.prototype.hasOwnProperty.call(t, "current")
  );
}
function ZR(t, e, n) {
  return O.useCallback(
    (i) => {
      i && t.onMount && t.onMount(i),
        e && (i ? e.mount(i) : e.unmount()),
        n && (typeof n == "function" ? n(i) : Va(n) && (n.current = i));
    },
    [e]
  );
}
const $g = (t) => t.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
  KR = "framerAppearId",
  KE = "data-" + $g(KR),
  { schedule: Xg, cancel: Wj } = XE(queueMicrotask, !1),
  JE = O.createContext({});
function JR(t, e, n, i, r) {
  var s, a;
  const { visualElement: o } = O.useContext(ch),
    l = O.useContext(qE),
    c = O.useContext(ah),
    u = O.useContext(oh).reducedMotion,
    d = O.useRef(null);
  (i = i || l.renderer),
    !d.current &&
      i &&
      (d.current = i(t, {
        visualState: e,
        parent: o,
        props: n,
        presenceContext: c,
        blockInitialAnimation: c ? c.initial === !1 : !1,
        reducedMotionConfig: u,
      }));
  const h = d.current,
    p = O.useContext(JE);
  h &&
    !h.projection &&
    r &&
    (h.type === "html" || h.type === "svg") &&
    QR(d.current, n, r, p);
  const v = O.useRef(!1);
  O.useInsertionEffect(() => {
    h && v.current && h.update(n, c);
  });
  const x = n[KE],
    m = O.useRef(
      !!x &&
        !(
          !((s = window.MotionHandoffIsComplete) === null || s === void 0) &&
          s.call(window, x)
        ) &&
        ((a = window.MotionHasOptimisedAnimation) === null || a === void 0
          ? void 0
          : a.call(window, x))
    );
  return (
    lh(() => {
      h &&
        ((v.current = !0),
        (window.MotionIsMounted = !0),
        h.updateFeatures(),
        Xg.render(h.render),
        m.current && h.animationState && h.animationState.animateChanges());
    }),
    O.useEffect(() => {
      h &&
        (!m.current && h.animationState && h.animationState.animateChanges(),
        m.current &&
          (queueMicrotask(() => {
            var f;
            (f = window.MotionHandoffMarkAsComplete) === null ||
              f === void 0 ||
              f.call(window, x);
          }),
          (m.current = !1)));
    }),
    h
  );
}
function QR(t, e, n, i) {
  const {
    layoutId: r,
    layout: s,
    drag: a,
    dragConstraints: o,
    layoutScroll: l,
    layoutRoot: c,
  } = e;
  (t.projection = new n(
    t.latestValues,
    e["data-framer-portal-id"] ? void 0 : QE(t.parent)
  )),
    t.projection.setOptions({
      layoutId: r,
      layout: s,
      alwaysMeasureLayout: !!a || (o && Va(o)),
      visualElement: t,
      animationType: typeof s == "string" ? s : "both",
      initialPromotionConfig: i,
      layoutScroll: l,
      layoutRoot: c,
    });
}
function QE(t) {
  if (t) return t.options.allowProjection !== !1 ? t.projection : QE(t.parent);
}
function eP({
  preloadedFeatures: t,
  createVisualElement: e,
  useRender: n,
  useVisualState: i,
  Component: r,
}) {
  var s, a;
  t && VR(t);
  function o(c, u) {
    let d;
    const h = {
        ...O.useContext(oh),
        ...c,
        layoutId: tP(c),
      },
      { isStatic: p } = h,
      v = qR(c),
      x = i(c, p);
    if (!p && Vg) {
      nP();
      const m = iP(h);
      (d = m.MeasureLayout),
        (v.visualElement = JR(r, x, h, e, m.ProjectionNode));
    }
    return _.jsxs(ch.Provider, {
      value: v,
      children: [
        d && v.visualElement
          ? _.jsx(d, {
              visualElement: v.visualElement,
              ...h,
            })
          : null,
        n(r, c, ZR(x, v.visualElement, u), x, p, v.visualElement),
      ],
    });
  }
  o.displayName = `motion.${
    typeof r == "string"
      ? r
      : `create(${
          (a = (s = r.displayName) !== null && s !== void 0 ? s : r.name) !==
            null && a !== void 0
            ? a
            : ""
        })`
  }`;
  const l = O.forwardRef(o);
  return (l[YR] = r), l;
}
function tP({ layoutId: t }) {
  const e = O.useContext(jg).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function nP(t, e) {
  O.useContext(qE).strict;
}
function iP(t) {
  const { drag: e, layout: n } = po;
  if (!e && !n) return {};
  const i = {
    ...e,
    ...n,
  };
  return {
    MeasureLayout:
      (e != null && e.isEnabled(t)) || (n != null && n.isEnabled(t))
        ? i.MeasureLayout
        : void 0,
    ProjectionNode: i.ProjectionNode,
  };
}
const rP = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function qg(t) {
  return typeof t != "string" || t.includes("-")
    ? !1
    : !!(rP.indexOf(t) > -1 || /[A-Z]/u.test(t));
}
function o_(t) {
  const e = [{}, {}];
  return (
    t == null ||
      t.values.forEach((n, i) => {
        (e[0][i] = n.get()), (e[1][i] = n.getVelocity());
      }),
    e
  );
}
function Yg(t, e, n, i) {
  if (typeof e == "function") {
    const [r, s] = o_(i);
    e = e(n !== void 0 ? n : t.custom, r, s);
  }
  if (
    (typeof e == "string" && (e = t.variants && t.variants[e]),
    typeof e == "function")
  ) {
    const [r, s] = o_(i);
    e = e(n !== void 0 ? n : t.custom, r, s);
  }
  return e;
}
const nm = (t) => Array.isArray(t),
  sP = (t) => !!(t && typeof t == "object" && t.mix && t.toValue),
  aP = (t) => (nm(t) ? t[t.length - 1] || 0 : t),
  dn = (t) => !!(t && t.getVelocity);
function Hu(t) {
  const e = dn(t) ? t.get() : t;
  return sP(e) ? e.toValue() : e;
}
function oP(
  { scrapeMotionValuesFromProps: t, createRenderState: e, onUpdate: n },
  i,
  r,
  s
) {
  const a = {
    latestValues: lP(i, r, s, t),
    renderState: e(),
  };
  return (
    n &&
      ((a.onMount = (o) =>
        n({
          props: i,
          current: o,
          ...a,
        })),
      (a.onUpdate = (o) => n(o))),
    a
  );
}
const e1 = (t) => (e, n) => {
  const i = O.useContext(ch),
    r = O.useContext(ah),
    s = () => oP(t, e, i, r);
  return n ? s() : Ro(s);
};
function lP(t, e, n, i) {
  const r = {},
    s = i(t, {});
  for (const h in s) r[h] = Hu(s[h]);
  let { initial: a, animate: o } = t;
  const l = dh(t),
    c = ZE(t);
  e &&
    c &&
    !l &&
    t.inherit !== !1 &&
    (a === void 0 && (a = e.initial), o === void 0 && (o = e.animate));
  let u = n ? n.initial === !1 : !1;
  u = u || a === !1;
  const d = u ? o : a;
  if (d && typeof d != "boolean" && !uh(d)) {
    const h = Array.isArray(d) ? d : [d];
    for (let p = 0; p < h.length; p++) {
      const v = Yg(t, h[p]);
      if (v) {
        const { transitionEnd: x, transition: m, ...f } = v;
        for (const y in f) {
          let g = f[y];
          if (Array.isArray(g)) {
            const S = u ? g.length - 1 : 0;
            g = g[S];
          }
          g !== null && (r[y] = g);
        }
        for (const y in x) r[y] = x[y];
      }
    }
  }
  return r;
}
const Po = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  aa = new Set(Po),
  t1 = (t) => (e) => typeof e == "string" && e.startsWith(t),
  n1 = t1("--"),
  cP = t1("var(--"),
  Zg = (t) => (cP(t) ? uP.test(t.split("/*")[0].trim()) : !1),
  uP =
    /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
  i1 = (t, e) => (e && typeof t == "number" ? e.transform(t) : t),
  ji = (t, e, n) => (n > e ? e : n < t ? t : n),
  Lo = {
    test: (t) => typeof t == "number",
    parse: parseFloat,
    transform: (t) => t,
  },
  Yl = {
    ...Lo,
    transform: (t) => ji(0, 1, t),
  },
  Qc = {
    ...Lo,
    default: 1,
  },
  xc = (t) => ({
    test: (e) =>
      typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${t}`,
  }),
  br = xc("deg"),
  Fi = xc("%"),
  Ae = xc("px"),
  dP = xc("vh"),
  hP = xc("vw"),
  l_ = {
    ...Fi,
    parse: (t) => Fi.parse(t) / 100,
    transform: (t) => Fi.transform(t * 100),
  },
  fP = {
    borderWidth: Ae,
    borderTopWidth: Ae,
    borderRightWidth: Ae,
    borderBottomWidth: Ae,
    borderLeftWidth: Ae,
    borderRadius: Ae,
    radius: Ae,
    borderTopLeftRadius: Ae,
    borderTopRightRadius: Ae,
    borderBottomRightRadius: Ae,
    borderBottomLeftRadius: Ae,
    width: Ae,
    maxWidth: Ae,
    height: Ae,
    maxHeight: Ae,
    top: Ae,
    right: Ae,
    bottom: Ae,
    left: Ae,
    padding: Ae,
    paddingTop: Ae,
    paddingRight: Ae,
    paddingBottom: Ae,
    paddingLeft: Ae,
    margin: Ae,
    marginTop: Ae,
    marginRight: Ae,
    marginBottom: Ae,
    marginLeft: Ae,
    backgroundPositionX: Ae,
    backgroundPositionY: Ae,
  },
  pP = {
    rotate: br,
    rotateX: br,
    rotateY: br,
    rotateZ: br,
    scale: Qc,
    scaleX: Qc,
    scaleY: Qc,
    scaleZ: Qc,
    skew: br,
    skewX: br,
    skewY: br,
    distance: Ae,
    translateX: Ae,
    translateY: Ae,
    translateZ: Ae,
    x: Ae,
    y: Ae,
    z: Ae,
    perspective: Ae,
    transformPerspective: Ae,
    opacity: Yl,
    originX: l_,
    originY: l_,
    originZ: Ae,
  },
  c_ = {
    ...Lo,
    transform: Math.round,
  },
  Kg = {
    ...fP,
    ...pP,
    zIndex: c_,
    size: Ae,
    fillOpacity: Yl,
    strokeOpacity: Yl,
    numOctaves: c_,
  },
  mP = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  gP = Po.length;
function vP(t, e, n) {
  let i = "",
    r = !0;
  for (let s = 0; s < gP; s++) {
    const a = Po[s],
      o = t[a];
    if (o === void 0) continue;
    let l = !0;
    if (
      (typeof o == "number"
        ? (l = o === (a.startsWith("scale") ? 1 : 0))
        : (l = parseFloat(o) === 0),
      !l || n)
    ) {
      const c = i1(o, Kg[a]);
      if (!l) {
        r = !1;
        const u = mP[a] || a;
        i += `${u}(${c}) `;
      }
      n && (e[a] = c);
    }
  }
  return (i = i.trim()), n ? (i = n(e, r ? "" : i)) : r && (i = "none"), i;
}
function Jg(t, e, n) {
  const { style: i, vars: r, transformOrigin: s } = t;
  let a = !1,
    o = !1;
  for (const l in e) {
    const c = e[l];
    if (aa.has(l)) {
      a = !0;
      continue;
    } else if (n1(l)) {
      r[l] = c;
      continue;
    } else {
      const u = i1(c, Kg[l]);
      l.startsWith("origin") ? ((o = !0), (s[l] = u)) : (i[l] = u);
    }
  }
  if (
    (e.transform ||
      (a || n
        ? (i.transform = vP(e, t.transform, n))
        : i.transform && (i.transform = "none")),
    o)
  ) {
    const { originX: l = "50%", originY: c = "50%", originZ: u = 0 } = s;
    i.transformOrigin = `${l} ${c} ${u}`;
  }
}
const _P = {
    offset: "stroke-dashoffset",
    array: "stroke-dasharray",
  },
  yP = {
    offset: "strokeDashoffset",
    array: "strokeDasharray",
  };
function xP(t, e, n = 1, i = 0, r = !0) {
  t.pathLength = 1;
  const s = r ? _P : yP;
  t[s.offset] = Ae.transform(-i);
  const a = Ae.transform(e),
    o = Ae.transform(n);
  t[s.array] = `${a} ${o}`;
}
function u_(t, e, n) {
  return typeof t == "string" ? t : Ae.transform(e + n * t);
}
function SP(t, e, n) {
  const i = u_(e, t.x, t.width),
    r = u_(n, t.y, t.height);
  return `${i} ${r}`;
}
function Qg(
  t,
  {
    attrX: e,
    attrY: n,
    attrScale: i,
    originX: r,
    originY: s,
    pathLength: a,
    pathSpacing: o = 1,
    pathOffset: l = 0,
    ...c
  },
  u,
  d
) {
  if ((Jg(t, c, d), u)) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  (t.attrs = t.style), (t.style = {});
  const { attrs: h, style: p, dimensions: v } = t;
  h.transform && (v && (p.transform = h.transform), delete h.transform),
    v &&
      (r !== void 0 || s !== void 0 || p.transform) &&
      (p.transformOrigin = SP(
        v,
        r !== void 0 ? r : 0.5,
        s !== void 0 ? s : 0.5
      )),
    e !== void 0 && (h.x = e),
    n !== void 0 && (h.y = n),
    i !== void 0 && (h.scale = i),
    a !== void 0 && xP(h, a, o, l, !1);
}
const ev = () => ({
    style: {},
    transform: {},
    transformOrigin: {},
    vars: {},
  }),
  r1 = () => ({
    ...ev(),
    attrs: {},
  }),
  tv = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function s1(t, { style: e, vars: n }, i, r) {
  Object.assign(t.style, e, r && r.getProjectionStyles(i));
  for (const s in n) t.style.setProperty(s, n[s]);
}
const a1 = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function o1(t, e, n, i) {
  s1(t, e, void 0, i);
  for (const r in e.attrs) t.setAttribute(a1.has(r) ? r : $g(r), e.attrs[r]);
}
const wd = {};
function wP(t) {
  Object.assign(wd, t);
}
function l1(t, { layout: e, layoutId: n }) {
  return (
    aa.has(t) ||
    t.startsWith("origin") ||
    ((e || n !== void 0) && (!!wd[t] || t === "opacity"))
  );
}
function nv(t, e, n) {
  var i;
  const { style: r } = t,
    s = {};
  for (const a in r)
    (dn(r[a]) ||
      (e.style && dn(e.style[a])) ||
      l1(a, t) ||
      ((i = n == null ? void 0 : n.getValue(a)) === null || i === void 0
        ? void 0
        : i.liveStyle) !== void 0) &&
      (s[a] = r[a]);
  return s;
}
function c1(t, e, n) {
  const i = nv(t, e, n);
  for (const r in t)
    if (dn(t[r]) || dn(e[r])) {
      const s =
        Po.indexOf(r) !== -1
          ? "attr" + r.charAt(0).toUpperCase() + r.substring(1)
          : r;
      i[s] = t[r];
    }
  return i;
}
function EP(t, e) {
  try {
    e.dimensions =
      typeof t.getBBox == "function" ? t.getBBox() : t.getBoundingClientRect();
  } catch {
    e.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
    };
  }
}
const d_ = ["x", "y", "width", "height", "cx", "cy", "r"],
  TP = {
    useVisualState: e1({
      scrapeMotionValuesFromProps: c1,
      createRenderState: r1,
      onUpdate: ({
        props: t,
        prevProps: e,
        current: n,
        renderState: i,
        latestValues: r,
      }) => {
        if (!n) return;
        let s = !!t.drag;
        if (!s) {
          for (const o in r)
            if (aa.has(o)) {
              s = !0;
              break;
            }
        }
        if (!s) return;
        let a = !e;
        if (e)
          for (let o = 0; o < d_.length; o++) {
            const l = d_[o];
            t[l] !== e[l] && (a = !0);
          }
        a &&
          at.read(() => {
            EP(n, i),
              at.render(() => {
                Qg(i, r, tv(n.tagName), t.transformTemplate), o1(n, i);
              });
          });
      },
    }),
  },
  MP = {
    useVisualState: e1({
      scrapeMotionValuesFromProps: nv,
      createRenderState: ev,
    }),
  };
function u1(t, e, n) {
  for (const i in e) !dn(e[i]) && !l1(i, n) && (t[i] = e[i]);
}
function bP({ transformTemplate: t }, e) {
  return O.useMemo(() => {
    const n = ev();
    return Jg(n, e, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function AP(t, e) {
  const n = t.style || {},
    i = {};
  return u1(i, n, t), Object.assign(i, bP(t, e)), i;
}
function CP(t, e) {
  const n = {},
    i = AP(t, e);
  return (
    t.drag &&
      t.dragListener !== !1 &&
      ((n.draggable = !1),
      (i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none"),
      (i.touchAction =
        t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`)),
    t.tabIndex === void 0 &&
      (t.onTap || t.onTapStart || t.whileTap) &&
      (n.tabIndex = 0),
    (n.style = i),
    n
  );
}
function RP(t, e, n, i) {
  const r = O.useMemo(() => {
    const s = r1();
    return (
      Qg(s, e, tv(i), t.transformTemplate),
      {
        ...s.attrs,
        style: {
          ...s.style,
        },
      }
    );
  }, [e]);
  if (t.style) {
    const s = {};
    u1(s, t.style, t),
      (r.style = {
        ...s,
        ...r.style,
      });
  }
  return r;
}
function PP(t = !1) {
  return (n, i, r, { latestValues: s }, a) => {
    const l = (qg(n) ? RP : CP)(i, s, a, n),
      c = WR(i, typeof n == "string", t),
      u =
        n !== O.Fragment
          ? {
              ...c,
              ...l,
              ref: r,
            }
          : {},
      { children: d } = i,
      h = O.useMemo(() => (dn(d) ? d.get() : d), [d]);
    return O.createElement(n, {
      ...u,
      children: h,
    });
  };
}
function LP(t, e) {
  return function (
    i,
    { forwardMotionProps: r } = {
      forwardMotionProps: !1,
    }
  ) {
    const a = {
      ...(qg(i) ? TP : MP),
      preloadedFeatures: t,
      useRender: PP(r),
      createVisualElement: e,
      Component: i,
    };
    return eP(a);
  };
}
function d1(t, e) {
  if (!Array.isArray(e)) return !1;
  const n = e.length;
  if (n !== t.length) return !1;
  for (let i = 0; i < n; i++) if (e[i] !== t[i]) return !1;
  return !0;
}
function hh(t, e, n) {
  const i = t.getProps();
  return Yg(i, e, n !== void 0 ? n : i.custom, t);
}
const h1 = Hg(() => window.ScrollTimeline !== void 0);
class NP {
  constructor(e) {
    (this.stop = () => this.runAll("stop")),
      (this.animations = e.filter(Boolean));
  }
  get finished() {
    return Promise.all(
      this.animations.map((e) => ("finished" in e ? e.finished : e))
    );
  }
  getAll(e) {
    return this.animations[0][e];
  }
  setAll(e, n) {
    for (let i = 0; i < this.animations.length; i++) this.animations[i][e] = n;
  }
  attachTimeline(e, n) {
    const i = this.animations.map((r) => {
      if (h1() && r.attachTimeline) return r.attachTimeline(e);
      if (typeof n == "function") return n(r);
    });
    return () => {
      i.forEach((r, s) => {
        r && r(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(e) {
    this.setAll("time", e);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(e) {
    this.setAll("speed", e);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let e = 0;
    for (let n = 0; n < this.animations.length; n++)
      e = Math.max(e, this.animations[n].duration);
    return e;
  }
  runAll(e) {
    this.animations.forEach((n) => n[e]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class DP extends NP {
  then(e, n) {
    return Promise.all(this.animations).then(e).catch(n);
  }
}
function iv(t, e) {
  return t ? t[e] || t.default || t : void 0;
}
const im = 2e4;
function f1(t) {
  let e = 0;
  const n = 50;
  let i = t.next(e);
  for (; !i.done && e < im; ) (e += n), (i = t.next(e));
  return e >= im ? 1 / 0 : e;
}
function rv(t) {
  return typeof t == "function";
}
function h_(t, e) {
  (t.timeline = e), (t.onfinish = null);
}
const sv = (t) => Array.isArray(t) && typeof t[0] == "number",
  kP = {
    linearEasing: void 0,
  };
function IP(t, e) {
  const n = Hg(t);
  return () => {
    var i;
    return (i = kP[e]) !== null && i !== void 0 ? i : n();
  };
}
const Ed = IP(() => {
    try {
      document.createElement("div").animate(
        {
          opacity: 0,
        },
        {
          easing: "linear(0, 1)",
        }
      );
    } catch {
      return !1;
    }
    return !0;
  }, "linearEasing"),
  p1 = (t, e, n = 10) => {
    let i = "";
    const r = Math.max(Math.round(e / n), 2);
    for (let s = 0; s < r; s++) i += t(Ks(0, r - 1, s)) + ", ";
    return `linear(${i.substring(0, i.length - 2)})`;
  };
function m1(t) {
  return !!(
    (typeof t == "function" && Ed()) ||
    !t ||
    (typeof t == "string" && (t in rm || Ed())) ||
    sv(t) ||
    (Array.isArray(t) && t.every(m1))
  );
}
const sl = ([t, e, n, i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`,
  rm = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: sl([0, 0.65, 0.55, 1]),
    circOut: sl([0.55, 0, 1, 0.45]),
    backIn: sl([0.31, 0.01, 0.66, -0.59]),
    backOut: sl([0.33, 1.53, 0.69, 0.99]),
  };
function g1(t, e) {
  if (t)
    return typeof t == "function" && Ed()
      ? p1(t, e)
      : sv(t)
      ? sl(t)
      : Array.isArray(t)
      ? t.map((n) => g1(n, e) || rm.easeOut)
      : rm[t];
}
const hi = {
  x: !1,
  y: !1,
};
function v1() {
  return hi.x || hi.y;
}
function _1(t, e, n) {
  var i;
  if (t instanceof Element) return [t];
  if (typeof t == "string") {
    let r = document;
    const s = (i = void 0) !== null && i !== void 0 ? i : r.querySelectorAll(t);
    return s ? Array.from(s) : [];
  }
  return Array.from(t);
}
function y1(t, e) {
  const n = _1(t),
    i = new AbortController(),
    r = {
      passive: !0,
      ...e,
      signal: i.signal,
    };
  return [n, r, () => i.abort()];
}
function f_(t) {
  return (e) => {
    e.pointerType === "touch" || v1() || t(e);
  };
}
function UP(t, e, n = {}) {
  const [i, r, s] = y1(t, n),
    a = f_((o) => {
      const { target: l } = o,
        c = e(o);
      if (typeof c != "function" || !l) return;
      const u = f_((d) => {
        c(d), l.removeEventListener("pointerleave", u);
      });
      l.addEventListener("pointerleave", u, r);
    });
  return (
    i.forEach((o) => {
      o.addEventListener("pointerenter", a, r);
    }),
    s
  );
}
const x1 = (t, e) => (e ? (t === e ? !0 : x1(t, e.parentElement)) : !1),
  av = (t) =>
    t.pointerType === "mouse"
      ? typeof t.button != "number" || t.button <= 0
      : t.isPrimary !== !1,
  OP = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);
function FP(t) {
  return OP.has(t.tagName) || t.tabIndex !== -1;
}
const al = new WeakSet();
function p_(t) {
  return (e) => {
    e.key === "Enter" && t(e);
  };
}
function af(t, e) {
  t.dispatchEvent(
    new PointerEvent("pointer" + e, {
      isPrimary: !0,
      bubbles: !0,
    })
  );
}
const BP = (t, e) => {
  const n = t.currentTarget;
  if (!n) return;
  const i = p_(() => {
    if (al.has(n)) return;
    af(n, "down");
    const r = p_(() => {
        af(n, "up");
      }),
      s = () => af(n, "cancel");
    n.addEventListener("keyup", r, e), n.addEventListener("blur", s, e);
  });
  n.addEventListener("keydown", i, e),
    n.addEventListener("blur", () => n.removeEventListener("keydown", i), e);
};
function m_(t) {
  return av(t) && !v1();
}
function zP(t, e, n = {}) {
  const [i, r, s] = y1(t, n),
    a = (o) => {
      const l = o.currentTarget;
      if (!m_(o) || al.has(l)) return;
      al.add(l);
      const c = e(o),
        u = (p, v) => {
          window.removeEventListener("pointerup", d),
            window.removeEventListener("pointercancel", h),
            !(!m_(p) || !al.has(l)) &&
              (al.delete(l),
              typeof c == "function" &&
                c(p, {
                  success: v,
                }));
        },
        d = (p) => {
          u(p, n.useGlobalTarget || x1(l, p.target));
        },
        h = (p) => {
          u(p, !1);
        };
      window.addEventListener("pointerup", d, r),
        window.addEventListener("pointercancel", h, r);
    };
  return (
    i.forEach((o) => {
      !FP(o) && o.getAttribute("tabindex") === null && (o.tabIndex = 0),
        (n.useGlobalTarget ? window : o).addEventListener("pointerdown", a, r),
        o.addEventListener("focus", (c) => BP(c, r), r);
    }),
    s
  );
}
function jP(t) {
  return t === "x" || t === "y"
    ? hi[t]
      ? null
      : ((hi[t] = !0),
        () => {
          hi[t] = !1;
        })
    : hi.x || hi.y
    ? null
    : ((hi.x = hi.y = !0),
      () => {
        hi.x = hi.y = !1;
      });
}
const S1 = new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Po,
]);
let Gu;
function VP() {
  Gu = void 0;
}
const Bi = {
  now: () => (
    Gu === void 0 &&
      Bi.set(
        Xt.isProcessing || BR.useManualTiming ? Xt.timestamp : performance.now()
      ),
    Gu
  ),
  set: (t) => {
    (Gu = t), queueMicrotask(VP);
  },
};
function ov(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function lv(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
class cv {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return ov(this.subscriptions, e), () => lv(this.subscriptions, e);
  }
  notify(e, n, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, n, i);
      else
        for (let s = 0; s < r; s++) {
          const a = this.subscriptions[s];
          a && a(e, n, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function uv(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const g_ = 30,
  HP = (t) => !isNaN(parseFloat(t)),
  xl = {
    current: void 0,
  };
class GP {
  constructor(e, n = {}) {
    (this.version = "11.18.2"),
      (this.canTrackVelocity = null),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        const s = Bi.now();
        this.updatedAt !== s && this.setPrevFrameValue(),
          (this.prev = this.current),
          this.setCurrent(i),
          this.current !== this.prev &&
            this.events.change &&
            this.events.change.notify(this.current),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.hasAnimated = !1),
      this.setCurrent(e),
      (this.owner = n.owner);
  }
  setCurrent(e) {
    (this.current = e),
      (this.updatedAt = Bi.now()),
      this.canTrackVelocity === null &&
        e !== void 0 &&
        (this.canTrackVelocity = HP(this.current));
  }
  setPrevFrameValue(e = this.current) {
    (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new cv());
    const i = this.events[e].add(n);
    return e === "change"
      ? () => {
          i(),
            at.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, n) {
    (this.passiveEffect = e), (this.stopPassiveEffect = n);
  }
  set(e, n = !0) {
    !n || !this.passiveEffect
      ? this.updateAndNotify(e, n)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, n, i) {
    this.set(n),
      (this.prev = void 0),
      (this.prevFrameValue = e),
      (this.prevUpdatedAt = this.updatedAt - i);
  }
  jump(e, n = !0) {
    this.updateAndNotify(e),
      (this.prev = e),
      (this.prevUpdatedAt = this.prevFrameValue = void 0),
      n && this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return xl.current && xl.current.push(this), this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    const e = Bi.now();
    if (
      !this.canTrackVelocity ||
      this.prevFrameValue === void 0 ||
      e - this.updatedAt > g_
    )
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, g_);
    return uv(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  start(e) {
    return (
      this.stop(),
      new Promise((n) => {
        (this.hasAnimated = !0),
          (this.animation = e(n)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Ii(t, e) {
  return new GP(t, e);
}
function WP(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Ii(n));
}
function $P(t, e) {
  const n = hh(t, e);
  let { transitionEnd: i = {}, transition: r = {}, ...s } = n || {};
  s = {
    ...s,
    ...i,
  };
  for (const a in s) {
    const o = aP(s[a]);
    WP(t, a, o);
  }
}
function XP(t) {
  return !!(dn(t) && t.add);
}
function sm(t, e) {
  const n = t.getValue("willChange");
  if (XP(n)) return n.add(e);
}
function w1(t) {
  return t.props[KE];
}
const E1 = (t, e, n) =>
    (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t,
  qP = 1e-7,
  YP = 12;
function ZP(t, e, n, i, r) {
  let s,
    a,
    o = 0;
  do (a = e + (n - e) / 2), (s = E1(a, i, r) - t), s > 0 ? (n = a) : (e = a);
  while (Math.abs(s) > qP && ++o < YP);
  return a;
}
function Sc(t, e, n, i) {
  if (t === e && n === i) return yn;
  const r = (s) => ZP(s, 0, 1, t, n);
  return (s) => (s === 0 || s === 1 ? s : E1(r(s), e, i));
}
const T1 = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2,
  M1 = (t) => (e) => 1 - t(1 - e),
  b1 = Sc(0.33, 1.53, 0.69, 0.99),
  dv = M1(b1),
  A1 = T1(dv),
  C1 = (t) =>
    (t *= 2) < 1 ? 0.5 * dv(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))),
  hv = (t) => 1 - Math.sin(Math.acos(t)),
  R1 = M1(hv),
  P1 = T1(hv),
  L1 = (t) => /^0[^.\s]+$/u.test(t);
function KP(t) {
  return typeof t == "number"
    ? t === 0
    : t !== null
    ? t === "none" || t === "0" || L1(t)
    : !0;
}
const Sl = (t) => Math.round(t * 1e5) / 1e5,
  fv = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function JP(t) {
  return t == null;
}
const QP =
    /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
  pv = (t, e) => (n) =>
    !!(
      (typeof n == "string" && QP.test(n) && n.startsWith(t)) ||
      (e && !JP(n) && Object.prototype.hasOwnProperty.call(n, e))
    ),
  N1 = (t, e, n) => (i) => {
    if (typeof i != "string") return i;
    const [r, s, a, o] = i.match(fv);
    return {
      [t]: parseFloat(r),
      [e]: parseFloat(s),
      [n]: parseFloat(a),
      alpha: o !== void 0 ? parseFloat(o) : 1,
    };
  },
  e2 = (t) => ji(0, 255, t),
  of = {
    ...Lo,
    transform: (t) => Math.round(e2(t)),
  },
  Os = {
    test: pv("rgb", "red"),
    parse: N1("red", "green", "blue"),
    transform: ({ red: t, green: e, blue: n, alpha: i = 1 }) =>
      "rgba(" +
      of.transform(t) +
      ", " +
      of.transform(e) +
      ", " +
      of.transform(n) +
      ", " +
      Sl(Yl.transform(i)) +
      ")",
  };
function t2(t) {
  let e = "",
    n = "",
    i = "",
    r = "";
  return (
    t.length > 5
      ? ((e = t.substring(1, 3)),
        (n = t.substring(3, 5)),
        (i = t.substring(5, 7)),
        (r = t.substring(7, 9)))
      : ((e = t.substring(1, 2)),
        (n = t.substring(2, 3)),
        (i = t.substring(3, 4)),
        (r = t.substring(4, 5)),
        (e += e),
        (n += n),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(n, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const am = {
    test: pv("#"),
    parse: t2,
    transform: Os.transform,
  },
  Ha = {
    test: pv("hsl", "hue"),
    parse: N1("hue", "saturation", "lightness"),
    transform: ({ hue: t, saturation: e, lightness: n, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(t) +
      ", " +
      Fi.transform(Sl(e)) +
      ", " +
      Fi.transform(Sl(n)) +
      ", " +
      Sl(Yl.transform(i)) +
      ")",
  },
  cn = {
    test: (t) => Os.test(t) || am.test(t) || Ha.test(t),
    parse: (t) =>
      Os.test(t) ? Os.parse(t) : Ha.test(t) ? Ha.parse(t) : am.parse(t),
    transform: (t) =>
      typeof t == "string"
        ? t
        : t.hasOwnProperty("red")
        ? Os.transform(t)
        : Ha.transform(t),
  },
  n2 =
    /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function i2(t) {
  var e, n;
  return (
    isNaN(t) &&
    typeof t == "string" &&
    (((e = t.match(fv)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((n = t.match(n2)) === null || n === void 0 ? void 0 : n.length) || 0) >
      0
  );
}
const D1 = "number",
  k1 = "color",
  r2 = "var",
  s2 = "var(",
  v_ = "${}",
  a2 =
    /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function Zl(t) {
  const e = t.toString(),
    n = [],
    i = {
      color: [],
      number: [],
      var: [],
    },
    r = [];
  let s = 0;
  const o = e
    .replace(
      a2,
      (l) => (
        cn.test(l)
          ? (i.color.push(s), r.push(k1), n.push(cn.parse(l)))
          : l.startsWith(s2)
          ? (i.var.push(s), r.push(r2), n.push(l))
          : (i.number.push(s), r.push(D1), n.push(parseFloat(l))),
        ++s,
        v_
      )
    )
    .split(v_);
  return {
    values: n,
    split: o,
    indexes: i,
    types: r,
  };
}
function I1(t) {
  return Zl(t).values;
}
function U1(t) {
  const { split: e, types: n } = Zl(t),
    i = e.length;
  return (r) => {
    let s = "";
    for (let a = 0; a < i; a++)
      if (((s += e[a]), r[a] !== void 0)) {
        const o = n[a];
        o === D1
          ? (s += Sl(r[a]))
          : o === k1
          ? (s += cn.transform(r[a]))
          : (s += r[a]);
      }
    return s;
  };
}
const o2 = (t) => (typeof t == "number" ? 0 : t);
function l2(t) {
  const e = I1(t);
  return U1(t)(e.map(o2));
}
const ts = {
    test: i2,
    parse: I1,
    createTransformer: U1,
    getAnimatableNone: l2,
  },
  c2 = new Set(["brightness", "contrast", "saturate", "opacity"]);
function u2(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow") return t;
  const [i] = n.match(fv) || [];
  if (!i) return t;
  const r = n.replace(i, "");
  let s = c2.has(e) ? 1 : 0;
  return i !== n && (s *= 100), e + "(" + s + r + ")";
}
const d2 = /\b([a-z-]*)\(.*?\)/gu,
  om = {
    ...ts,
    getAnimatableNone: (t) => {
      const e = t.match(d2);
      return e ? e.map(u2).join(" ") : t;
    },
  },
  h2 = {
    ...Kg,
    color: cn,
    backgroundColor: cn,
    outlineColor: cn,
    fill: cn,
    stroke: cn,
    borderColor: cn,
    borderTopColor: cn,
    borderRightColor: cn,
    borderBottomColor: cn,
    borderLeftColor: cn,
    filter: om,
    WebkitFilter: om,
  },
  mv = (t) => h2[t];
function O1(t, e) {
  let n = mv(t);
  return (
    n !== om && (n = ts), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0
  );
}
const f2 = new Set(["auto", "none", "0"]);
function p2(t, e, n) {
  let i = 0,
    r;
  for (; i < t.length && !r; ) {
    const s = t[i];
    typeof s == "string" && !f2.has(s) && Zl(s).values.length && (r = t[i]),
      i++;
  }
  if (r && n) for (const s of e) t[s] = O1(n, r);
}
const __ = (t) => t === Lo || t === Ae,
  y_ = (t, e) => parseFloat(t.split(", ")[e]),
  x_ =
    (t, e) =>
    (n, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/u);
      if (r) return y_(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/u);
        return s ? y_(s[1], t) : 0;
      }
    },
  m2 = new Set(["x", "y", "z"]),
  g2 = Po.filter((t) => !m2.has(t));
function v2(t) {
  const e = [];
  return (
    g2.forEach((n) => {
      const i = t.getValue(n);
      i !== void 0 &&
        (e.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0));
    }),
    e
  );
}
const mo = {
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) =>
    t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) =>
    t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  x: x_(4, 13),
  y: x_(5, 14),
};
mo.translateX = mo.x;
mo.translateY = mo.y;
const js = new Set();
let lm = !1,
  cm = !1;
function F1() {
  if (cm) {
    const t = Array.from(js).filter((i) => i.needsMeasurement),
      e = new Set(t.map((i) => i.element)),
      n = new Map();
    e.forEach((i) => {
      const r = v2(i);
      r.length && (n.set(i, r), i.render());
    }),
      t.forEach((i) => i.measureInitialState()),
      e.forEach((i) => {
        i.render();
        const r = n.get(i);
        r &&
          r.forEach(([s, a]) => {
            var o;
            (o = i.getValue(s)) === null || o === void 0 || o.set(a);
          });
      }),
      t.forEach((i) => i.measureEndState()),
      t.forEach((i) => {
        i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY);
      });
  }
  (cm = !1), (lm = !1), js.forEach((t) => t.complete()), js.clear();
}
function B1() {
  js.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (cm = !0);
  });
}
function _2() {
  B1(), F1();
}
class gv {
  constructor(e, n, i, r, s, a = !1) {
    (this.isComplete = !1),
      (this.isAsync = !1),
      (this.needsMeasurement = !1),
      (this.isScheduled = !1),
      (this.unresolvedKeyframes = [...e]),
      (this.onComplete = n),
      (this.name = i),
      (this.motionValue = r),
      (this.element = s),
      (this.isAsync = a);
  }
  scheduleResolve() {
    (this.isScheduled = !0),
      this.isAsync
        ? (js.add(this),
          lm || ((lm = !0), at.read(B1), at.resolveKeyframes(F1)))
        : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const {
      unresolvedKeyframes: e,
      name: n,
      element: i,
      motionValue: r,
    } = this;
    for (let s = 0; s < e.length; s++)
      if (e[s] === null)
        if (s === 0) {
          const a = r == null ? void 0 : r.get(),
            o = e[e.length - 1];
          if (a !== void 0) e[0] = a;
          else if (i && n) {
            const l = i.readValue(n, o);
            l != null && (e[0] = l);
          }
          e[0] === void 0 && (e[0] = o), r && a === void 0 && r.set(e[0]);
        } else e[s] = e[s - 1];
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    (this.isComplete = !0),
      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe),
      js.delete(this);
  }
  cancel() {
    this.isComplete || ((this.isScheduled = !1), js.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const z1 = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t),
  y2 = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function x2(t) {
  const e = y2.exec(t);
  if (!e) return [,];
  const [, n, i, r] = e;
  return [`--${n ?? i}`, r];
}
function j1(t, e, n = 1) {
  const [i, r] = x2(t);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  if (s) {
    const a = s.trim();
    return z1(a) ? parseFloat(a) : a;
  }
  return Zg(r) ? j1(r, e, n + 1) : r;
}
const V1 = (t) => (e) => e.test(t),
  S2 = {
    test: (t) => t === "auto",
    parse: (t) => t,
  },
  H1 = [Lo, Ae, Fi, br, hP, dP, S2],
  S_ = (t) => H1.find(V1(t));
class G1 extends gv {
  constructor(e, n, i, r, s) {
    super(e, n, i, r, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: i } = this;
    if (!n || !n.current) return;
    super.readKeyframes();
    for (let l = 0; l < e.length; l++) {
      let c = e[l];
      if (typeof c == "string" && ((c = c.trim()), Zg(c))) {
        const u = j1(c, n.current);
        u !== void 0 && (e[l] = u),
          l === e.length - 1 && (this.finalKeyframe = c);
      }
    }
    if ((this.resolveNoneKeyframes(), !S1.has(i) || e.length !== 2)) return;
    const [r, s] = e,
      a = S_(r),
      o = S_(s);
    if (a !== o)
      if (__(a) && __(o))
        for (let l = 0; l < e.length; l++) {
          const c = e[l];
          typeof c == "string" && (e[l] = parseFloat(c));
        }
      else this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this,
      i = [];
    for (let r = 0; r < e.length; r++) KP(e[r]) && i.push(r);
    i.length && p2(e, i, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: i } = this;
    if (!e || !e.current) return;
    i === "height" && (this.suspendedScrollY = window.pageYOffset),
      (this.measuredOrigin = mo[i](
        e.measureViewportBox(),
        window.getComputedStyle(e.current)
      )),
      (n[0] = this.measuredOrigin);
    const r = n[n.length - 1];
    r !== void 0 && e.getValue(i, r).jump(r, !1);
  }
  measureEndState() {
    var e;
    const { element: n, name: i, unresolvedKeyframes: r } = this;
    if (!n || !n.current) return;
    const s = n.getValue(i);
    s && s.jump(this.measuredOrigin, !1);
    const a = r.length - 1,
      o = r[a];
    (r[a] = mo[i](n.measureViewportBox(), window.getComputedStyle(n.current))),
      o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o),
      !((e = this.removedTransforms) === null || e === void 0) &&
        e.length &&
        this.removedTransforms.forEach(([l, c]) => {
          n.getValue(l).set(c);
        }),
      this.resolveNoneKeyframes();
  }
}
const w_ = (t, e) =>
  e === "zIndex"
    ? !1
    : !!(
        typeof t == "number" ||
        Array.isArray(t) ||
        (typeof t == "string" &&
          (ts.test(t) || t === "0") &&
          !t.startsWith("url("))
      );
function w2(t) {
  const e = t[0];
  if (t.length === 1) return !0;
  for (let n = 0; n < t.length; n++) if (t[n] !== e) return !0;
}
function E2(t, e, n, i) {
  const r = t[0];
  if (r === null) return !1;
  if (e === "display" || e === "visibility") return !0;
  const s = t[t.length - 1],
    a = w_(r, e),
    o = w_(s, e);
  return !a || !o ? !1 : w2(t) || ((n === "spring" || rv(n)) && i);
}
const T2 = (t) => t !== null;
function fh(t, { repeat: e, repeatType: n = "loop" }, i) {
  const r = t.filter(T2),
    s = e && n !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
  return !s || i === void 0 ? r[s] : i;
}
const M2 = 40;
class W1 {
  constructor({
    autoplay: e = !0,
    delay: n = 0,
    type: i = "keyframes",
    repeat: r = 0,
    repeatDelay: s = 0,
    repeatType: a = "loop",
    ...o
  }) {
    (this.isStopped = !1),
      (this.hasAttemptedResolve = !1),
      (this.createdAt = Bi.now()),
      (this.options = {
        autoplay: e,
        delay: n,
        type: i,
        repeat: r,
        repeatDelay: s,
        repeatType: a,
        ...o,
      }),
      this.updateFinishedPromise();
  }
  calcStartTime() {
    return this.resolvedAt
      ? this.resolvedAt - this.createdAt > M2
        ? this.resolvedAt
        : this.createdAt
      : this.createdAt;
  }
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && _2(), this._resolved;
  }
  onKeyframesResolved(e, n) {
    (this.resolvedAt = Bi.now()), (this.hasAttemptedResolve = !0);
    const {
      name: i,
      type: r,
      velocity: s,
      delay: a,
      onComplete: o,
      onUpdate: l,
      isGenerator: c,
    } = this.options;
    if (!c && !E2(e, i, r, s))
      if (a) this.options.duration = 0;
      else {
        l && l(fh(e, this.options, n)), o && o(), this.resolveFinishedPromise();
        return;
      }
    const u = this.initPlayback(e, n);
    u !== !1 &&
      ((this._resolved = {
        keyframes: e,
        finalKeyframe: n,
        ...u,
      }),
      this.onPostResolved());
  }
  onPostResolved() {}
  then(e, n) {
    return this.currentFinishedPromise.then(e, n);
  }
  flatten() {
    (this.options.type = "keyframes"), (this.options.ease = "linear");
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((e) => {
      this.resolveFinishedPromise = e;
    });
  }
}
const Mt = (t, e, n) => t + (e - t) * n;
function lf(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * (2 / 3 - n) * 6
      : t
  );
}
function b2({ hue: t, saturation: e, lightness: n, alpha: i }) {
  (t /= 360), (e /= 100), (n /= 100);
  let r = 0,
    s = 0,
    a = 0;
  if (!e) r = s = a = n;
  else {
    const o = n < 0.5 ? n * (1 + e) : n + e - n * e,
      l = 2 * n - o;
    (r = lf(l, o, t + 1 / 3)), (s = lf(l, o, t)), (a = lf(l, o, t - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(a * 255),
    alpha: i,
  };
}
function Td(t, e) {
  return (n) => (n > 0 ? e : t);
}
const cf = (t, e, n) => {
    const i = t * t,
      r = n * (e * e - i) + i;
    return r < 0 ? 0 : Math.sqrt(r);
  },
  A2 = [am, Os, Ha],
  C2 = (t) => A2.find((e) => e.test(t));
function E_(t) {
  const e = C2(t);
  if (!e) return !1;
  let n = e.parse(t);
  return e === Ha && (n = b2(n)), n;
}
const T_ = (t, e) => {
    const n = E_(t),
      i = E_(e);
    if (!n || !i) return Td(t, e);
    const r = {
      ...n,
    };
    return (s) => (
      (r.red = cf(n.red, i.red, s)),
      (r.green = cf(n.green, i.green, s)),
      (r.blue = cf(n.blue, i.blue, s)),
      (r.alpha = Mt(n.alpha, i.alpha, s)),
      Os.transform(r)
    );
  },
  R2 = (t, e) => (n) => e(t(n)),
  wc = (...t) => t.reduce(R2),
  um = new Set(["none", "hidden"]);
function P2(t, e) {
  return um.has(t) ? (n) => (n <= 0 ? t : e) : (n) => (n >= 1 ? e : t);
}
function L2(t, e) {
  return (n) => Mt(t, e, n);
}
function vv(t) {
  return typeof t == "number"
    ? L2
    : typeof t == "string"
    ? Zg(t)
      ? Td
      : cn.test(t)
      ? T_
      : k2
    : Array.isArray(t)
    ? $1
    : typeof t == "object"
    ? cn.test(t)
      ? T_
      : N2
    : Td;
}
function $1(t, e) {
  const n = [...t],
    i = n.length,
    r = t.map((s, a) => vv(s)(s, e[a]));
  return (s) => {
    for (let a = 0; a < i; a++) n[a] = r[a](s);
    return n;
  };
}
function N2(t, e) {
  const n = {
      ...t,
      ...e,
    },
    i = {};
  for (const r in n)
    t[r] !== void 0 && e[r] !== void 0 && (i[r] = vv(t[r])(t[r], e[r]));
  return (r) => {
    for (const s in i) n[s] = i[s](r);
    return n;
  };
}
function D2(t, e) {
  var n;
  const i = [],
    r = {
      color: 0,
      var: 0,
      number: 0,
    };
  for (let s = 0; s < e.values.length; s++) {
    const a = e.types[s],
      o = t.indexes[a][r[a]],
      l = (n = t.values[o]) !== null && n !== void 0 ? n : 0;
    (i[s] = l), r[a]++;
  }
  return i;
}
const k2 = (t, e) => {
  const n = ts.createTransformer(e),
    i = Zl(t),
    r = Zl(e);
  return i.indexes.var.length === r.indexes.var.length &&
    i.indexes.color.length === r.indexes.color.length &&
    i.indexes.number.length >= r.indexes.number.length
    ? (um.has(t) && !r.values.length) || (um.has(e) && !i.values.length)
      ? P2(t, e)
      : wc($1(D2(i, r), r.values), n)
    : Td(t, e);
};
function X1(t, e, n) {
  return typeof t == "number" && typeof e == "number" && typeof n == "number"
    ? Mt(t, e, n)
    : vv(t)(t, e);
}
const I2 = 5;
function q1(t, e, n) {
  const i = Math.max(e - I2, 0);
  return uv(n - t(i), e - i);
}
const Ct = {
    stiffness: 100,
    damping: 10,
    mass: 1,
    velocity: 0,
    duration: 800,
    bounce: 0.3,
    visualDuration: 0.3,
    restSpeed: {
      granular: 0.01,
      default: 2,
    },
    restDelta: {
      granular: 0.005,
      default: 0.5,
    },
    minDuration: 0.01,
    maxDuration: 10,
    minDamping: 0.05,
    maxDamping: 1,
  },
  uf = 0.001;
function U2({
  duration: t = Ct.duration,
  bounce: e = Ct.bounce,
  velocity: n = Ct.velocity,
  mass: i = Ct.mass,
}) {
  let r,
    s,
    a = 1 - e;
  (a = ji(Ct.minDamping, Ct.maxDamping, a)),
    (t = ji(Ct.minDuration, Ct.maxDuration, ur(t))),
    a < 1
      ? ((r = (c) => {
          const u = c * a,
            d = u * t,
            h = u - n,
            p = dm(c, a),
            v = Math.exp(-d);
          return uf - (h / p) * v;
        }),
        (s = (c) => {
          const d = c * a * t,
            h = d * n + n,
            p = Math.pow(a, 2) * Math.pow(c, 2) * t,
            v = Math.exp(-d),
            x = dm(Math.pow(c, 2), a);
          return ((-r(c) + uf > 0 ? -1 : 1) * ((h - p) * v)) / x;
        }))
      : ((r = (c) => {
          const u = Math.exp(-c * t),
            d = (c - n) * t + 1;
          return -uf + u * d;
        }),
        (s = (c) => {
          const u = Math.exp(-c * t),
            d = (n - c) * (t * t);
          return u * d;
        }));
  const o = 5 / t,
    l = F2(r, s, o);
  if (((t = cr(t)), isNaN(l)))
    return {
      stiffness: Ct.stiffness,
      damping: Ct.damping,
      duration: t,
    };
  {
    const c = Math.pow(l, 2) * i;
    return {
      stiffness: c,
      damping: a * 2 * Math.sqrt(i * c),
      duration: t,
    };
  }
}
const O2 = 12;
function F2(t, e, n) {
  let i = n;
  for (let r = 1; r < O2; r++) i = i - t(i) / e(i);
  return i;
}
function dm(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const B2 = ["duration", "bounce"],
  z2 = ["stiffness", "damping", "mass"];
function M_(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function j2(t) {
  let e = {
    velocity: Ct.velocity,
    stiffness: Ct.stiffness,
    damping: Ct.damping,
    mass: Ct.mass,
    isResolvedFromDuration: !1,
    ...t,
  };
  if (!M_(t, z2) && M_(t, B2))
    if (t.visualDuration) {
      const n = t.visualDuration,
        i = (2 * Math.PI) / (n * 1.2),
        r = i * i,
        s = 2 * ji(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(r);
      e = {
        ...e,
        mass: Ct.mass,
        stiffness: r,
        damping: s,
      };
    } else {
      const n = U2(t);
      (e = {
        ...e,
        ...n,
        mass: Ct.mass,
      }),
        (e.isResolvedFromDuration = !0);
    }
  return e;
}
function Y1(t = Ct.visualDuration, e = Ct.bounce) {
  const n =
    typeof t != "object"
      ? {
          visualDuration: t,
          keyframes: [0, 1],
          bounce: e,
        }
      : t;
  let { restSpeed: i, restDelta: r } = n;
  const s = n.keyframes[0],
    a = n.keyframes[n.keyframes.length - 1],
    o = {
      done: !1,
      value: s,
    },
    {
      stiffness: l,
      damping: c,
      mass: u,
      duration: d,
      velocity: h,
      isResolvedFromDuration: p,
    } = j2({
      ...n,
      velocity: -ur(n.velocity || 0),
    }),
    v = h || 0,
    x = c / (2 * Math.sqrt(l * u)),
    m = a - s,
    f = ur(Math.sqrt(l / u)),
    y = Math.abs(m) < 5;
  i || (i = y ? Ct.restSpeed.granular : Ct.restSpeed.default),
    r || (r = y ? Ct.restDelta.granular : Ct.restDelta.default);
  let g;
  if (x < 1) {
    const T = dm(f, x);
    g = (A) => {
      const b = Math.exp(-x * f * A);
      return (
        a - b * (((v + x * f * m) / T) * Math.sin(T * A) + m * Math.cos(T * A))
      );
    };
  } else if (x === 1) g = (T) => a - Math.exp(-f * T) * (m + (v + f * m) * T);
  else {
    const T = f * Math.sqrt(x * x - 1);
    g = (A) => {
      const b = Math.exp(-x * f * A),
        P = Math.min(T * A, 300);
      return (
        a - (b * ((v + x * f * m) * Math.sinh(P) + T * m * Math.cosh(P))) / T
      );
    };
  }
  const S = {
    calculatedDuration: (p && d) || null,
    next: (T) => {
      const A = g(T);
      if (p) o.done = T >= d;
      else {
        let b = 0;
        x < 1 && (b = T === 0 ? cr(v) : q1(g, T, A));
        const P = Math.abs(b) <= i,
          G = Math.abs(a - A) <= r;
        o.done = P && G;
      }
      return (o.value = o.done ? a : A), o;
    },
    toString: () => {
      const T = Math.min(f1(S), im),
        A = p1((b) => S.next(T * b).value, T, 30);
      return T + "ms " + A;
    },
  };
  return S;
}
function b_({
  keyframes: t,
  velocity: e = 0,
  power: n = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: a,
  min: o,
  max: l,
  restDelta: c = 0.5,
  restSpeed: u,
}) {
  const d = t[0],
    h = {
      done: !1,
      value: d,
    },
    p = (P) => (o !== void 0 && P < o) || (l !== void 0 && P > l),
    v = (P) =>
      o === void 0
        ? l
        : l === void 0 || Math.abs(o - P) < Math.abs(l - P)
        ? o
        : l;
  let x = n * e;
  const m = d + x,
    f = a === void 0 ? m : a(m);
  f !== m && (x = f - d);
  const y = (P) => -x * Math.exp(-P / i),
    g = (P) => f + y(P),
    S = (P) => {
      const G = y(P),
        w = g(P);
      (h.done = Math.abs(G) <= c), (h.value = h.done ? f : w);
    };
  let T, A;
  const b = (P) => {
    p(h.value) &&
      ((T = P),
      (A = Y1({
        keyframes: [h.value, v(h.value)],
        velocity: q1(g, P, h.value),
        damping: r,
        stiffness: s,
        restDelta: c,
        restSpeed: u,
      })));
  };
  return (
    b(0),
    {
      calculatedDuration: null,
      next: (P) => {
        let G = !1;
        return (
          !A && T === void 0 && ((G = !0), S(P), b(P)),
          T !== void 0 && P >= T ? A.next(P - T) : (!G && S(P), h)
        );
      },
    }
  );
}
const V2 = Sc(0.42, 0, 1, 1),
  H2 = Sc(0, 0, 0.58, 1),
  Z1 = Sc(0.42, 0, 0.58, 1),
  G2 = (t) => Array.isArray(t) && typeof t[0] != "number",
  A_ = {
    linear: yn,
    easeIn: V2,
    easeInOut: Z1,
    easeOut: H2,
    circIn: hv,
    circInOut: P1,
    circOut: R1,
    backIn: dv,
    backInOut: A1,
    backOut: b1,
    anticipate: C1,
  },
  C_ = (t) => {
    if (sv(t)) {
      tm(t.length === 4);
      const [e, n, i, r] = t;
      return Sc(e, n, i, r);
    } else if (typeof t == "string") return tm(A_[t] !== void 0), A_[t];
    return t;
  };
function W2(t, e, n) {
  const i = [],
    r = n || X1,
    s = t.length - 1;
  for (let a = 0; a < s; a++) {
    let o = r(t[a], t[a + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[a] || yn : e;
      o = wc(l, o);
    }
    i.push(o);
  }
  return i;
}
function _v(t, e, { clamp: n = !0, ease: i, mixer: r } = {}) {
  const s = t.length;
  if ((tm(s === e.length), s === 1)) return () => e[0];
  if (s === 2 && e[0] === e[1]) return () => e[1];
  const a = t[0] === t[1];
  t[0] > t[s - 1] && ((t = [...t].reverse()), (e = [...e].reverse()));
  const o = W2(e, i, r),
    l = o.length,
    c = (u) => {
      if (a && u < t[0]) return e[0];
      let d = 0;
      if (l > 1) for (; d < t.length - 2 && !(u < t[d + 1]); d++);
      const h = Ks(t[d], t[d + 1], u);
      return o[d](h);
    };
  return n ? (u) => c(ji(t[0], t[s - 1], u)) : c;
}
function $2(t, e) {
  const n = t[t.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = Ks(0, e, i);
    t.push(Mt(n, 1, r));
  }
}
function K1(t) {
  const e = [0];
  return $2(e, t.length - 1), e;
}
function X2(t, e) {
  return t.map((n) => n * e);
}
function q2(t, e) {
  return t.map(() => e || Z1).splice(0, t.length - 1);
}
function Md({
  duration: t = 300,
  keyframes: e,
  times: n,
  ease: i = "easeInOut",
}) {
  const r = G2(i) ? i.map(C_) : C_(i),
    s = {
      done: !1,
      value: e[0],
    },
    a = X2(n && n.length === e.length ? n : K1(e), t),
    o = _v(a, e, {
      ease: Array.isArray(r) ? r : q2(e, r),
    });
  return {
    calculatedDuration: t,
    next: (l) => ((s.value = o(l)), (s.done = l >= t), s),
  };
}
const Y2 = (t) => {
    const e = ({ timestamp: n }) => t(n);
    return {
      start: () => at.update(e, !0),
      stop: () => Mi(e),
      now: () => (Xt.isProcessing ? Xt.timestamp : Bi.now()),
    };
  },
  Z2 = {
    decay: b_,
    inertia: b_,
    tween: Md,
    keyframes: Md,
    spring: Y1,
  },
  K2 = (t) => t / 100;
class yv extends W1 {
  constructor(e) {
    super(e),
      (this.holdTime = null),
      (this.cancelTime = null),
      (this.currentTime = 0),
      (this.playbackSpeed = 1),
      (this.pendingPlayState = "running"),
      (this.startTime = null),
      (this.state = "idle"),
      (this.stop = () => {
        if (
          (this.resolver.cancel(), (this.isStopped = !0), this.state === "idle")
        )
          return;
        this.teardown();
        const { onStop: l } = this.options;
        l && l();
      });
    const { name: n, motionValue: i, element: r, keyframes: s } = this.options,
      a = (r == null ? void 0 : r.KeyframeResolver) || gv,
      o = (l, c) => this.onKeyframesResolved(l, c);
    (this.resolver = new a(s, o, n, i, r)), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(),
      this._resolved &&
        Object.assign(
          this._resolved,
          this.initPlayback(this._resolved.keyframes)
        );
  }
  initPlayback(e) {
    const {
        type: n = "keyframes",
        repeat: i = 0,
        repeatDelay: r = 0,
        repeatType: s,
        velocity: a = 0,
      } = this.options,
      o = rv(n) ? n : Z2[n] || Md;
    let l, c;
    o !== Md &&
      typeof e[0] != "number" &&
      ((l = wc(K2, X1(e[0], e[1]))), (e = [0, 100]));
    const u = o({
      ...this.options,
      keyframes: e,
    });
    s === "mirror" &&
      (c = o({
        ...this.options,
        keyframes: [...e].reverse(),
        velocity: -a,
      })),
      u.calculatedDuration === null && (u.calculatedDuration = f1(u));
    const { calculatedDuration: d } = u,
      h = d + r,
      p = h * (i + 1) - r;
    return {
      generator: u,
      mirroredGenerator: c,
      mapPercentToKeyframes: l,
      calculatedDuration: d,
      resolvedDuration: h,
      totalDuration: p,
    };
  }
  onPostResolved() {
    const { autoplay: e = !0 } = this.options;
    this.play(),
      this.pendingPlayState === "paused" || !e
        ? this.pause()
        : (this.state = this.pendingPlayState);
  }
  tick(e, n = !1) {
    const { resolved: i } = this;
    if (!i) {
      const { keyframes: P } = this.options;
      return {
        done: !0,
        value: P[P.length - 1],
      };
    }
    const {
      finalKeyframe: r,
      generator: s,
      mirroredGenerator: a,
      mapPercentToKeyframes: o,
      keyframes: l,
      calculatedDuration: c,
      totalDuration: u,
      resolvedDuration: d,
    } = i;
    if (this.startTime === null) return s.next(0);
    const {
      delay: h,
      repeat: p,
      repeatType: v,
      repeatDelay: x,
      onUpdate: m,
    } = this.options;
    this.speed > 0
      ? (this.startTime = Math.min(this.startTime, e))
      : this.speed < 0 &&
        (this.startTime = Math.min(e - u / this.speed, this.startTime)),
      n
        ? (this.currentTime = e)
        : this.holdTime !== null
        ? (this.currentTime = this.holdTime)
        : (this.currentTime = Math.round(e - this.startTime) * this.speed);
    const f = this.currentTime - h * (this.speed >= 0 ? 1 : -1),
      y = this.speed >= 0 ? f < 0 : f > u;
    (this.currentTime = Math.max(f, 0)),
      this.state === "finished" &&
        this.holdTime === null &&
        (this.currentTime = u);
    let g = this.currentTime,
      S = s;
    if (p) {
      const P = Math.min(this.currentTime, u) / d;
      let G = Math.floor(P),
        w = P % 1;
      !w && P >= 1 && (w = 1),
        w === 1 && G--,
        (G = Math.min(G, p + 1)),
        !!(G % 2) &&
          (v === "reverse"
            ? ((w = 1 - w), x && (w -= x / d))
            : v === "mirror" && (S = a)),
        (g = ji(0, 1, w) * d);
    }
    const T = y
      ? {
          done: !1,
          value: l[0],
        }
      : S.next(g);
    o && (T.value = o(T.value));
    let { done: A } = T;
    !y &&
      c !== null &&
      (A = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
    const b =
      this.holdTime === null &&
      (this.state === "finished" || (this.state === "running" && A));
    return (
      b && r !== void 0 && (T.value = fh(l, this.options, r)),
      m && m(T.value),
      b && this.finish(),
      T
    );
  }
  get duration() {
    const { resolved: e } = this;
    return e ? ur(e.calculatedDuration) : 0;
  }
  get time() {
    return ur(this.currentTime);
  }
  set time(e) {
    (e = cr(e)),
      (this.currentTime = e),
      this.holdTime !== null || this.speed === 0
        ? (this.holdTime = e)
        : this.driver && (this.startTime = this.driver.now() - e / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    const n = this.playbackSpeed !== e;
    (this.playbackSpeed = e), n && (this.time = ur(this.currentTime));
  }
  play() {
    if (
      (this.resolver.isScheduled || this.resolver.resume(), !this._resolved)
    ) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped) return;
    const { driver: e = Y2, onPlay: n, startTime: i } = this.options;
    this.driver || (this.driver = e((s) => this.tick(s))), n && n();
    const r = this.driver.now();
    this.holdTime !== null
      ? (this.startTime = r - this.holdTime)
      : this.startTime
      ? this.state === "finished" && (this.startTime = r)
      : (this.startTime = i ?? this.calcStartTime()),
      this.state === "finished" && this.updateFinishedPromise(),
      (this.cancelTime = this.startTime),
      (this.holdTime = null),
      (this.state = "running"),
      this.driver.start();
  }
  pause() {
    var e;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    (this.state = "paused"),
      (this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0);
  }
  complete() {
    this.state !== "running" && this.play(),
      (this.pendingPlayState = this.state = "finished"),
      (this.holdTime = null);
  }
  finish() {
    this.teardown(), (this.state = "finished");
    const { onComplete: e } = this.options;
    e && e();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime),
      this.teardown(),
      this.updateFinishedPromise();
  }
  teardown() {
    (this.state = "idle"),
      this.stopDriver(),
      this.resolveFinishedPromise(),
      this.updateFinishedPromise(),
      (this.startTime = this.cancelTime = null),
      this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), (this.driver = void 0));
  }
  sample(e) {
    return (this.startTime = 0), this.tick(e, !0);
  }
}
const J2 = new Set(["opacity", "clipPath", "filter", "transform"]);
function Q2(
  t,
  e,
  n,
  {
    delay: i = 0,
    duration: r = 300,
    repeat: s = 0,
    repeatType: a = "loop",
    ease: o = "easeInOut",
    times: l,
  } = {}
) {
  const c = {
    [e]: n,
  };
  l && (c.offset = l);
  const u = g1(o, r);
  return (
    Array.isArray(u) && (c.easing = u),
    t.animate(c, {
      delay: i,
      duration: r,
      easing: Array.isArray(u) ? "linear" : u,
      fill: "both",
      iterations: s + 1,
      direction: a === "reverse" ? "alternate" : "normal",
    })
  );
}
const eL = Hg(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
  bd = 10,
  tL = 2e4;
function nL(t) {
  return rv(t.type) || t.type === "spring" || !m1(t.ease);
}
function iL(t, e) {
  const n = new yv({
    ...e,
    keyframes: t,
    repeat: 0,
    delay: 0,
    isGenerator: !0,
  });
  let i = {
    done: !1,
    value: t[0],
  };
  const r = [];
  let s = 0;
  for (; !i.done && s < tL; ) (i = n.sample(s)), r.push(i.value), (s += bd);
  return {
    times: void 0,
    keyframes: r,
    duration: s - bd,
    ease: "linear",
  };
}
const J1 = {
  anticipate: C1,
  backInOut: A1,
  circInOut: P1,
};
function rL(t) {
  return t in J1;
}
class R_ extends W1 {
  constructor(e) {
    super(e);
    const { name: n, motionValue: i, element: r, keyframes: s } = this.options;
    (this.resolver = new G1(
      s,
      (a, o) => this.onKeyframesResolved(a, o),
      n,
      i,
      r
    )),
      this.resolver.scheduleResolve();
  }
  initPlayback(e, n) {
    let {
      duration: i = 300,
      times: r,
      ease: s,
      type: a,
      motionValue: o,
      name: l,
      startTime: c,
    } = this.options;
    if (!o.owner || !o.owner.current) return !1;
    if (
      (typeof s == "string" && Ed() && rL(s) && (s = J1[s]), nL(this.options))
    ) {
      const {
          onComplete: d,
          onUpdate: h,
          motionValue: p,
          element: v,
          ...x
        } = this.options,
        m = iL(e, x);
      (e = m.keyframes),
        e.length === 1 && (e[1] = e[0]),
        (i = m.duration),
        (r = m.times),
        (s = m.ease),
        (a = "keyframes");
    }
    const u = Q2(o.owner.current, l, e, {
      ...this.options,
      duration: i,
      times: r,
      ease: s,
    });
    return (
      (u.startTime = c ?? this.calcStartTime()),
      this.pendingTimeline
        ? (h_(u, this.pendingTimeline), (this.pendingTimeline = void 0))
        : (u.onfinish = () => {
            const { onComplete: d } = this.options;
            o.set(fh(e, this.options, n)),
              d && d(),
              this.cancel(),
              this.resolveFinishedPromise();
          }),
      {
        animation: u,
        duration: i,
        times: r,
        type: a,
        ease: s,
        keyframes: e,
      }
    );
  }
  get duration() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { duration: n } = e;
    return ur(n);
  }
  get time() {
    const { resolved: e } = this;
    if (!e) return 0;
    const { animation: n } = e;
    return ur(n.currentTime || 0);
  }
  set time(e) {
    const { resolved: n } = this;
    if (!n) return;
    const { animation: i } = n;
    i.currentTime = cr(e);
  }
  get speed() {
    const { resolved: e } = this;
    if (!e) return 1;
    const { animation: n } = e;
    return n.playbackRate;
  }
  set speed(e) {
    const { resolved: n } = this;
    if (!n) return;
    const { animation: i } = n;
    i.playbackRate = e;
  }
  get state() {
    const { resolved: e } = this;
    if (!e) return "idle";
    const { animation: n } = e;
    return n.playState;
  }
  get startTime() {
    const { resolved: e } = this;
    if (!e) return null;
    const { animation: n } = e;
    return n.startTime;
  }
  attachTimeline(e) {
    if (!this._resolved) this.pendingTimeline = e;
    else {
      const { resolved: n } = this;
      if (!n) return yn;
      const { animation: i } = n;
      h_(i, e);
    }
    return yn;
  }
  play() {
    if (this.isStopped) return;
    const { resolved: e } = this;
    if (!e) return;
    const { animation: n } = e;
    n.playState === "finished" && this.updateFinishedPromise(), n.play();
  }
  pause() {
    const { resolved: e } = this;
    if (!e) return;
    const { animation: n } = e;
    n.pause();
  }
  stop() {
    if ((this.resolver.cancel(), (this.isStopped = !0), this.state === "idle"))
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: e } = this;
    if (!e) return;
    const {
      animation: n,
      keyframes: i,
      duration: r,
      type: s,
      ease: a,
      times: o,
    } = e;
    if (n.playState === "idle" || n.playState === "finished") return;
    if (this.time) {
      const {
          motionValue: c,
          onUpdate: u,
          onComplete: d,
          element: h,
          ...p
        } = this.options,
        v = new yv({
          ...p,
          keyframes: i,
          duration: r,
          type: s,
          ease: a,
          times: o,
          isGenerator: !0,
        }),
        x = cr(this.time);
      c.setWithVelocity(v.sample(x - bd).value, v.sample(x).value, bd);
    }
    const { onStop: l } = this.options;
    l && l(), this.cancel();
  }
  complete() {
    const { resolved: e } = this;
    e && e.animation.finish();
  }
  cancel() {
    const { resolved: e } = this;
    e && e.animation.cancel();
  }
  static supports(e) {
    const {
      motionValue: n,
      name: i,
      repeatDelay: r,
      repeatType: s,
      damping: a,
      type: o,
    } = e;
    if (!n || !n.owner || !(n.owner.current instanceof HTMLElement)) return !1;
    const { onUpdate: l, transformTemplate: c } = n.owner.getProps();
    return (
      eL() &&
      i &&
      J2.has(i) &&
      !l &&
      !c &&
      !r &&
      s !== "mirror" &&
      a !== 0 &&
      o !== "inertia"
    );
  }
}
const sL = {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10,
  },
  aL = (t) => ({
    type: "spring",
    stiffness: 550,
    damping: t === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  oL = {
    type: "keyframes",
    duration: 0.8,
  },
  lL = {
    type: "keyframes",
    ease: [0.25, 0.1, 0.35, 1],
    duration: 0.3,
  },
  cL = (t, { keyframes: e }) =>
    e.length > 2
      ? oL
      : aa.has(t)
      ? t.startsWith("scale")
        ? aL(e[1])
        : sL
      : lL;
function uL({
  when: t,
  delay: e,
  delayChildren: n,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: a,
  repeatDelay: o,
  from: l,
  elapsed: c,
  ...u
}) {
  return !!Object.keys(u).length;
}
const xv =
  (t, e, n, i = {}, r, s) =>
  (a) => {
    const o = iv(i, t) || {},
      l = o.delay || i.delay || 0;
    let { elapsed: c = 0 } = i;
    c = c - cr(l);
    let u = {
      keyframes: Array.isArray(n) ? n : [null, n],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...o,
      delay: -c,
      onUpdate: (h) => {
        e.set(h), o.onUpdate && o.onUpdate(h);
      },
      onComplete: () => {
        a(), o.onComplete && o.onComplete();
      },
      name: t,
      motionValue: e,
      element: s ? void 0 : r,
    };
    uL(o) ||
      (u = {
        ...u,
        ...cL(t, u),
      }),
      u.duration && (u.duration = cr(u.duration)),
      u.repeatDelay && (u.repeatDelay = cr(u.repeatDelay)),
      u.from !== void 0 && (u.keyframes[0] = u.from);
    let d = !1;
    if (
      ((u.type === !1 || (u.duration === 0 && !u.repeatDelay)) &&
        ((u.duration = 0), u.delay === 0 && (d = !0)),
      d && !s && e.get() !== void 0)
    ) {
      const h = fh(u.keyframes, o);
      if (h !== void 0)
        return (
          at.update(() => {
            u.onUpdate(h), u.onComplete();
          }),
          new DP([])
        );
    }
    return !s && R_.supports(u) ? new R_(u) : new yv(u);
  };
function dL({ protectedKeys: t, needsAnimating: e }, n) {
  const i = t.hasOwnProperty(n) && e[n] !== !0;
  return (e[n] = !1), i;
}
function Q1(t, e, { delay: n = 0, transitionOverride: i, type: r } = {}) {
  var s;
  let { transition: a = t.getDefaultTransition(), transitionEnd: o, ...l } = e;
  i && (a = i);
  const c = [],
    u = r && t.animationState && t.animationState.getState()[r];
  for (const d in l) {
    const h = t.getValue(
        d,
        (s = t.latestValues[d]) !== null && s !== void 0 ? s : null
      ),
      p = l[d];
    if (p === void 0 || (u && dL(u, d))) continue;
    const v = {
      delay: n,
      ...iv(a || {}, d),
    };
    let x = !1;
    if (window.MotionHandoffAnimation) {
      const f = w1(t);
      if (f) {
        const y = window.MotionHandoffAnimation(f, d, at);
        y !== null && ((v.startTime = y), (x = !0));
      }
    }
    sm(t, d),
      h.start(
        xv(
          d,
          h,
          p,
          t.shouldReduceMotion && S1.has(d)
            ? {
                type: !1,
              }
            : v,
          t,
          x
        )
      );
    const m = h.animation;
    m && c.push(m);
  }
  return (
    o &&
      Promise.all(c).then(() => {
        at.update(() => {
          o && $P(t, o);
        });
      }),
    c
  );
}
function hm(t, e, n = {}) {
  var i;
  const r = hh(
    t,
    e,
    n.type === "exit"
      ? (i = t.presenceContext) === null || i === void 0
        ? void 0
        : i.custom
      : void 0
  );
  let { transition: s = t.getDefaultTransition() || {} } = r || {};
  n.transitionOverride && (s = n.transitionOverride);
  const a = r ? () => Promise.all(Q1(t, r, n)) : () => Promise.resolve(),
    o =
      t.variantChildren && t.variantChildren.size
        ? (c = 0) => {
            const {
              delayChildren: u = 0,
              staggerChildren: d,
              staggerDirection: h,
            } = s;
            return hL(t, e, u + c, d, h, n);
          }
        : () => Promise.resolve(),
    { when: l } = s;
  if (l) {
    const [c, u] = l === "beforeChildren" ? [a, o] : [o, a];
    return c().then(() => u());
  } else return Promise.all([a(), o(n.delay)]);
}
function hL(t, e, n = 0, i = 0, r = 1, s) {
  const a = [],
    o = (t.variantChildren.size - 1) * i,
    l = r === 1 ? (c = 0) => c * i : (c = 0) => o - c * i;
  return (
    Array.from(t.variantChildren)
      .sort(fL)
      .forEach((c, u) => {
        c.notify("AnimationStart", e),
          a.push(
            hm(c, e, {
              ...s,
              delay: n + l(u),
            }).then(() => c.notify("AnimationComplete", e))
          );
      }),
    Promise.all(a)
  );
}
function fL(t, e) {
  return t.sortNodePosition(e);
}
function pL(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => hm(t, s, n));
    i = Promise.all(r);
  } else if (typeof e == "string") i = hm(t, e, n);
  else {
    const r = typeof e == "function" ? hh(t, e, n.custom) : e;
    i = Promise.all(Q1(t, r, n));
  }
  return i.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const mL = Wg.length;
function eT(t) {
  if (!t) return;
  if (!t.isControllingVariants) {
    const n = t.parent ? eT(t.parent) || {} : {};
    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;
  }
  const e = {};
  for (let n = 0; n < mL; n++) {
    const i = Wg[n],
      r = t.props[i];
    (ql(r) || r === !1) && (e[i] = r);
  }
  return e;
}
const gL = [...Gg].reverse(),
  vL = Gg.length;
function _L(t) {
  return (e) =>
    Promise.all(e.map(({ animation: n, options: i }) => pL(t, n, i)));
}
function yL(t) {
  let e = _L(t),
    n = P_(),
    i = !0;
  const r = (l) => (c, u) => {
    var d;
    const h = hh(
      t,
      u,
      l === "exit"
        ? (d = t.presenceContext) === null || d === void 0
          ? void 0
          : d.custom
        : void 0
    );
    if (h) {
      const { transition: p, transitionEnd: v, ...x } = h;
      c = {
        ...c,
        ...x,
        ...v,
      };
    }
    return c;
  };
  function s(l) {
    e = l(t);
  }
  function a(l) {
    const { props: c } = t,
      u = eT(t.parent) || {},
      d = [],
      h = new Set();
    let p = {},
      v = 1 / 0;
    for (let m = 0; m < vL; m++) {
      const f = gL[m],
        y = n[f],
        g = c[f] !== void 0 ? c[f] : u[f],
        S = ql(g),
        T = f === l ? y.isActive : null;
      T === !1 && (v = m);
      let A = g === u[f] && g !== c[f] && S;
      if (
        (A && i && t.manuallyAnimateOnMount && (A = !1),
        (y.protectedKeys = {
          ...p,
        }),
        (!y.isActive && T === null) ||
          (!g && !y.prevProp) ||
          uh(g) ||
          typeof g == "boolean")
      )
        continue;
      const b = xL(y.prevProp, g);
      let P = b || (f === l && y.isActive && !A && S) || (m > v && S),
        G = !1;
      const w = Array.isArray(g) ? g : [g];
      let R = w.reduce(r(f), {});
      T === !1 && (R = {});
      const { prevResolvedValues: ie = {} } = y,
        J = {
          ...ie,
          ...R,
        },
        D = (W) => {
          (P = !0),
            h.has(W) && ((G = !0), h.delete(W)),
            (y.needsAnimating[W] = !0);
          const L = t.getValue(W);
          L && (L.liveStyle = !1);
        };
      for (const W in J) {
        const L = R[W],
          U = ie[W];
        if (p.hasOwnProperty(W)) continue;
        let X = !1;
        nm(L) && nm(U) ? (X = !d1(L, U)) : (X = L !== U),
          X
            ? L != null
              ? D(W)
              : h.add(W)
            : L !== void 0 && h.has(W)
            ? D(W)
            : (y.protectedKeys[W] = !0);
      }
      (y.prevProp = g),
        (y.prevResolvedValues = R),
        y.isActive &&
          (p = {
            ...p,
            ...R,
          }),
        i && t.blockInitialAnimation && (P = !1),
        P &&
          (!(A && b) || G) &&
          d.push(
            ...w.map((W) => ({
              animation: W,
              options: {
                type: f,
              },
            }))
          );
    }
    if (h.size) {
      const m = {};
      h.forEach((f) => {
        const y = t.getBaseTarget(f),
          g = t.getValue(f);
        g && (g.liveStyle = !0), (m[f] = y ?? null);
      }),
        d.push({
          animation: m,
        });
    }
    let x = !!d.length;
    return (
      i &&
        (c.initial === !1 || c.initial === c.animate) &&
        !t.manuallyAnimateOnMount &&
        (x = !1),
      (i = !1),
      x ? e(d) : Promise.resolve()
    );
  }
  function o(l, c) {
    var u;
    if (n[l].isActive === c) return Promise.resolve();
    (u = t.variantChildren) === null ||
      u === void 0 ||
      u.forEach((h) => {
        var p;
        return (p = h.animationState) === null || p === void 0
          ? void 0
          : p.setActive(l, c);
      }),
      (n[l].isActive = c);
    const d = a(l);
    for (const h in n) n[h].protectedKeys = {};
    return d;
  }
  return {
    animateChanges: a,
    setActive: o,
    setAnimateFunction: s,
    getState: () => n,
    reset: () => {
      (n = P_()), (i = !0);
    },
  };
}
function xL(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !d1(e, t) : !1;
}
function gs(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function P_() {
  return {
    animate: gs(!0),
    whileInView: gs(),
    whileHover: gs(),
    whileTap: gs(),
    whileDrag: gs(),
    whileFocus: gs(),
    exit: gs(),
  };
}
class ds {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
class SL extends ds {
  constructor(e) {
    super(e), e.animationState || (e.animationState = yL(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    uh(e) && (this.unmountControls = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(),
      (e = this.unmountControls) === null || e === void 0 || e.call(this);
  }
}
let wL = 0;
class EL extends ds {
  constructor() {
    super(...arguments), (this.id = wL++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext,
      { isPresent: i } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === i) return;
    const r = this.node.animationState.setActive("exit", !e);
    n && !e && r.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const TL = {
  animation: {
    Feature: SL,
  },
  exit: {
    Feature: EL,
  },
};
function Kl(
  t,
  e,
  n,
  i = {
    passive: !0,
  }
) {
  return t.addEventListener(e, n, i), () => t.removeEventListener(e, n);
}
function Ec(t) {
  return {
    point: {
      x: t.pageX,
      y: t.pageY,
    },
  };
}
const ML = (t) => (e) => av(e) && t(e, Ec(e));
function wl(t, e, n, i) {
  return Kl(t, e, ML(n), i);
}
const L_ = (t, e) => Math.abs(t - e);
function bL(t, e) {
  const n = L_(t.x, e.x),
    i = L_(t.y, e.y);
  return Math.sqrt(n ** 2 + i ** 2);
}
class tT {
  constructor(
    e,
    n,
    { transformPagePoint: i, contextWindow: r, dragSnapToOrigin: s = !1 } = {}
  ) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.contextWindow = window),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const d = hf(this.lastMoveEventInfo, this.history),
          h = this.startEvent !== null,
          p =
            bL(d.offset, {
              x: 0,
              y: 0,
            }) >= 3;
        if (!h && !p) return;
        const { point: v } = d,
          { timestamp: x } = Xt;
        this.history.push({
          ...v,
          timestamp: x,
        });
        const { onStart: m, onMove: f } = this.handlers;
        h ||
          (m && m(this.lastMoveEvent, d),
          (this.startEvent = this.lastMoveEvent)),
          f && f(this.lastMoveEvent, d);
      }),
      (this.handlePointerMove = (d, h) => {
        (this.lastMoveEvent = d),
          (this.lastMoveEventInfo = df(h, this.transformPagePoint)),
          at.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (d, h) => {
        this.end();
        const { onEnd: p, onSessionEnd: v, resumeAnimation: x } = this.handlers;
        if (
          (this.dragSnapToOrigin && x && x(),
          !(this.lastMoveEvent && this.lastMoveEventInfo))
        )
          return;
        const m = hf(
          d.type === "pointercancel"
            ? this.lastMoveEventInfo
            : df(h, this.transformPagePoint),
          this.history
        );
        this.startEvent && p && p(d, m), v && v(d, m);
      }),
      !av(e))
    )
      return;
    (this.dragSnapToOrigin = s),
      (this.handlers = n),
      (this.transformPagePoint = i),
      (this.contextWindow = r || window);
    const a = Ec(e),
      o = df(a, this.transformPagePoint),
      { point: l } = o,
      { timestamp: c } = Xt;
    this.history = [
      {
        ...l,
        timestamp: c,
      },
    ];
    const { onSessionStart: u } = n;
    u && u(e, hf(o, this.history)),
      (this.removeListeners = wc(
        wl(this.contextWindow, "pointermove", this.handlePointerMove),
        wl(this.contextWindow, "pointerup", this.handlePointerUp),
        wl(this.contextWindow, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Mi(this.updatePoint);
  }
}
function df(t, e) {
  return e
    ? {
        point: e(t.point),
      }
    : t;
}
function N_(t, e) {
  return {
    x: t.x - e.x,
    y: t.y - e.y,
  };
}
function hf({ point: t }, e) {
  return {
    point: t,
    delta: N_(t, nT(e)),
    offset: N_(t, AL(e)),
    velocity: CL(e, 0.1),
  };
}
function AL(t) {
  return t[0];
}
function nT(t) {
  return t[t.length - 1];
}
function CL(t, e) {
  if (t.length < 2)
    return {
      x: 0,
      y: 0,
    };
  let n = t.length - 1,
    i = null;
  const r = nT(t);
  for (; n >= 0 && ((i = t[n]), !(r.timestamp - i.timestamp > cr(e))); ) n--;
  if (!i)
    return {
      x: 0,
      y: 0,
    };
  const s = ur(r.timestamp - i.timestamp);
  if (s === 0)
    return {
      x: 0,
      y: 0,
    };
  const a = {
    x: (r.x - i.x) / s,
    y: (r.y - i.y) / s,
  };
  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;
}
const iT = 1e-4,
  RL = 1 - iT,
  PL = 1 + iT,
  rT = 0.01,
  LL = 0 - rT,
  NL = 0 + rT;
function Wn(t) {
  return t.max - t.min;
}
function DL(t, e, n) {
  return Math.abs(t - e) <= n;
}
function D_(t, e, n, i = 0.5) {
  (t.origin = i),
    (t.originPoint = Mt(e.min, e.max, t.origin)),
    (t.scale = Wn(n) / Wn(e)),
    (t.translate = Mt(n.min, n.max, t.origin) - t.originPoint),
    ((t.scale >= RL && t.scale <= PL) || isNaN(t.scale)) && (t.scale = 1),
    ((t.translate >= LL && t.translate <= NL) || isNaN(t.translate)) &&
      (t.translate = 0);
}
function El(t, e, n, i) {
  D_(t.x, e.x, n.x, i ? i.originX : void 0),
    D_(t.y, e.y, n.y, i ? i.originY : void 0);
}
function k_(t, e, n) {
  (t.min = n.min + e.min), (t.max = t.min + Wn(e));
}
function kL(t, e, n) {
  k_(t.x, e.x, n.x), k_(t.y, e.y, n.y);
}
function I_(t, e, n) {
  (t.min = e.min - n.min), (t.max = t.min + Wn(e));
}
function Tl(t, e, n) {
  I_(t.x, e.x, n.x), I_(t.y, e.y, n.y);
}
function IL(t, { min: e, max: n }, i) {
  return (
    e !== void 0 && t < e
      ? (t = i ? Mt(e, t, i.min) : Math.max(t, e))
      : n !== void 0 && t > n && (t = i ? Mt(n, t, i.max) : Math.min(t, n)),
    t
  );
}
function U_(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0,
  };
}
function UL(t, { top: e, left: n, bottom: i, right: r }) {
  return {
    x: U_(t.x, n, r),
    y: U_(t.y, e, i),
  };
}
function O_(t, e) {
  let n = e.min - t.min,
    i = e.max - t.max;
  return (
    e.max - e.min < t.max - t.min && ([n, i] = [i, n]),
    {
      min: n,
      max: i,
    }
  );
}
function OL(t, e) {
  return {
    x: O_(t.x, e.x),
    y: O_(t.y, e.y),
  };
}
function FL(t, e) {
  let n = 0.5;
  const i = Wn(t),
    r = Wn(e);
  return (
    r > i
      ? (n = Ks(e.min, e.max - i, t.min))
      : i > r && (n = Ks(t.min, t.max - r, e.min)),
    ji(0, 1, n)
  );
}
function BL(t, e) {
  const n = {};
  return (
    e.min !== void 0 && (n.min = e.min - t.min),
    e.max !== void 0 && (n.max = e.max - t.min),
    n
  );
}
const fm = 0.35;
function zL(t = fm) {
  return (
    t === !1 ? (t = 0) : t === !0 && (t = fm),
    {
      x: F_(t, "left", "right"),
      y: F_(t, "top", "bottom"),
    }
  );
}
function F_(t, e, n) {
  return {
    min: B_(t, e),
    max: B_(t, n),
  };
}
function B_(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const z_ = () => ({
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0,
  }),
  Ga = () => ({
    x: z_(),
    y: z_(),
  }),
  j_ = () => ({
    min: 0,
    max: 0,
  }),
  Nt = () => ({
    x: j_(),
    y: j_(),
  });
function Jn(t) {
  return [t("x"), t("y")];
}
function sT({ top: t, left: e, right: n, bottom: i }) {
  return {
    x: {
      min: e,
      max: n,
    },
    y: {
      min: t,
      max: i,
    },
  };
}
function jL({ x: t, y: e }) {
  return {
    top: e.min,
    right: t.max,
    bottom: e.max,
    left: t.min,
  };
}
function VL(t, e) {
  if (!e) return t;
  const n = e({
      x: t.left,
      y: t.top,
    }),
    i = e({
      x: t.right,
      y: t.bottom,
    });
  return {
    top: n.y,
    left: n.x,
    bottom: i.y,
    right: i.x,
  };
}
function ff(t) {
  return t === void 0 || t === 1;
}
function pm({ scale: t, scaleX: e, scaleY: n }) {
  return !ff(t) || !ff(e) || !ff(n);
}
function bs(t) {
  return (
    pm(t) ||
    aT(t) ||
    t.z ||
    t.rotate ||
    t.rotateX ||
    t.rotateY ||
    t.skewX ||
    t.skewY
  );
}
function aT(t) {
  return V_(t.x) || V_(t.y);
}
function V_(t) {
  return t && t !== "0%";
}
function Ad(t, e, n) {
  const i = t - n,
    r = e * i;
  return n + r;
}
function H_(t, e, n, i, r) {
  return r !== void 0 && (t = Ad(t, r, i)), Ad(t, n, i) + e;
}
function mm(t, e = 0, n = 1, i, r) {
  (t.min = H_(t.min, e, n, i, r)), (t.max = H_(t.max, e, n, i, r));
}
function oT(t, { x: e, y: n }) {
  mm(t.x, e.translate, e.scale, e.originPoint),
    mm(t.y, n.translate, n.scale, n.originPoint);
}
const G_ = 0.999999999999,
  W_ = 1.0000000000001;
function HL(t, e, n, i = !1) {
  const r = n.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, a;
  for (let o = 0; o < r; o++) {
    (s = n[o]), (a = s.projectionDelta);
    const { visualElement: l } = s.options;
    (l && l.props.style && l.props.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        $a(t, {
          x: -s.scroll.offset.x,
          y: -s.scroll.offset.y,
        }),
      a && ((e.x *= a.x.scale), (e.y *= a.y.scale), oT(t, a)),
      i && bs(s.latestValues) && $a(t, s.latestValues));
  }
  e.x < W_ && e.x > G_ && (e.x = 1), e.y < W_ && e.y > G_ && (e.y = 1);
}
function Wa(t, e) {
  (t.min = t.min + e), (t.max = t.max + e);
}
function $_(t, e, n, i, r = 0.5) {
  const s = Mt(t.min, t.max, r);
  mm(t, e, n, s, i);
}
function $a(t, e) {
  $_(t.x, e.x, e.scaleX, e.scale, e.originX),
    $_(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function lT(t, e) {
  return sT(VL(t.getBoundingClientRect(), e));
}
function GL(t, e, n) {
  const i = lT(t, n),
    { scroll: r } = e;
  return r && (Wa(i.x, r.offset.x), Wa(i.y, r.offset.y)), i;
}
const cT = ({ current: t }) => (t ? t.ownerDocument.defaultView : null),
  WL = new WeakMap();
class $L {
  constructor(e) {
    (this.openDragLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = {
        x: 0,
        y: 0,
      }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Nt()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: n = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (u) => {
        const { dragSnapToOrigin: d } = this.getProps();
        d ? this.pauseAnimation() : this.stopAnimation(),
          n && this.snapToCursor(Ec(u).point);
      },
      s = (u, d) => {
        const { drag: h, dragPropagation: p, onDragStart: v } = this.getProps();
        if (
          h &&
          !p &&
          (this.openDragLock && this.openDragLock(),
          (this.openDragLock = jP(h)),
          !this.openDragLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          Jn((m) => {
            let f = this.getAxisMotionValue(m).get() || 0;
            if (Fi.test(f)) {
              const { projection: y } = this.visualElement;
              if (y && y.layout) {
                const g = y.layout.layoutBox[m];
                g && (f = Wn(g) * (parseFloat(f) / 100));
              }
            }
            this.originPoint[m] = f;
          }),
          v && at.postRender(() => v(u, d)),
          sm(this.visualElement, "transform");
        const { animationState: x } = this.visualElement;
        x && x.setActive("whileDrag", !0);
      },
      a = (u, d) => {
        const {
          dragPropagation: h,
          dragDirectionLock: p,
          onDirectionLock: v,
          onDrag: x,
        } = this.getProps();
        if (!h && !this.openDragLock) return;
        const { offset: m } = d;
        if (p && this.currentDirection === null) {
          (this.currentDirection = XL(m)),
            this.currentDirection !== null && v && v(this.currentDirection);
          return;
        }
        this.updateAxis("x", d.point, m),
          this.updateAxis("y", d.point, m),
          this.visualElement.render(),
          x && x(u, d);
      },
      o = (u, d) => this.stop(u, d),
      l = () =>
        Jn((u) => {
          var d;
          return (
            this.getAnimationState(u) === "paused" &&
            ((d = this.getAxisMotionValue(u).animation) === null || d === void 0
              ? void 0
              : d.play())
          );
        }),
      { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new tT(
      e,
      {
        onSessionStart: r,
        onStart: s,
        onMove: a,
        onSessionEnd: o,
        resumeAnimation: l,
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: c,
        contextWindow: cT(this.visualElement),
      }
    );
  }
  stop(e, n) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = n;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && at.postRender(() => s(e, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: i } = this.getProps();
    !i &&
      this.openDragLock &&
      (this.openDragLock(), (this.openDragLock = null)),
      n && n.setActive("whileDrag", !1);
  }
  updateAxis(e, n, i) {
    const { drag: r } = this.getProps();
    if (!i || !eu(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let a = this.originPoint[e] + i[e];
    this.constraints &&
      this.constraints[e] &&
      (a = IL(a, this.constraints[e], this.elastic[e])),
      s.set(a);
  }
  resolveConstraints() {
    var e;
    const { dragConstraints: n, dragElastic: i } = this.getProps(),
      r =
        this.visualElement.projection && !this.visualElement.projection.layout
          ? this.visualElement.projection.measure(!1)
          : (e = this.visualElement.projection) === null || e === void 0
          ? void 0
          : e.layout,
      s = this.constraints;
    n && Va(n)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : n && r
      ? (this.constraints = UL(r.layoutBox, n))
      : (this.constraints = !1),
      (this.elastic = zL(i)),
      s !== this.constraints &&
        r &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        Jn((a) => {
          this.constraints !== !1 &&
            this.getAxisMotionValue(a) &&
            (this.constraints[a] = BL(r.layoutBox[a], this.constraints[a]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !Va(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = GL(i, r.root, this.visualElement.getTransformPagePoint());
    let a = OL(r.layout.layoutBox, s);
    if (n) {
      const o = n(jL(a));
      (this.hasMutatedConstraints = !!o), o && (a = sT(o));
    }
    return a;
  }
  startAnimation(e) {
    const {
        drag: n,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: a,
        onDragTransitionEnd: o,
      } = this.getProps(),
      l = this.constraints || {},
      c = Jn((u) => {
        if (!eu(u, n, this.currentDirection)) return;
        let d = (l && l[u]) || {};
        a &&
          (d = {
            min: 0,
            max: 0,
          });
        const h = r ? 200 : 1e6,
          p = r ? 40 : 1e7,
          v = {
            type: "inertia",
            velocity: i ? e[u] : 0,
            bounceStiffness: h,
            bounceDamping: p,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(u, v);
      });
    return Promise.all(c).then(o);
  }
  startAxisValueAnimation(e, n) {
    const i = this.getAxisMotionValue(e);
    return (
      sm(this.visualElement, e), i.start(xv(e, i, 0, n, this.visualElement, !1))
    );
  }
  stopAnimation() {
    Jn((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    Jn((e) => {
      var n;
      return (n = this.getAxisMotionValue(e).animation) === null || n === void 0
        ? void 0
        : n.pause();
    });
  }
  getAnimationState(e) {
    var n;
    return (n = this.getAxisMotionValue(e).animation) === null || n === void 0
      ? void 0
      : n.state;
  }
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`,
      i = this.visualElement.getProps(),
      r = i[n];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    Jn((n) => {
      const { drag: i } = this.getProps();
      if (!eu(n, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(n);
      if (r && r.layout) {
        const { min: a, max: o } = r.layout.layoutBox[n];
        s.set(e[n] - Mt(a, o, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: n } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!Va(n) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = {
      x: 0,
      y: 0,
    };
    Jn((a) => {
      const o = this.getAxisMotionValue(a);
      if (o && this.constraints !== !1) {
        const l = o.get();
        r[a] = FL(
          {
            min: l,
            max: l,
          },
          this.constraints[a]
        );
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      Jn((a) => {
        if (!eu(a, e, null)) return;
        const o = this.getAxisMotionValue(a),
          { min: l, max: c } = this.constraints[a];
        o.set(Mt(l, c, r[a]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    WL.set(this.visualElement, this);
    const e = this.visualElement.current,
      n = wl(e, "pointerdown", (l) => {
        const { drag: c, dragListener: u = !0 } = this.getProps();
        c && u && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        Va(l) && l.current && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()),
      at.read(i);
    const a = Kl(window, "resize", () => this.scalePositionWithinConstraints()),
      o = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: c }) => {
          this.isDragging &&
            c &&
            (Jn((u) => {
              const d = this.getAxisMotionValue(u);
              d &&
                ((this.originPoint[u] += l[u].translate),
                d.set(d.get() + l[u].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      a(), n(), s(), o && o();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: n = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: a = fm,
        dragMomentum: o = !0,
      } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: a,
      dragMomentum: o,
    };
  }
}
function eu(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function XL(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? (n = "y") : Math.abs(t.x) > e && (n = "x"), n;
}
class qL extends ds {
  constructor(e) {
    super(e),
      (this.removeGroupControls = yn),
      (this.removeListeners = yn),
      (this.controls = new $L(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || yn);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const X_ = (t) => (e, n) => {
  t && at.postRender(() => t(e, n));
};
class YL extends ds {
  constructor() {
    super(...arguments), (this.removePointerDownListener = yn);
  }
  onPointerDown(e) {
    this.session = new tT(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: cT(this.node),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: n,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: X_(e),
      onStart: X_(n),
      onMove: i,
      onEnd: (s, a) => {
        delete this.session, r && at.postRender(() => r(s, a));
      },
    };
  }
  mount() {
    this.removePointerDownListener = wl(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Wu = {
  hasAnimatedSinceResize: !0,
  hasEverUpdated: !1,
};
function q_(t, e) {
  return e.max === e.min ? 0 : (t / (e.max - e.min)) * 100;
}
const Wo = {
    correct: (t, e) => {
      if (!e.target) return t;
      if (typeof t == "string")
        if (Ae.test(t)) t = parseFloat(t);
        else return t;
      const n = q_(t, e.target.x),
        i = q_(t, e.target.y);
      return `${n}% ${i}%`;
    },
  },
  ZL = {
    correct: (t, { treeScale: e, projectionDelta: n }) => {
      const i = t,
        r = ts.parse(t);
      if (r.length > 5) return i;
      const s = ts.createTransformer(t),
        a = typeof r[0] != "number" ? 1 : 0,
        o = n.x.scale * e.x,
        l = n.y.scale * e.y;
      (r[0 + a] /= o), (r[1 + a] /= l);
      const c = Mt(o, l, 0.5);
      return (
        typeof r[2 + a] == "number" && (r[2 + a] /= c),
        typeof r[3 + a] == "number" && (r[3 + a] /= c),
        s(r)
      );
    },
  };
class KL extends O.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: n,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    wP(JL),
      s &&
        (n.group && n.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (Wu.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: n,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      a = i.projection;
    return (
      a &&
        ((a.isPresent = s),
        r || e.layoutDependency !== n || n === void 0
          ? a.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? a.promote()
            : a.relegate() ||
              at.postRender(() => {
                const o = a.getStack();
                (!o || !o.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      Xg.postRender(() => {
        !e.currentAnimation && e.isLead() && this.safeToRemove();
      }));
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: n,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      n && n.group && n.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function uT(t) {
  const [e, n] = $E(),
    i = O.useContext(jg);
  return _.jsx(KL, {
    ...t,
    layoutGroup: i,
    switchLayoutGroup: O.useContext(JE),
    isPresent: e,
    safeToRemove: n,
  });
}
const JL = {
  borderRadius: {
    ...Wo,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius",
    ],
  },
  borderTopLeftRadius: Wo,
  borderTopRightRadius: Wo,
  borderBottomLeftRadius: Wo,
  borderBottomRightRadius: Wo,
  boxShadow: ZL,
};
function QL(t, e, n) {
  const i = dn(t) ? t : Ii(t);
  return i.start(xv("", i, e, n)), i.animation;
}
function eN(t) {
  return t instanceof SVGElement && t.tagName !== "svg";
}
const tN = (t, e) => t.depth - e.depth;
class nN {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    ov(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    lv(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(tN),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function iN(t, e) {
  const n = Bi.now(),
    i = ({ timestamp: r }) => {
      const s = r - n;
      s >= e && (Mi(i), t(s - e));
    };
  return at.read(i, !0), () => Mi(i);
}
const dT = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  rN = dT.length,
  Y_ = (t) => (typeof t == "string" ? parseFloat(t) : t),
  Z_ = (t) => typeof t == "number" || Ae.test(t);
function sN(t, e, n, i, r, s) {
  r
    ? ((t.opacity = Mt(0, n.opacity !== void 0 ? n.opacity : 1, aN(i))),
      (t.opacityExit = Mt(e.opacity !== void 0 ? e.opacity : 1, 0, oN(i))))
    : s &&
      (t.opacity = Mt(
        e.opacity !== void 0 ? e.opacity : 1,
        n.opacity !== void 0 ? n.opacity : 1,
        i
      ));
  for (let a = 0; a < rN; a++) {
    const o = `border${dT[a]}Radius`;
    let l = K_(e, o),
      c = K_(n, o);
    if (l === void 0 && c === void 0) continue;
    l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || Z_(l) === Z_(c)
        ? ((t[o] = Math.max(Mt(Y_(l), Y_(c), i), 0)),
          (Fi.test(c) || Fi.test(l)) && (t[o] += "%"))
        : (t[o] = c);
  }
  (e.rotate || n.rotate) && (t.rotate = Mt(e.rotate || 0, n.rotate || 0, i));
}
function K_(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const aN = hT(0, 0.5, R1),
  oN = hT(0.5, 0.95, yn);
function hT(t, e, n) {
  return (i) => (i < t ? 0 : i > e ? 1 : n(Ks(t, e, i)));
}
function J_(t, e) {
  (t.min = e.min), (t.max = e.max);
}
function Zn(t, e) {
  J_(t.x, e.x), J_(t.y, e.y);
}
function Q_(t, e) {
  (t.translate = e.translate),
    (t.scale = e.scale),
    (t.originPoint = e.originPoint),
    (t.origin = e.origin);
}
function ey(t, e, n, i, r) {
  return (
    (t -= e), (t = Ad(t, 1 / n, i)), r !== void 0 && (t = Ad(t, 1 / r, i)), t
  );
}
function lN(t, e = 0, n = 1, i = 0.5, r, s = t, a = t) {
  if (
    (Fi.test(e) &&
      ((e = parseFloat(e)), (e = Mt(a.min, a.max, e / 100) - a.min)),
    typeof e != "number")
  )
    return;
  let o = Mt(s.min, s.max, i);
  t === s && (o -= e),
    (t.min = ey(t.min, e, n, o, r)),
    (t.max = ey(t.max, e, n, o, r));
}
function ty(t, e, [n, i, r], s, a) {
  lN(t, e[n], e[i], e[r], e.scale, s, a);
}
const cN = ["x", "scaleX", "originX"],
  uN = ["y", "scaleY", "originY"];
function ny(t, e, n, i) {
  ty(t.x, e, cN, n ? n.x : void 0, i ? i.x : void 0),
    ty(t.y, e, uN, n ? n.y : void 0, i ? i.y : void 0);
}
function iy(t) {
  return t.translate === 0 && t.scale === 1;
}
function fT(t) {
  return iy(t.x) && iy(t.y);
}
function ry(t, e) {
  return t.min === e.min && t.max === e.max;
}
function dN(t, e) {
  return ry(t.x, e.x) && ry(t.y, e.y);
}
function sy(t, e) {
  return (
    Math.round(t.min) === Math.round(e.min) &&
    Math.round(t.max) === Math.round(e.max)
  );
}
function pT(t, e) {
  return sy(t.x, e.x) && sy(t.y, e.y);
}
function ay(t) {
  return Wn(t.x) / Wn(t.y);
}
function oy(t, e) {
  return (
    t.translate === e.translate &&
    t.scale === e.scale &&
    t.originPoint === e.originPoint
  );
}
class hN {
  constructor() {
    this.members = [];
  }
  add(e) {
    ov(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (lv(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((r) => e === r);
    if (n === 0) return !1;
    let i;
    for (let r = n; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, n) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        n && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: i } = e;
      n.onExitComplete && n.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function fN(t, e, n) {
  let i = "";
  const r = t.x.translate / e.x,
    s = t.y.translate / e.y,
    a = (n == null ? void 0 : n.z) || 0;
  if (
    ((r || s || a) && (i = `translate3d(${r}px, ${s}px, ${a}px) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    n)
  ) {
    const {
      transformPerspective: c,
      rotate: u,
      rotateX: d,
      rotateY: h,
      skewX: p,
      skewY: v,
    } = n;
    c && (i = `perspective(${c}px) ${i}`),
      u && (i += `rotate(${u}deg) `),
      d && (i += `rotateX(${d}deg) `),
      h && (i += `rotateY(${h}deg) `),
      p && (i += `skewX(${p}deg) `),
      v && (i += `skewY(${v}deg) `);
  }
  const o = t.x.scale * e.x,
    l = t.y.scale * e.y;
  return (o !== 1 || l !== 1) && (i += `scale(${o}, ${l})`), i || "none";
}
const As = {
    type: "projectionFrame",
    totalNodes: 0,
    resolvedTargetDeltas: 0,
    recalculatedProjection: 0,
  },
  ol = typeof window < "u" && window.MotionDebug !== void 0,
  pf = ["", "X", "Y", "Z"],
  pN = {
    visibility: "hidden",
  },
  ly = 1e3;
let mN = 0;
function mf(t, e, n, i) {
  const { latestValues: r } = e;
  r[t] && ((n[t] = r[t]), e.setStaticValue(t, 0), i && (i[t] = 0));
}
function mT(t) {
  if (((t.hasCheckedOptimisedAppear = !0), t.root === t)) return;
  const { visualElement: e } = t.options;
  if (!e) return;
  const n = w1(e);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: r, layoutId: s } = t.options;
    window.MotionCancelOptimisedAnimation(n, "transform", at, !(r || s));
  }
  const { parent: i } = t;
  i && !i.hasCheckedOptimisedAppear && mT(i);
}
function gT({
  attachResizeListener: t,
  defaultParent: e,
  measureScroll: n,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(a = {}, o = e == null ? void 0 : e()) {
      (this.id = mN++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.hasCheckedOptimisedAppear = !1),
        (this.treeScale = {
          x: 1,
          y: 1,
        }),
        (this.eventHandlers = new Map()),
        (this.hasTreeAnimated = !1),
        (this.updateScheduled = !1),
        (this.scheduleUpdate = () => this.update()),
        (this.projectionUpdateScheduled = !1),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (this.projectionUpdateScheduled = !1),
            ol &&
              (As.totalNodes =
                As.resolvedTargetDeltas =
                As.recalculatedProjection =
                  0),
            this.nodes.forEach(_N),
            this.nodes.forEach(EN),
            this.nodes.forEach(TN),
            this.nodes.forEach(yN),
            ol && window.MotionDebug.record(As);
        }),
        (this.resolvedRelativeTargetAt = 0),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.latestValues = a),
        (this.root = o ? o.root || o : this),
        (this.path = o ? [...o.path, o] : []),
        (this.parent = o),
        (this.depth = o ? o.depth + 1 : 0);
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new nN());
    }
    addEventListener(a, o) {
      return (
        this.eventHandlers.has(a) || this.eventHandlers.set(a, new cv()),
        this.eventHandlers.get(a).add(o)
      );
    }
    notifyListeners(a, ...o) {
      const l = this.eventHandlers.get(a);
      l && l.notify(...o);
    }
    hasListeners(a) {
      return this.eventHandlers.has(a);
    }
    mount(a, o = this.root.hasTreeAnimated) {
      if (this.instance) return;
      (this.isSVG = eN(a)), (this.instance = a);
      const { layoutId: l, layout: c, visualElement: u } = this.options;
      if (
        (u && !u.current && u.mount(a),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        o && (c || l) && (this.isLayoutDirty = !0),
        t)
      ) {
        let d;
        const h = () => (this.root.updateBlockedByResize = !1);
        t(a, () => {
          (this.root.updateBlockedByResize = !0),
            d && d(),
            (d = iN(h, 250)),
            Wu.hasAnimatedSinceResize &&
              ((Wu.hasAnimatedSinceResize = !1), this.nodes.forEach(uy));
        });
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          u &&
          (l || c) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: h,
              hasRelativeTargetChanged: p,
              layout: v,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const x =
                  this.options.transition || u.getDefaultTransition() || RN,
                { onLayoutAnimationStart: m, onLayoutAnimationComplete: f } =
                  u.getProps(),
                y = !this.targetLayout || !pT(this.targetLayout, v) || p,
                g = !h && p;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                g ||
                (h && (y || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, g);
                const S = {
                  ...iv(x, "layout"),
                  onPlay: m,
                  onComplete: f,
                };
                (u.shouldReduceMotion || this.options.layoutRoot) &&
                  ((S.delay = 0), (S.type = !1)),
                  this.startAnimation(S);
              } else
                h || uy(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = v;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const a = this.getStack();
      a && a.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Mi(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(MN),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: a } = this.options;
      return a && a.getProps().transformTemplate;
    }
    willUpdate(a = !0) {
      if (((this.root.hasTreeAnimated = !0), this.root.isUpdateBlocked())) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (window.MotionCancelOptimisedAnimation &&
          !this.hasCheckedOptimisedAppear &&
          mT(this),
        !this.root.isUpdating && this.root.startUpdate(),
        this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let u = 0; u < this.path.length; u++) {
        const d = this.path[u];
        (d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: o, layout: l } = this.options;
      if (o === void 0 && !l) return;
      const c = this.getTransformTemplate();
      (this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        a && this.notifyListeners("willUpdate");
    }
    update() {
      if (((this.updateScheduled = !1), this.isUpdateBlocked())) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(cy);
        return;
      }
      this.isUpdating || this.nodes.forEach(SN),
        (this.isUpdating = !1),
        this.nodes.forEach(wN),
        this.nodes.forEach(gN),
        this.nodes.forEach(vN),
        this.clearAllSnapshots();
      const o = Bi.now();
      (Xt.delta = ji(0, 1e3 / 60, o - Xt.timestamp)),
        (Xt.timestamp = o),
        (Xt.isProcessing = !0),
        sf.update.process(Xt),
        sf.preRender.process(Xt),
        sf.render.process(Xt),
        (Xt.isProcessing = !1);
    }
    didUpdate() {
      this.updateScheduled ||
        ((this.updateScheduled = !0), Xg.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(xN), this.sharedNodes.forEach(bN);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled ||
        ((this.projectionUpdateScheduled = !0),
        at.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      at.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const a = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = Nt()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: o } = this.options;
      o &&
        o.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          a ? a.layoutBox : void 0
        );
    }
    updateScroll(a = "measure") {
      let o = !!(this.options.layoutScroll && this.instance);
      if (
        (this.scroll &&
          this.scroll.animationId === this.root.animationId &&
          this.scroll.phase === a &&
          (o = !1),
        o)
      ) {
        const l = i(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: a,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l,
        };
      }
    }
    resetTransform() {
      if (!r) return;
      const a =
          this.isLayoutDirty ||
          this.shouldResetTransform ||
          this.options.alwaysMeasureLayout,
        o = this.projectionDelta && !fT(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        u = c !== this.prevTransformTemplateValue;
      a &&
        (o || bs(this.latestValues) || u) &&
        (r(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(a = !0) {
      const o = this.measurePageBox();
      let l = this.removeElementScroll(o);
      return (
        a && (l = this.removeTransform(l)),
        PN(l),
        {
          animationId: this.root.animationId,
          measuredBox: o,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      var a;
      const { visualElement: o } = this.options;
      if (!o) return Nt();
      const l = o.measureViewportBox();
      if (
        !(
          ((a = this.scroll) === null || a === void 0 ? void 0 : a.wasRoot) ||
          this.path.some(LN)
        )
      ) {
        const { scroll: u } = this.root;
        u && (Wa(l.x, u.offset.x), Wa(l.y, u.offset.y));
      }
      return l;
    }
    removeElementScroll(a) {
      var o;
      const l = Nt();
      if (
        (Zn(l, a), !((o = this.scroll) === null || o === void 0) && o.wasRoot)
      )
        return l;
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c],
          { scroll: d, options: h } = u;
        u !== this.root &&
          d &&
          h.layoutScroll &&
          (d.wasRoot && Zn(l, a), Wa(l.x, d.offset.x), Wa(l.y, d.offset.y));
      }
      return l;
    }
    applyTransform(a, o = !1) {
      const l = Nt();
      Zn(l, a);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        !o &&
          u.options.layoutScroll &&
          u.scroll &&
          u !== u.root &&
          $a(l, {
            x: -u.scroll.offset.x,
            y: -u.scroll.offset.y,
          }),
          bs(u.latestValues) && $a(l, u.latestValues);
      }
      return bs(this.latestValues) && $a(l, this.latestValues), l;
    }
    removeTransform(a) {
      const o = Nt();
      Zn(o, a);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !bs(c.latestValues)) continue;
        pm(c.latestValues) && c.updateSnapshot();
        const u = Nt(),
          d = c.measurePageBox();
        Zn(u, d),
          ny(o, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u);
      }
      return bs(this.latestValues) && ny(o, this.latestValues), o;
    }
    setTargetDelta(a) {
      (this.targetDelta = a),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(a) {
      this.options = {
        ...this.options,
        ...a,
        crossfade: a.crossfade !== void 0 ? a.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent &&
        this.relativeParent.resolvedRelativeTargetAt !== Xt.timestamp &&
        this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(a = !1) {
      var o;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (
        !(
          a ||
          (c && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget ||
          this.root.updateBlockedByResize
        )
      )
        return;
      const { layout: d, layoutId: h } = this.options;
      if (!(!this.layout || !(d || h))) {
        if (
          ((this.resolvedRelativeTargetAt = Xt.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const p = this.getClosestProjectingParent();
          p && p.layout && this.animationProgress !== 1
            ? ((this.relativeParent = p),
              this.forceRelativeParentToResolveTarget(),
              (this.relativeTarget = Nt()),
              (this.relativeTargetOrigin = Nt()),
              Tl(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                p.layout.layoutBox
              ),
              Zn(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Nt()), (this.targetWithTransforms = Nt())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.forceRelativeParentToResolveTarget(),
                kL(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : Zn(this.target, this.layout.layoutBox),
                oT(this.target, this.targetDelta))
              : Zn(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const p = this.getClosestProjectingParent();
            p &&
            !!p.resumingFrom == !!this.resumingFrom &&
            !p.options.layoutScroll &&
            p.target &&
            this.animationProgress !== 1
              ? ((this.relativeParent = p),
                this.forceRelativeParentToResolveTarget(),
                (this.relativeTarget = Nt()),
                (this.relativeTargetOrigin = Nt()),
                Tl(this.relativeTargetOrigin, this.target, p.target),
                Zn(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          ol && As.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          pm(this.parent.latestValues) ||
          aT(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var a;
      const o = this.getLead(),
        l = !!this.resumingFrom || this !== o;
      let c = !0;
      if (
        ((this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty)) &&
          (c = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (c = !1),
        this.resolvedRelativeTargetAt === Xt.timestamp && (c = !1),
        c)
      )
        return;
      const { layout: u, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(u || d))
      )
        return;
      Zn(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x,
        p = this.treeScale.y;
      HL(this.layoutCorrected, this.treeScale, this.path, l),
        o.layout &&
          !o.target &&
          (this.treeScale.x !== 1 || this.treeScale.y !== 1) &&
          ((o.target = o.layout.layoutBox), (o.targetWithTransforms = Nt()));
      const { target: v } = o;
      if (!v) {
        this.prevProjectionDelta &&
          (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta
        ? this.createProjectionDeltas()
        : (Q_(this.prevProjectionDelta.x, this.projectionDelta.x),
          Q_(this.prevProjectionDelta.y, this.projectionDelta.y)),
        El(this.projectionDelta, this.layoutCorrected, v, this.latestValues),
        (this.treeScale.x !== h ||
          this.treeScale.y !== p ||
          !oy(this.projectionDelta.x, this.prevProjectionDelta.x) ||
          !oy(this.projectionDelta.y, this.prevProjectionDelta.y)) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", v)),
        ol && As.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(a = !0) {
      var o;
      if (
        ((o = this.options.visualElement) === null ||
          o === void 0 ||
          o.scheduleRender(),
        a)
      ) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      (this.prevProjectionDelta = Ga()),
        (this.projectionDelta = Ga()),
        (this.projectionDeltaWithTransform = Ga());
    }
    setAnimationOrigin(a, o = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        u = {
          ...this.latestValues,
        },
        d = Ga();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !o);
      const h = Nt(),
        p = l ? l.source : void 0,
        v = this.layout ? this.layout.source : void 0,
        x = p !== v,
        m = this.getStack(),
        f = !m || m.members.length <= 1,
        y = !!(x && !f && this.options.crossfade === !0 && !this.path.some(CN));
      this.animationProgress = 0;
      let g;
      (this.mixTargetDelta = (S) => {
        const T = S / 1e3;
        dy(d.x, a.x, T),
          dy(d.y, a.y, T),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (Tl(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            AN(this.relativeTarget, this.relativeTargetOrigin, h, T),
            g && dN(this.relativeTarget, g) && (this.isProjectionDirty = !1),
            g || (g = Nt()),
            Zn(g, this.relativeTarget)),
          x &&
            ((this.animationValues = u), sN(u, c, this.latestValues, T, y, f)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = T);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(a) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Mi(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = at.update(() => {
          (Wu.hasAnimatedSinceResize = !0),
            (this.currentAnimation = QL(0, ly, {
              ...a,
              onUpdate: (o) => {
                this.mixTargetDelta(o), a.onUpdate && a.onUpdate(o);
              },
              onComplete: () => {
                a.onComplete && a.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const a = this.getStack();
      a && a.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(ly),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const a = this.getLead();
      let {
        targetWithTransforms: o,
        target: l,
        layout: c,
        latestValues: u,
      } = a;
      if (!(!o || !l || !c)) {
        if (
          this !== a &&
          this.layout &&
          c &&
          vT(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || Nt();
          const d = Wn(this.layout.layoutBox.x);
          (l.x.min = a.target.x.min), (l.x.max = l.x.min + d);
          const h = Wn(this.layout.layoutBox.y);
          (l.y.min = a.target.y.min), (l.y.max = l.y.min + h);
        }
        Zn(o, l),
          $a(o, u),
          El(this.projectionDeltaWithTransform, this.layoutCorrected, o, u);
      }
    }
    registerSharedNode(a, o) {
      this.sharedNodes.has(a) || this.sharedNodes.set(a, new hN()),
        this.sharedNodes.get(a).add(o);
      const c = o.options.initialPromotionConfig;
      o.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity
            ? c.shouldPreserveFollowOpacity(o)
            : void 0,
      });
    }
    isLead() {
      const a = this.getStack();
      return a ? a.lead === this : !0;
    }
    getLead() {
      var a;
      const { layoutId: o } = this.options;
      return o
        ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var a;
      const { layoutId: o } = this.options;
      return o
        ? (a = this.getStack()) === null || a === void 0
          ? void 0
          : a.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: a } = this.options;
      if (a) return this.root.sharedNodes.get(a);
    }
    promote({ needsReset: a, transition: o, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l),
        a && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        o &&
          this.setOptions({
            transition: o,
          });
    }
    relegate() {
      const a = this.getStack();
      return a ? a.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: a } = this.options;
      if (!a) return;
      let o = !1;
      const { latestValues: l } = a;
      if (
        ((l.z ||
          l.rotate ||
          l.rotateX ||
          l.rotateY ||
          l.rotateZ ||
          l.skewX ||
          l.skewY) &&
          (o = !0),
        !o)
      )
        return;
      const c = {};
      l.z && mf("z", a, c, this.animationValues);
      for (let u = 0; u < pf.length; u++)
        mf(`rotate${pf[u]}`, a, c, this.animationValues),
          mf(`skew${pf[u]}`, a, c, this.animationValues);
      a.render();
      for (const u in c)
        a.setStaticValue(u, c[u]),
          this.animationValues && (this.animationValues[u] = c[u]);
      a.scheduleRender();
    }
    getProjectionStyles(a) {
      var o, l;
      if (!this.instance || this.isSVG) return;
      if (!this.isVisible) return pN;
      const c = {
          visibility: "",
        },
        u = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (c.opacity = ""),
          (c.pointerEvents = Hu(a == null ? void 0 : a.pointerEvents) || ""),
          (c.transform = u ? u(this.latestValues, "") : "none"),
          c
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const x = {};
        return (
          this.options.layoutId &&
            ((x.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (x.pointerEvents = Hu(a == null ? void 0 : a.pointerEvents) || "")),
          this.hasProjected &&
            !bs(this.latestValues) &&
            ((x.transform = u ? u({}, "") : "none"), (this.hasProjected = !1)),
          x
        );
      }
      const h = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(),
        (c.transform = fN(
          this.projectionDeltaWithTransform,
          this.treeScale,
          h
        )),
        u && (c.transform = u(h, c.transform));
      const { x: p, y: v } = this.projectionDelta;
      (c.transformOrigin = `${p.origin * 100}% ${v.origin * 100}% 0`),
        d.animationValues
          ? (c.opacity =
              d === this
                ? (l =
                    (o = h.opacity) !== null && o !== void 0
                      ? o
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : h.opacityExit)
          : (c.opacity =
              d === this
                ? h.opacity !== void 0
                  ? h.opacity
                  : ""
                : h.opacityExit !== void 0
                ? h.opacityExit
                : 0);
      for (const x in wd) {
        if (h[x] === void 0) continue;
        const { correct: m, applyTo: f } = wd[x],
          y = c.transform === "none" ? h[x] : m(h[x], d);
        if (f) {
          const g = f.length;
          for (let S = 0; S < g; S++) c[f[S]] = y;
        } else c[x] = y;
      }
      return (
        this.options.layoutId &&
          (c.pointerEvents =
            d === this
              ? Hu(a == null ? void 0 : a.pointerEvents) || ""
              : "none"),
        c
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((a) => {
        var o;
        return (o = a.currentAnimation) === null || o === void 0
          ? void 0
          : o.stop();
      }),
        this.root.nodes.forEach(cy),
        this.root.sharedNodes.clear();
    }
  };
}
function gN(t) {
  t.updateLayout();
}
function vN(t) {
  var e;
  const n =
    ((e = t.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    t.snapshot;
  if (t.isLead() && t.layout && n && t.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = t.layout,
      { animationType: s } = t.options,
      a = n.source !== t.layout.source;
    s === "size"
      ? Jn((d) => {
          const h = a ? n.measuredBox[d] : n.layoutBox[d],
            p = Wn(h);
          (h.min = i[d].min), (h.max = h.min + p);
        })
      : vT(s, n.layoutBox, i) &&
        Jn((d) => {
          const h = a ? n.measuredBox[d] : n.layoutBox[d],
            p = Wn(i[d]);
          (h.max = h.min + p),
            t.relativeTarget &&
              !t.currentAnimation &&
              ((t.isProjectionDirty = !0),
              (t.relativeTarget[d].max = t.relativeTarget[d].min + p));
        });
    const o = Ga();
    El(o, i, n.layoutBox);
    const l = Ga();
    a ? El(l, t.applyTransform(r, !0), n.measuredBox) : El(l, i, n.layoutBox);
    const c = !fT(o);
    let u = !1;
    if (!t.resumeFrom) {
      const d = t.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: h, layout: p } = d;
        if (h && p) {
          const v = Nt();
          Tl(v, n.layoutBox, h.layoutBox);
          const x = Nt();
          Tl(x, i, p.layoutBox),
            pT(v, x) || (u = !0),
            d.options.layoutRoot &&
              ((t.relativeTarget = x),
              (t.relativeTargetOrigin = v),
              (t.relativeParent = d));
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: i,
      snapshot: n,
      delta: l,
      layoutDelta: o,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: u,
    });
  } else if (t.isLead()) {
    const { onExitComplete: i } = t.options;
    i && i();
  }
  t.options.transition = void 0;
}
function _N(t) {
  ol && As.totalNodes++,
    t.parent &&
      (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty),
      t.isSharedProjectionDirty ||
        (t.isSharedProjectionDirty = !!(
          t.isProjectionDirty ||
          t.parent.isProjectionDirty ||
          t.parent.isSharedProjectionDirty
        )),
      t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function yN(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function xN(t) {
  t.clearSnapshot();
}
function cy(t) {
  t.clearMeasurements();
}
function SN(t) {
  t.isLayoutDirty = !1;
}
function wN(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    t.resetTransform();
}
function uy(t) {
  t.finishAnimation(),
    (t.targetDelta = t.relativeTarget = t.target = void 0),
    (t.isProjectionDirty = !0);
}
function EN(t) {
  t.resolveTargetDelta();
}
function TN(t) {
  t.calcProjection();
}
function MN(t) {
  t.resetSkewAndRotation();
}
function bN(t) {
  t.removeLeadSnapshot();
}
function dy(t, e, n) {
  (t.translate = Mt(e.translate, 0, n)),
    (t.scale = Mt(e.scale, 1, n)),
    (t.origin = e.origin),
    (t.originPoint = e.originPoint);
}
function hy(t, e, n, i) {
  (t.min = Mt(e.min, n.min, i)), (t.max = Mt(e.max, n.max, i));
}
function AN(t, e, n, i) {
  hy(t.x, e.x, n.x, i), hy(t.y, e.y, n.y, i);
}
function CN(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const RN = {
    duration: 0.45,
    ease: [0.4, 0, 0.1, 1],
  },
  fy = (t) =>
    typeof navigator < "u" &&
    navigator.userAgent &&
    navigator.userAgent.toLowerCase().includes(t),
  py = fy("applewebkit/") && !fy("chrome/") ? Math.round : yn;
function my(t) {
  (t.min = py(t.min)), (t.max = py(t.max));
}
function PN(t) {
  my(t.x), my(t.y);
}
function vT(t, e, n) {
  return (
    t === "position" || (t === "preserve-aspect" && !DL(ay(e), ay(n), 0.2))
  );
}
function LN(t) {
  var e;
  return (
    t !== t.root &&
    ((e = t.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
  );
}
const NN = gT({
    attachResizeListener: (t, e) => Kl(t, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  gf = {
    current: void 0,
  },
  _T = gT({
    measureScroll: (t) => ({
      x: t.scrollLeft,
      y: t.scrollTop,
    }),
    defaultParent: () => {
      if (!gf.current) {
        const t = new NN({});
        t.mount(window),
          t.setOptions({
            layoutScroll: !0,
          }),
          (gf.current = t);
      }
      return gf.current;
    },
    resetTransform: (t, e) => {
      t.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed",
  }),
  DN = {
    pan: {
      Feature: YL,
    },
    drag: {
      Feature: qL,
      ProjectionNode: _T,
      MeasureLayout: uT,
    },
  };
function gy(t, e, n) {
  const { props: i } = t;
  t.animationState &&
    i.whileHover &&
    t.animationState.setActive("whileHover", n === "Start");
  const r = "onHover" + n,
    s = i[r];
  s && at.postRender(() => s(e, Ec(e)));
}
class kN extends ds {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = UP(
        e,
        (n) => (gy(this.node, n, "Start"), (i) => gy(this.node, i, "End"))
      ));
  }
  unmount() {}
}
class IN extends ds {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = wc(
      Kl(this.node.current, "focus", () => this.onFocus()),
      Kl(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
function vy(t, e, n) {
  const { props: i } = t;
  t.animationState &&
    i.whileTap &&
    t.animationState.setActive("whileTap", n === "Start");
  const r = "onTap" + (n === "End" ? "" : n),
    s = i[r];
  s && at.postRender(() => s(e, Ec(e)));
}
class UN extends ds {
  mount() {
    const { current: e } = this.node;
    e &&
      (this.unmount = zP(
        e,
        (n) => (
          vy(this.node, n, "Start"),
          (i, { success: r }) => vy(this.node, i, r ? "End" : "Cancel")
        ),
        {
          useGlobalTarget: this.node.props.globalTapTarget,
        }
      ));
  }
  unmount() {}
}
const gm = new WeakMap(),
  vf = new WeakMap(),
  ON = (t) => {
    const e = gm.get(t.target);
    e && e(t);
  },
  FN = (t) => {
    t.forEach(ON);
  };
function BN({ root: t, ...e }) {
  const n = t || document;
  vf.has(n) || vf.set(n, {});
  const i = vf.get(n),
    r = JSON.stringify(e);
  return (
    i[r] ||
      (i[r] = new IntersectionObserver(FN, {
        root: t,
        ...e,
      })),
    i[r]
  );
}
function zN(t, e, n) {
  const i = BN(e);
  return (
    gm.set(t, n),
    i.observe(t),
    () => {
      gm.delete(t), i.unobserve(t);
    }
  );
}
const jN = {
  some: 0,
  all: 1,
};
class VN extends ds {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: n, margin: i, amount: r = "some", once: s } = e,
      a = {
        root: n ? n.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : jN[r],
      },
      o = (l) => {
        const { isIntersecting: c } = l;
        if (
          this.isInView === c ||
          ((this.isInView = c), s && !c && this.hasEnteredView)
        )
          return;
        c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", c);
        const { onViewportEnter: u, onViewportLeave: d } = this.node.getProps(),
          h = c ? u : d;
        h && h(l);
      };
    return zN(this.node.current, a, o);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(HN(e, n)) && this.startObserver();
  }
  unmount() {}
}
function HN({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const GN = {
    inView: {
      Feature: VN,
    },
    tap: {
      Feature: UN,
    },
    focus: {
      Feature: IN,
    },
    hover: {
      Feature: kN,
    },
  },
  WN = {
    layout: {
      ProjectionNode: _T,
      MeasureLayout: uT,
    },
  },
  vm = {
    current: null,
  },
  yT = {
    current: !1,
  };
function $N() {
  if (((yT.current = !0), !!Vg))
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (vm.current = t.matches);
      t.addListener(e), e();
    } else vm.current = !1;
}
const XN = [...H1, cn, ts],
  qN = (t) => XN.find(V1(t)),
  _y = new WeakMap();
function YN(t, e, n) {
  for (const i in e) {
    const r = e[i],
      s = n[i];
    if (dn(r)) t.addValue(i, r);
    else if (dn(s))
      t.addValue(
        i,
        Ii(r, {
          owner: t,
        })
      );
    else if (s !== r)
      if (t.hasValue(i)) {
        const a = t.getValue(i);
        a.liveStyle === !0 ? a.jump(r) : a.hasAnimated || a.set(r);
      } else {
        const a = t.getStaticValue(i);
        t.addValue(
          i,
          Ii(a !== void 0 ? a : r, {
            owner: t,
          })
        );
      }
  }
  for (const i in n) e[i] === void 0 && t.removeValue(i);
  return e;
}
const yy = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete",
];
class ZN {
  scrapeMotionValuesFromProps(e, n, i) {
    return {};
  }
  constructor(
    {
      parent: e,
      props: n,
      presenceContext: i,
      reducedMotionConfig: r,
      blockInitialAnimation: s,
      visualState: a,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.KeyframeResolver = gv),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.renderScheduledAt = 0),
      (this.scheduleRender = () => {
        const p = Bi.now();
        this.renderScheduledAt < p &&
          ((this.renderScheduledAt = p), at.render(this.render, !1, !0));
      });
    const { latestValues: l, renderState: c, onUpdate: u } = a;
    (this.onUpdate = u),
      (this.latestValues = l),
      (this.baseTarget = {
        ...l,
      }),
      (this.initialValues = n.initial
        ? {
            ...l,
          }
        : {}),
      (this.renderState = c),
      (this.parent = e),
      (this.props = n),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.blockInitialAnimation = !!s),
      (this.isControllingVariants = dh(n)),
      (this.isVariantNode = ZE(n)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: d, ...h } = this.scrapeMotionValuesFromProps(
      n,
      {},
      this
    );
    for (const p in h) {
      const v = h[p];
      l[p] !== void 0 && dn(v) && v.set(l[p], !1);
    }
  }
  mount(e) {
    (this.current = e),
      _y.set(e, this),
      this.projection && !this.projection.instance && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((n, i) => this.bindToMotionValue(i, n)),
      yT.current || $N(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : vm.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    _y.delete(this.current),
      this.projection && this.projection.unmount(),
      Mi(this.notifyUpdate),
      Mi(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.valueSubscriptions.clear(),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) {
      const n = this.features[e];
      n && (n.unmount(), (n.isMounted = !1));
    }
    this.current = null;
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const i = aa.has(e),
      r = n.on("change", (o) => {
        (this.latestValues[e] = o),
          this.props.onUpdate && at.preRender(this.notifyUpdate),
          i && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = n.on("renderRequest", this.scheduleRender);
    let a;
    window.MotionCheckAppearSync &&
      (a = window.MotionCheckAppearSync(this, e, n)),
      this.valueSubscriptions.set(e, () => {
        r(), s(), a && a(), n.owner && n.stop();
      });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in po) {
      const n = po[e];
      if (!n) continue;
      const { isEnabled: i, Feature: r } = n;
      if (
        (!this.features[e] &&
          r &&
          i(this.props) &&
          (this.features[e] = new r(this)),
        this.features[e])
      ) {
        const s = this.features[e];
        s.isMounted ? s.update() : (s.mount(), (s.isMounted = !0));
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Nt();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = n);
    for (let i = 0; i < yy.length; i++) {
      const r = yy[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = "on" + r,
        a = e[s];
      a && (this.propEventSubscriptions[r] = this.on(r, a));
    }
    (this.prevMotionValues = YN(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps, this),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue(),
      this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return (
        n.variantChildren && n.variantChildren.add(e),
        () => n.variantChildren.delete(e)
      );
  }
  addValue(e, n) {
    const i = this.values.get(e);
    n !== i &&
      (i && this.removeValue(e),
      this.bindToMotionValue(e, n),
      this.values.set(e, n),
      (this.latestValues[e] = n.get()));
  }
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        n !== void 0 &&
        ((i = Ii(n === null ? void 0 : n, {
          owner: this,
        })),
        this.addValue(e, i)),
      i
    );
  }
  readValue(e, n) {
    var i;
    let r =
      this.latestValues[e] !== void 0 || !this.current
        ? this.latestValues[e]
        : (i = this.getBaseTargetFromProps(this.props, e)) !== null &&
          i !== void 0
        ? i
        : this.readValueFromInstance(this.current, e, this.options);
    return (
      r != null &&
        (typeof r == "string" && (z1(r) || L1(r))
          ? (r = parseFloat(r))
          : !qN(r) && ts.test(n) && (r = O1(e, n)),
        this.setBaseTarget(e, dn(r) ? r.get() : r)),
      dn(r) ? r.get() : r
    );
  }
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  getBaseTarget(e) {
    var n;
    const { initial: i } = this.props;
    let r;
    if (typeof i == "string" || typeof i == "object") {
      const a = Yg(
        this.props,
        i,
        (n = this.presenceContext) === null || n === void 0 ? void 0 : n.custom
      );
      a && (r = a[e]);
    }
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !dn(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new cv()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
}
class xT extends ZN {
  constructor() {
    super(...arguments), (this.KeyframeResolver = G1);
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    return e.style ? e.style[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: i }) {
    delete n[e], delete i[e];
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    dn(e) &&
      (this.childSubscription = e.on("change", (n) => {
        this.current && (this.current.textContent = `${n}`);
      }));
  }
}
function KN(t) {
  return window.getComputedStyle(t);
}
class JN extends xT {
  constructor() {
    super(...arguments), (this.type = "html"), (this.renderInstance = s1);
  }
  readValueFromInstance(e, n) {
    if (aa.has(n)) {
      const i = mv(n);
      return (i && i.default) || 0;
    } else {
      const i = KN(e),
        r = (n1(n) ? i.getPropertyValue(n) : i[n]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return lT(e, n);
  }
  build(e, n, i) {
    Jg(e, n, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n, i) {
    return nv(e, n, i);
  }
}
class QN extends xT {
  constructor() {
    super(...arguments),
      (this.type = "svg"),
      (this.isSVGTag = !1),
      (this.measureInstanceViewportBox = Nt);
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (aa.has(n)) {
      const i = mv(n);
      return (i && i.default) || 0;
    }
    return (n = a1.has(n) ? n : $g(n)), e.getAttribute(n);
  }
  scrapeMotionValuesFromProps(e, n, i) {
    return c1(e, n, i);
  }
  build(e, n, i) {
    Qg(e, n, this.isSVGTag, i.transformTemplate);
  }
  renderInstance(e, n, i, r) {
    o1(e, n, i, r);
  }
  mount(e) {
    (this.isSVGTag = tv(e.tagName)), super.mount(e);
  }
}
const eD = (t, e) =>
    qg(t)
      ? new QN(e)
      : new JN(e, {
          allowProjection: t !== O.Fragment,
        }),
  tD = LP(
    {
      ...TL,
      ...GN,
      ...DN,
      ...WN,
    },
    eD
  ),
  Me = $R(tD);
function ST(t, e) {
  let n;
  const i = () => {
    const { currentTime: r } = e,
      a = (r === null ? 0 : r.value) / 100;
    n !== a && t(a), (n = a);
  };
  return at.update(i, !0), () => Mi(i);
}
const $u = new WeakMap();
let Ar;
function nD(t, e) {
  if (e) {
    const { inlineSize: n, blockSize: i } = e[0];
    return {
      width: n,
      height: i,
    };
  } else
    return t instanceof SVGElement && "getBBox" in t
      ? t.getBBox()
      : {
          width: t.offsetWidth,
          height: t.offsetHeight,
        };
}
function iD({ target: t, contentRect: e, borderBoxSize: n }) {
  var i;
  (i = $u.get(t)) === null ||
    i === void 0 ||
    i.forEach((r) => {
      r({
        target: t,
        contentSize: e,
        get size() {
          return nD(t, n);
        },
      });
    });
}
function rD(t) {
  t.forEach(iD);
}
function sD() {
  typeof ResizeObserver > "u" || (Ar = new ResizeObserver(rD));
}
function aD(t, e) {
  Ar || sD();
  const n = _1(t);
  return (
    n.forEach((i) => {
      let r = $u.get(i);
      r || ((r = new Set()), $u.set(i, r)),
        r.add(e),
        Ar == null || Ar.observe(i);
    }),
    () => {
      n.forEach((i) => {
        const r = $u.get(i);
        r == null || r.delete(e),
          (r != null && r.size) || Ar == null || Ar.unobserve(i);
      });
    }
  );
}
const Xu = new Set();
let Ml;
function oD() {
  (Ml = () => {
    const t = {
        width: window.innerWidth,
        height: window.innerHeight,
      },
      e = {
        target: window,
        size: t,
        contentSize: t,
      };
    Xu.forEach((n) => n(e));
  }),
    window.addEventListener("resize", Ml);
}
function lD(t) {
  return (
    Xu.add(t),
    Ml || oD(),
    () => {
      Xu.delete(t), !Xu.size && Ml && (Ml = void 0);
    }
  );
}
function cD(t, e) {
  return typeof t == "function" ? lD(t) : aD(t, e);
}
const uD = 50,
  xy = () => ({
    current: 0,
    offset: [],
    progress: 0,
    scrollLength: 0,
    targetOffset: 0,
    targetLength: 0,
    containerLength: 0,
    velocity: 0,
  }),
  dD = () => ({
    time: 0,
    x: xy(),
    y: xy(),
  }),
  hD = {
    x: {
      length: "Width",
      position: "Left",
    },
    y: {
      length: "Height",
      position: "Top",
    },
  };
function Sy(t, e, n, i) {
  const r = n[e],
    { length: s, position: a } = hD[e],
    o = r.current,
    l = n.time;
  (r.current = t[`scroll${a}`]),
    (r.scrollLength = t[`scroll${s}`] - t[`client${s}`]),
    (r.offset.length = 0),
    (r.offset[0] = 0),
    (r.offset[1] = r.scrollLength),
    (r.progress = Ks(0, r.scrollLength, r.current));
  const c = i - l;
  r.velocity = c > uD ? 0 : uv(r.current - o, c);
}
function fD(t, e, n) {
  Sy(t, "x", e, n), Sy(t, "y", e, n), (e.time = n);
}
function pD(t, e) {
  const n = {
    x: 0,
    y: 0,
  };
  let i = t;
  for (; i && i !== e; )
    if (i instanceof HTMLElement)
      (n.x += i.offsetLeft), (n.y += i.offsetTop), (i = i.offsetParent);
    else if (i.tagName === "svg") {
      const r = i.getBoundingClientRect();
      i = i.parentElement;
      const s = i.getBoundingClientRect();
      (n.x += r.left - s.left), (n.y += r.top - s.top);
    } else if (i instanceof SVGGraphicsElement) {
      const { x: r, y: s } = i.getBBox();
      (n.x += r), (n.y += s);
      let a = null,
        o = i.parentNode;
      for (; !a; ) o.tagName === "svg" && (a = o), (o = i.parentNode);
      i = a;
    } else break;
  return n;
}
const _m = {
  start: 0,
  center: 0.5,
  end: 1,
};
function wy(t, e, n = 0) {
  let i = 0;
  if ((t in _m && (t = _m[t]), typeof t == "string")) {
    const r = parseFloat(t);
    t.endsWith("px")
      ? (i = r)
      : t.endsWith("%")
      ? (t = r / 100)
      : t.endsWith("vw")
      ? (i = (r / 100) * document.documentElement.clientWidth)
      : t.endsWith("vh")
      ? (i = (r / 100) * document.documentElement.clientHeight)
      : (t = r);
  }
  return typeof t == "number" && (i = e * t), n + i;
}
const mD = [0, 0];
function gD(t, e, n, i) {
  let r = Array.isArray(t) ? t : mD,
    s = 0,
    a = 0;
  return (
    typeof t == "number"
      ? (r = [t, t])
      : typeof t == "string" &&
        ((t = t.trim()),
        t.includes(" ") ? (r = t.split(" ")) : (r = [t, _m[t] ? t : "0"])),
    (s = wy(r[0], n, i)),
    (a = wy(r[1], e)),
    s - a
  );
}
const vD = {
    Enter: [
      [0, 1],
      [1, 1],
    ],
    Exit: [
      [0, 0],
      [1, 0],
    ],
    Any: [
      [1, 0],
      [0, 1],
    ],
    All: [
      [0, 0],
      [1, 1],
    ],
  },
  _D = {
    x: 0,
    y: 0,
  };
function yD(t) {
  return "getBBox" in t && t.tagName !== "svg"
    ? t.getBBox()
    : {
        width: t.clientWidth,
        height: t.clientHeight,
      };
}
function xD(t, e, n) {
  const { offset: i = vD.All } = n,
    { target: r = t, axis: s = "y" } = n,
    a = s === "y" ? "height" : "width",
    o = r !== t ? pD(r, t) : _D,
    l =
      r === t
        ? {
            width: t.scrollWidth,
            height: t.scrollHeight,
          }
        : yD(r),
    c = {
      width: t.clientWidth,
      height: t.clientHeight,
    };
  e[s].offset.length = 0;
  let u = !e[s].interpolate;
  const d = i.length;
  for (let h = 0; h < d; h++) {
    const p = gD(i[h], c[a], l[a], o[s]);
    !u && p !== e[s].interpolatorOffsets[h] && (u = !0), (e[s].offset[h] = p);
  }
  u &&
    ((e[s].interpolate = _v(e[s].offset, K1(i), {
      clamp: !1,
    })),
    (e[s].interpolatorOffsets = [...e[s].offset])),
    (e[s].progress = ji(0, 1, e[s].interpolate(e[s].current)));
}
function SD(t, e = t, n) {
  if (((n.x.targetOffset = 0), (n.y.targetOffset = 0), e !== t)) {
    let i = e;
    for (; i && i !== t; )
      (n.x.targetOffset += i.offsetLeft),
        (n.y.targetOffset += i.offsetTop),
        (i = i.offsetParent);
  }
  (n.x.targetLength = e === t ? e.scrollWidth : e.clientWidth),
    (n.y.targetLength = e === t ? e.scrollHeight : e.clientHeight),
    (n.x.containerLength = t.clientWidth),
    (n.y.containerLength = t.clientHeight);
}
function wD(t, e, n, i = {}) {
  return {
    measure: () => SD(t, i.target, n),
    update: (r) => {
      fD(t, n, r), (i.offset || i.target) && xD(t, n, i);
    },
    notify: () => e(n),
  };
}
const $o = new WeakMap(),
  Ey = new WeakMap(),
  _f = new WeakMap(),
  Ty = (t) => (t === document.documentElement ? window : t);
function Sv(t, { container: e = document.documentElement, ...n } = {}) {
  let i = _f.get(e);
  i || ((i = new Set()), _f.set(e, i));
  const r = dD(),
    s = wD(e, t, r, n);
  if ((i.add(s), !$o.has(e))) {
    const o = () => {
        for (const h of i) h.measure();
      },
      l = () => {
        for (const h of i) h.update(Xt.timestamp);
      },
      c = () => {
        for (const h of i) h.notify();
      },
      u = () => {
        at.read(o, !1, !0), at.read(l, !1, !0), at.update(c, !1, !0);
      };
    $o.set(e, u);
    const d = Ty(e);
    window.addEventListener("resize", u, {
      passive: !0,
    }),
      e !== document.documentElement && Ey.set(e, cD(e, u)),
      d.addEventListener("scroll", u, {
        passive: !0,
      });
  }
  const a = $o.get(e);
  return (
    at.read(a, !1, !0),
    () => {
      var o;
      Mi(a);
      const l = _f.get(e);
      if (!l || (l.delete(s), l.size)) return;
      const c = $o.get(e);
      $o.delete(e),
        c &&
          (Ty(e).removeEventListener("scroll", c),
          (o = Ey.get(e)) === null || o === void 0 || o(),
          window.removeEventListener("resize", c));
    }
  );
}
function ED({ source: t, container: e, axis: n = "y" }) {
  t && (e = t);
  const i = {
      value: 0,
    },
    r = Sv(
      (s) => {
        i.value = s[n].progress * 100;
      },
      {
        container: e,
        axis: n,
      }
    );
  return {
    currentTime: i,
    cancel: r,
  };
}
const yf = new Map();
function wT({
  source: t,
  container: e = document.documentElement,
  axis: n = "y",
} = {}) {
  t && (e = t), yf.has(e) || yf.set(e, {});
  const i = yf.get(e);
  return (
    i[n] ||
      (i[n] = h1()
        ? new ScrollTimeline({
            source: e,
            axis: n,
          })
        : ED({
            source: e,
            axis: n,
          })),
    i[n]
  );
}
function TD(t) {
  return t.length === 2;
}
function ET(t) {
  return t && (t.target || t.offset);
}
function MD(t, e) {
  return TD(t) || ET(e)
    ? Sv((n) => {
        t(n[e.axis].progress, n);
      }, e)
    : ST(t, wT(e));
}
function bD(t, e) {
  if ((t.flatten(), ET(e)))
    return (
      t.pause(),
      Sv((n) => {
        t.time = t.duration * n[e.axis].progress;
      }, e)
    );
  {
    const n = wT(e);
    return t.attachTimeline
      ? t.attachTimeline(
          n,
          (i) => (
            i.pause(),
            ST((r) => {
              i.time = i.duration * r;
            }, n)
          )
        )
      : yn;
  }
}
function AD(t, { axis: e = "y", ...n } = {}) {
  const i = {
    axis: e,
    ...n,
  };
  return typeof t == "function" ? MD(t, i) : bD(t, i);
}
function My(t, e) {
  FR(!!(!e || e.current));
}
const CD = () => ({
  scrollX: Ii(0),
  scrollY: Ii(0),
  scrollXProgress: Ii(0),
  scrollYProgress: Ii(0),
});
function RD({ container: t, target: e, layoutEffect: n = !0, ...i } = {}) {
  const r = Ro(CD);
  return (
    (n ? lh : O.useEffect)(
      () => (
        My("target", e),
        My("container", t),
        AD(
          (a, { x: o, y: l }) => {
            r.scrollX.set(o.current),
              r.scrollXProgress.set(o.progress),
              r.scrollY.set(l.current),
              r.scrollYProgress.set(l.progress);
          },
          {
            ...i,
            container: (t == null ? void 0 : t.current) || void 0,
            target: (e == null ? void 0 : e.current) || void 0,
          }
        )
      ),
      [t, e, JSON.stringify(i.offset)]
    ),
    r
  );
}
function PD(t) {
  const e = Ro(() => Ii(t)),
    { isStatic: n } = O.useContext(oh);
  if (n) {
    const [, i] = O.useState(t);
    O.useEffect(() => e.on("change", i), []);
  }
  return e;
}
function TT(t, e) {
  const n = PD(e()),
    i = () => n.set(e());
  return (
    i(),
    lh(() => {
      const r = () => at.preRender(i, !1, !0),
        s = t.map((a) => a.on("change", r));
      return () => {
        s.forEach((a) => a()), Mi(i);
      };
    }),
    n
  );
}
const LD = (t) => t && typeof t == "object" && t.mix,
  ND = (t) => (LD(t) ? t.mix : void 0);
function DD(...t) {
  const e = !Array.isArray(t[0]),
    n = e ? 0 : -1,
    i = t[0 + n],
    r = t[1 + n],
    s = t[2 + n],
    a = t[3 + n],
    o = _v(r, s, {
      mixer: ND(s[0]),
      ...a,
    });
  return e ? o(i) : o;
}
function kD(t) {
  (xl.current = []), t();
  const e = TT(xl.current, t);
  return (xl.current = void 0), e;
}
function ID(t, e, n, i) {
  if (typeof t == "function") return kD(t);
  const r = typeof e == "function" ? e : DD(e, n, i);
  return Array.isArray(t) ? by(t, r) : by([t], ([s]) => r(s));
}
function by(t, e) {
  const n = Ro(() => []);
  return TT(t, () => {
    n.length = 0;
    const i = t.length;
    for (let r = 0; r < i; r++) n[r] = t[r].get();
    return e(n);
  });
}
const UD = () => {
  const t = O.useRef(null),
    { scrollYProgress: e } = RD({
      target: t,
      offset: ["start start", "end start"],
    }),
    n = ID(e, [0, 0.3], [0, 1]),
    i = {
      hidden: {
        opacity: 0,
        y: 50,
      },
      visible: (r) => ({
        opacity: 1,
        y: 0,
        transition: {
          delay: r * 0.2,
          duration: 0.5,
          ease: "easeOut",
        },
      }),
    };
  return _.jsxs("section", {
    ref: t,
    className:
      "relative min-h-screen flex items-center justify-center overflow-hidden snap-start pt-24",
    children: [
      _.jsxs("div", {
        className: "absolute inset-0 w-full h-full",
        children: [
          _.jsx("div", {
            className: "absolute inset-0 bg-[#25584f] mix-blend-multiply",
          }),
          _.jsx("div", {
            className:
              "absolute inset-0 bg-gradient-to-br from-verde/90 to-beige/90",
          }),
          _.jsx("div", {
            className: "absolute inset-0 opacity-20",
            style: {
              backgroundImage: `url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M54.627 0l.83.828-1.415 1.415L51.8 0h2.827zM5.373 0l-.83.828L5.96 2.243 8.2 0H5.374zM48.97 0l3.657 3.657-1.414 1.414L46.143 0h2.828zM11.03 0L7.372 3.657 8.787 5.07 13.857 0H11.03zm32.284 0L49.8 6.485 48.384 7.9l-7.9-7.9h2.83zM16.686 0L10.2 6.485 11.616 7.9l7.9-7.9h-2.83zM22.344 0L13.858 8.485 15.272 9.9l9.9-9.9h-2.828zM32 0h-2.827L15.414 13.757l1.415 1.415L32 0zm-9.414 0l-9.9 9.9 1.415 1.414L25.272 0h-2.686zm-6.172 0L4.686 11.728l1.415 1.414L19.1 0h-2.686zM0 0c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314C-1.314.486-.828 0 0 0zm0 2.628c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314 0-.828.486-1.314 1.314-1.314zm2.628-2.628c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314 0-.828.486-1.314 1.314-1.314zm0 2.628c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314 0-.828.486-1.314 1.314-1.314zm2.628-2.628c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314 0-.828.486-1.314 1.314-1.314zm0 2.628c.828 0 1.314.486 1.314 1.314 0 .828-.486 1.314-1.314 1.314-.828 0-1.314-.486-1.314-1.314 0-.828.486-1.314 1.314-1.314z' fill='%23ffffff' fill-opacity='0.1' fill-rule='evenodd'/%3E%3C/svg%3E")`,
            },
          }),
        ],
      }),
      _.jsx("div", {
        className: "relative z-10 container mx-auto px-4",
        children: _.jsxs("div", {
          className: "max-w-4xl mx-auto",
          children: [
            _.jsx(Me.div, {
              initial: {
                scale: 0.8,
                opacity: 0,
              },
              animate: {
                scale: 1,
                opacity: 1,
              },
              transition: {
                duration: 0.8,
                ease: [0.16, 1, 0.3, 1],
              },
              className: "flex justify-center w-full",
              children: _.jsx(NR, {
                className: "w-[600px] h-[400px]",
              }),
            }),
            _.jsxs("div", {
              className: "text-center",
              children: [
                _.jsx(Me.div, {
                  initial: {
                    y: 20,
                    opacity: 0,
                  },
                  animate: {
                    y: 0,
                    opacity: 1,
                  },
                  transition: {
                    delay: 0.2,
                    duration: 0.6,
                    ease: [0.16, 1, 0.3, 1],
                  },
                  children: _.jsx(Vu, {
                    to: "/registro",
                    className:
                      "inline-flex items-center px-8 py-4 text-lg font-medium text-verde bg-marfil rounded-lg hover:bg-[#A8E0D9] transition-colors duration-300 transform hover:scale-105",
                    children: "Inscrbete",
                  }),
                }),
                _.jsxs(Me.p, {
                  className:
                    "text-xl md:text-2xl text-marfil/90 font-light mt-4 leading-relaxed",
                  initial: {
                    y: 20,
                    opacity: 0,
                  },
                  animate: {
                    y: 0,
                    opacity: 1,
                  },
                  transition: {
                    delay: 0.4,
                    duration: 0.6,
                    ease: [0.16, 1, 0.3, 1],
                  },
                  children: [
                    "El inicio de una nueva era en el padel.",
                    _.jsx("br", {}),
                    "Un torneo que conecta a jvenes en un ambiente vibrante.",
                  ],
                }),
                _.jsx(Me.div, {
                  className: "grid grid-cols-1 md:grid-cols-3 gap-8 mt-6",
                  style: {
                    opacity: n,
                  },
                  children: [
                    {
                      number: "23-24",
                      label: "Agosto 2025",
                    },
                    {
                      number: "160",
                      label: "Jugadores",
                    },
                    {
                      number: "300+",
                      label: "Visitantes",
                    },
                  ].map((r, s) =>
                    _.jsxs(
                      Me.div,
                      {
                        custom: s,
                        variants: i,
                        initial: "hidden",
                        whileInView: "visible",
                        viewport: {
                          once: !0,
                        },
                        className:
                          "bg-marfil/10 backdrop-blur-sm p-6 rounded-lg border border-marfil/20",
                        whileHover: {
                          scale: 1.05,
                          backgroundColor: "rgba(255, 255, 255, 0.15)",
                        },
                        transition: {
                          duration: 0.2,
                        },
                        children: [
                          _.jsx("div", {
                            className: "text-3xl font-bold text-marfil mb-1",
                            children: r.number,
                          }),
                          _.jsx("div", {
                            className: "text-marfil/80",
                            children: r.label,
                          }),
                        ],
                      },
                      s
                    )
                  ),
                }),
              ],
            }),
          ],
        }),
      }),
    ],
  });
};
var ym = new Map(),
  tu = new WeakMap(),
  Ay = 0,
  OD = void 0;
function FD(t) {
  return t
    ? (tu.has(t) || ((Ay += 1), tu.set(t, Ay.toString())), tu.get(t))
    : "0";
}
function BD(t) {
  return Object.keys(t)
    .sort()
    .filter((e) => t[e] !== void 0)
    .map((e) => `${e}_${e === "root" ? FD(t.root) : t[e]}`)
    .toString();
}
function zD(t) {
  const e = BD(t);
  let n = ym.get(e);
  if (!n) {
    const i = new Map();
    let r;
    const s = new IntersectionObserver((a) => {
      a.forEach((o) => {
        var l;
        const c = o.isIntersecting && r.some((u) => o.intersectionRatio >= u);
        t.trackVisibility && typeof o.isVisible > "u" && (o.isVisible = c),
          (l = i.get(o.target)) == null ||
            l.forEach((u) => {
              u(c, o);
            });
      });
    }, t);
    (r =
      s.thresholds ||
      (Array.isArray(t.threshold) ? t.threshold : [t.threshold || 0])),
      (n = {
        id: e,
        observer: s,
        elements: i,
      }),
      ym.set(e, n);
  }
  return n;
}
function jD(t, e, n = {}, i = OD) {
  if (typeof window.IntersectionObserver > "u" && i !== void 0) {
    const l = t.getBoundingClientRect();
    return (
      e(i, {
        isIntersecting: i,
        target: t,
        intersectionRatio: typeof n.threshold == "number" ? n.threshold : 0,
        time: 0,
        boundingClientRect: l,
        intersectionRect: l,
        rootBounds: l,
      }),
      () => {}
    );
  }
  const { id: r, observer: s, elements: a } = zD(n),
    o = a.get(t) || [];
  return (
    a.has(t) || a.set(t, o),
    o.push(e),
    s.observe(t),
    function () {
      o.splice(o.indexOf(e), 1),
        o.length === 0 && (a.delete(t), s.unobserve(t)),
        a.size === 0 && (s.disconnect(), ym.delete(r));
    }
  );
}
function Cd({
  threshold: t,
  delay: e,
  trackVisibility: n,
  rootMargin: i,
  root: r,
  triggerOnce: s,
  skip: a,
  initialInView: o,
  fallbackInView: l,
  onChange: c,
} = {}) {
  var u;
  const [d, h] = O.useState(null),
    p = O.useRef(c),
    [v, x] = O.useState({
      inView: !!o,
      entry: void 0,
    });
  (p.current = c),
    O.useEffect(() => {
      if (a || !d) return;
      let g;
      return (
        (g = jD(
          d,
          (S, T) => {
            x({
              inView: S,
              entry: T,
            }),
              p.current && p.current(S, T),
              T.isIntersecting && s && g && (g(), (g = void 0));
          },
          {
            root: r,
            rootMargin: i,
            threshold: t,
            trackVisibility: n,
            delay: e,
          },
          l
        )),
        () => {
          g && g();
        }
      );
    }, [Array.isArray(t) ? t.toString() : t, d, r, i, s, a, n, l, e]);
  const m = (u = v.entry) == null ? void 0 : u.target,
    f = O.useRef(void 0);
  !d &&
    m &&
    !s &&
    !a &&
    f.current !== m &&
    ((f.current = m),
    x({
      inView: !!o,
      entry: void 0,
    }));
  const y = [h, v.inView, v.entry];
  return (y.ref = y[0]), (y.inView = y[1]), (y.entry = y[2]), y;
}
const VD = () =>
    _.jsx("div", {
      id: "contact",
      className: "bg-marfil",
      children: _.jsxs("div", {
        className: "container",
        children: [
          _.jsx("h2", {
            className: "section-title text-verde",
            children: "Contacto",
          }),
          _.jsx("p", {
            className: "subtitle text-medianoche/80 max-w-3xl mx-auto mb-16",
            children:
              "Tienes preguntas sobre el torneo? Nuestro equipo est aqu para ayudarte",
          }),
          _.jsxs("div", {
            className: "grid grid-cols-1 lg:grid-cols-3 gap-8",
            children: [
              _.jsx("div", {
                className: "lg:col-span-2",
                children: _.jsx("div", {
                  className: "bg-verde rounded-lg overflow-hidden h-full",
                  children: _.jsx("iframe", {
                    src: "https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d3731.9729257001322!2d-103.45144972600073!3d20.711323998608126!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x8428af2c8e6f66f7%3A0x8870669e83d224bb!2sAv.%205%20de%20Mayo%20434%2C%20San%20Juan%20de%20Ocot%C3%A1n%2C%2045019%20Zapopan%2C%20Jal.!5e0!3m2!1ses!2smx!4v1748979139078!5m2!1ses!2smx",
                    width: "100%",
                    height: "100%",
                    style: {
                      border: 0,
                      minHeight: "400px",
                    },
                    allowFullScreen: !0,
                    loading: "lazy",
                    referrerPolicy: "no-referrer-when-downgrade",
                    title: "Ubicacin del Torneo",
                  }),
                }),
              }),
              _.jsx("div", {
                children: _.jsxs("div", {
                  className: "bg-verde p-8 rounded-lg text-marfil h-full",
                  children: [
                    _.jsx("h3", {
                      className: "text-2xl font-semibold mb-6 text-oro",
                      children: "Ponte en Contacto",
                    }),
                    _.jsxs("div", {
                      className: "space-y-6",
                      children: [
                        _.jsxs("div", {
                          className: "flex items-start",
                          children: [
                            _.jsx(HE, {
                              className: "mr-3 text-oro flex-shrink-0 mt-1",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold mb-1",
                                  children: "Sede del Torneo",
                                }),
                                _.jsxs("p", {
                                  className: "text-marfil/80",
                                  children: [
                                    "La Red Club De Padel",
                                    _.jsx("br", {}),
                                    "Av. 5 de Mayo 434",
                                    _.jsx("br", {}),
                                    "Zapopan, Jalisco",
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs("div", {
                          className: "flex items-start",
                          children: [
                            _.jsx(bR, {
                              className: "mr-3 text-oro flex-shrink-0 mt-1",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold mb-1",
                                  children: "Instagram",
                                }),
                                _.jsx("p", {
                                  className: "text-marfil/80 text-sm",
                                  children: _.jsx("a", {
                                    href: "https://instagram.com/grandslampadelofficial",
                                    className:
                                      "hover:text-oro transition-colors",
                                    children: "@grandslampadelofficial",
                                  }),
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs("div", {
                          className: "flex items-start",
                          children: [
                            _.jsx(CR, {
                              className: "mr-3 text-oro flex-shrink-0 mt-1",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold mb-1",
                                  children: "WhatsApp / Telfono",
                                }),
                                _.jsx("p", {
                                  className: "text-marfil/80",
                                  children: _.jsx("a", {
                                    href: "https://wa.me/5213319426363",
                                    target: "_blank",
                                    rel: "noopener noreferrer",
                                    className:
                                      "hover:text-oro transition-colors cursor-pointer select-all inline-block",
                                    children: "33 19 42 63 63",
                                  }),
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs("div", {
                          className: "flex items-start",
                          children: [
                            _.jsx(ER, {
                              className: "mr-3 text-oro flex-shrink-0 mt-1",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold mb-1",
                                  children: "Fechas del Torneo",
                                }),
                                _.jsxs("p", {
                                  className: "text-marfil/80",
                                  children: [
                                    "23-24 de Agosto, 2025",
                                    _.jsx("br", {}),
                                    "9:00 - 20:00",
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          }),
        ],
      }),
    }),
  HD = ({ sponsors: t }) => {
    const e = O.useRef(null),
      n = {
        animate: {
          x: [0, -2e3],
          transition: {
            x: {
              repeat: 1 / 0,
              repeatType: "loop",
              duration: 30,
              ease: "linear",
            },
          },
        },
      };
    return _.jsxs("div", {
      className: "relative overflow-hidden bg-marfil py-12",
      children: [
        _.jsx("div", {
          className:
            "absolute inset-y-0 left-0 w-32 bg-gradient-to-r from-marfil to-transparent z-10",
        }),
        _.jsx("div", {
          className:
            "absolute inset-y-0 right-0 w-32 bg-gradient-to-l from-marfil to-transparent z-10",
        }),
        _.jsx("div", {
          className: "overflow-hidden",
          children: _.jsx(Me.div, {
            ref: e,
            variants: n,
            animate: "animate",
            className: "flex items-center gap-12 py-8",
            whileHover: {
              animationPlayState: "paused",
            },
            children: [...t, ...t].map((i, r) =>
              _.jsx(
                Me.a,
                {
                  href: i.link,
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className:
                    "flex-shrink-0 w-48 h-48 bg-white rounded-lg shadow-md p-6 flex items-center justify-center transform-gpu hover:shadow-xl transition-all duration-300",
                  whileHover: {
                    scale: 1.05,
                    y: -5,
                  },
                  "aria-label": `Visitar sitio web de ${i.name}`,
                  children: _.jsx(Me.img, {
                    src: i.image,
                    alt: i.name,
                    className: "max-w-full max-h-full object-contain",
                    loading: "lazy",
                  }),
                },
                `${i.name}-${r}`
              )
            ),
          }),
        }),
      ],
    });
  },
  GD = [
    {
      name: "Birkenstock",
      image: "https://imgur.com/vx6TqhD.jpg",
      link: "https://www.instagram.com/birkenstockmexico/",
    },
    {
      name: "Electrolit",
      image: "https://imgur.com/w9Iy2Ju.jpg",
      link: "https://www.instagram.com/electrolit/",
    },
    {
      name: "Atajo Outdoors",
      image: "https://imgur.com/rCo7Vxe.jpg",
      link: "https://www.instagram.com/atajooutdoors/",
    },
    {
      name: "Red Cola",
      image: "https://imgur.com/MPA3x5d.jpg",
      link: "https://www.instagram.com/redcolamx/",
    },
    {
      name: "Betterware",
      image: "https://imgur.com/ZFHJVOJ.jpg",
      link: "https://www.instagram.com/betterwaremexico/",
    },
    {
      name: "Wu Nutrition",
      image: "https://imgur.com/lGviTeM.jpg",
      link: "https://wunutrition.com/",
    },
    {
      name: "Medusa Solar",
      image: "https://imgur.com/PKqlmEQ.jpg",
      link: "https://www.medusasolar.com/",
    },
    {
      name: "Skarch",
      image: "https://imgur.com/lvxHkHB.jpg",
      link: "https://www.instagram.com/skarchmexico/",
    },
    {
      name: "Premier Nuts",
      image: "https://imgur.com/KwFWu98.jpg",
      link: "https://www.instagram.com/premier.nuts/",
    },
    {
      name: "Come Verde",
      image: "https://imgur.com/yLDFa4k.jpg",
      link: "https://www.comeverde.mx/",
    },
    {
      name: "Omigoto",
      image: "https://imgur.com/yjSCL5S.jpg",
      link: "https://www.instagram.com/omigotomx/",
    },
  ],
  WD = () => {
    const t = OE(),
      { ref: e, inView: n } = Cd({
        triggerOnce: !0,
        threshold: 0.1,
      });
    return _.jsx("section", {
      className: "py-16 bg-marfil overflow-hidden",
      ref: e,
      children: _.jsxs("div", {
        className: "container",
        children: [
          _.jsxs(Me.div, {
            initial: {
              opacity: 0,
              y: 20,
            },
            animate: {
              opacity: n ? 1 : 0,
              y: n ? 0 : 20,
            },
            transition: {
              duration: 0.6,
            },
            className: "text-center mb-12",
            children: [
              _.jsx("h2", {
                className: "text-3xl font-bold text-verde mb-4",
                children: "Patrocinadores Destacados",
              }),
              _.jsx("p", {
                className: "text-medianoche/80",
                children:
                  "Orgullosos de contar con el apoyo de marcas lderes en el mundo del padel",
              }),
            ],
          }),
          _.jsx(HD, {
            sponsors: GD,
          }),
          _.jsx(Me.div, {
            initial: {
              opacity: 0,
              y: 20,
            },
            animate: {
              opacity: n ? 1 : 0,
              y: n ? 0 : 20,
            },
            transition: {
              duration: 0.6,
              delay: 0.3,
            },
            className: "text-center mt-12",
            children: _.jsx(Me.button, {
              onClick: () => t("/patrocinadores"),
              className:
                "inline-flex items-center px-8 py-4 text-base font-semibold text-verde border-2 border-verde rounded-lg hover:bg-verde hover:text-marfil transition-all duration-300 transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-verde focus:ring-offset-2",
              whileHover: {
                scale: 1.05,
              },
              whileTap: {
                scale: 0.95,
              },
              children: "Ver todos los patrocinadores",
            }),
          }),
        ],
      }),
    });
  },
  $D = () => {
    const [t, e] = Cd({
      triggerOnce: !0,
      threshold: 0.1,
    });
    return _.jsx("section", {
      id: "about",
      className: "section bg-marfil overflow-hidden snap-start",
      children: _.jsxs("div", {
        className: "container",
        children: [
          _.jsx(Me.h2, {
            className: "section-title text-verde",
            initial: {
              opacity: 0,
              y: 20,
            },
            animate: {
              opacity: e ? 1 : 0,
              y: e ? 0 : 20,
            },
            transition: {
              duration: 0.6,
            },
            ref: t,
            children: "Sobre el Torneo",
          }),
          _.jsx(Me.p, {
            className: "subtitle text-medianoche/80 max-w-3xl mx-auto mb-16",
            initial: {
              opacity: 0,
              y: 20,
            },
            animate: {
              opacity: e ? 1 : 0,
              y: e ? 0 : 20,
            },
            transition: {
              duration: 0.6,
              delay: 0.2,
            },
            children:
              "Padeln es ms que un torneo. Es una experiencia que busca posicionarse como el evento de padel ms prestigioso del estado de Jalisco, conectando a jvenes en un ambiente vibrante.",
          }),
          _.jsx(Me.div, {
            initial: {
              y: 40,
              opacity: 0,
            },
            animate: {
              y: 0,
              opacity: 1,
            },
            transition: {
              delay: 0.4,
              duration: 0.8,
              ease: [0.16, 1, 0.3, 1],
            },
            className:
              "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8 mb-16",
            children: [
              {
                icon: _.jsx(GE, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Premios Exclusivos",
                description:
                  "Ms de $100,000 MXN en premios para los ganadores",
              },
              {
                icon: _.jsx(MR, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Kit de Bienvenida",
                description:
                  "Kit exclusivo para todos los jugadores participantes",
              },
              {
                icon: _.jsx(RR, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Formato Premium",
                description: "Canchas premium y garanta de 3 partidos mnimo",
              },
              {
                icon: _.jsx(di, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Reconocimientos",
                description: "Trofeos y visibilidad en redes sociales",
              },
              {
                icon: _.jsx(zg, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Experiencias nicas",
                description: "Activaciones de marcas y experiencias exclusivas",
              },
              {
                icon: _.jsx(i_, {
                  className: "w-8 h-8 text-beige",
                }),
                title: "Primera Edicin",
                description: "S parte de un torneo que marcar historia",
              },
            ].map((n, i) =>
              _.jsxs(
                Me.div,
                {
                  className:
                    "bg-verde/10 backdrop-blur-sm p-6 rounded-lg border border-verde/20",
                  whileHover: {
                    scale: 1.05,
                    backgroundColor: "rgba(37, 88, 79, 0.15)",
                  },
                  transition: {
                    duration: 0.2,
                  },
                  children: [
                    _.jsxs("div", {
                      className: "flex items-center gap-4 mb-4",
                      children: [
                        n.icon,
                        _.jsx("h3", {
                          className: "text-lg font-semibold text-verde",
                          children: n.title,
                        }),
                      ],
                    }),
                    _.jsx("p", {
                      className: "text-medianoche/80",
                      children: n.description,
                    }),
                  ],
                },
                i
              )
            ),
          }),
          _.jsxs("div", {
            className: "grid grid-cols-1 md:grid-cols-2 gap-12 items-center",
            children: [
              _.jsx(Me.div, {
                className: "order-2 md:order-1",
                initial: {
                  opacity: 0,
                  x: -50,
                },
                animate: {
                  opacity: e ? 1 : 0,
                  x: e ? 0 : -50,
                },
                transition: {
                  duration: 0.6,
                  delay: 0.4,
                },
                children: _.jsxs("div", {
                  className: "space-y-6",
                  children: [
                    _.jsx("h3", {
                      className: "text-2xl font-semibold text-verde mb-4",
                      children: "Nuestra Visin",
                    }),
                    _.jsx("p", {
                      className: "text-medianoche/80",
                      children:
                        "Impulsar el crecimiento del padel en Mxico, creando una comunidad dentro y fuera de la cancha.",
                    }),
                    _.jsxs("div", {
                      className: "grid grid-cols-2 gap-6 mt-8",
                      children: [
                        _.jsxs(Me.div, {
                          className: "flex items-start",
                          whileHover: {
                            scale: 1.05,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx(i_, {
                              className: "mr-3 text-beige flex-shrink-0",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold",
                                  children: "Jvenes 18-26",
                                }),
                                _.jsx("p", {
                                  className: "text-sm text-medianoche/70",
                                  children: "Competencia de Alto Nivel",
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs(Me.div, {
                          className: "flex items-start",
                          whileHover: {
                            scale: 1.05,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx(wR, {
                              className: "mr-3 text-beige flex-shrink-0",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold",
                                  children: "23-24 Agosto",
                                }),
                                _.jsx("p", {
                                  className: "text-sm text-medianoche/70",
                                  children: "2025",
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs(Me.div, {
                          className: "flex items-start",
                          whileHover: {
                            scale: 1.05,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx(jE, {
                              className: "mr-3 text-beige flex-shrink-0",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold",
                                  children: "Ambiente Exclusivo",
                                }),
                                _.jsx("p", {
                                  className: "text-sm text-medianoche/70",
                                  children: "Experiencias nicas",
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs(Me.div, {
                          className: "flex items-start",
                          whileHover: {
                            scale: 1.05,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx(HE, {
                              className: "mr-3 text-beige flex-shrink-0",
                              size: 24,
                            }),
                            _.jsxs("div", {
                              children: [
                                _.jsx("h4", {
                                  className: "font-semibold",
                                  children: "La Red Club De Padel",
                                }),
                                _.jsx("p", {
                                  className: "text-sm text-medianoche/70",
                                  children: "Zapopan, Jalisco",
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              }),
              _.jsx(Me.div, {
                className: "order-1 md:order-2",
                initial: {
                  opacity: 0,
                  x: 50,
                },
                animate: {
                  opacity: e ? 1 : 0,
                  x: e ? 0 : 50,
                },
                transition: {
                  duration: 0.6,
                  delay: 0.4,
                },
                children: _.jsxs("div", {
                  className: "relative",
                  children: [
                    _.jsx(Me.img, {
                      src: "https://imgur.com/5zPSIVL.png",
                      alt: "Torneo de Padel",
                      className: "rounded-lg shadow-xl",
                      whileHover: {
                        scale: 1.05,
                      },
                      transition: {
                        duration: 0.3,
                      },
                    }),
                    _.jsxs(Me.div, {
                      className:
                        "absolute -bottom-6 -left-6 bg-beige p-4 rounded-lg shadow-lg",
                      initial: {
                        scale: 0,
                      },
                      animate: {
                        scale: e ? 1 : 0,
                      },
                      transition: {
                        duration: 0.6,
                        delay: 0.8,
                      },
                      children: [
                        _.jsx("div", {
                          className: "text-xl font-semibold text-marfil",
                          children: "1 Edicin",
                        }),
                        _.jsx("div", {
                          className: "text-sm text-marfil",
                          children: "Zapopan 2025",
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            ],
          }),
          _.jsxs(Me.div, {
            className: "mt-24",
            initial: {
              opacity: 0,
              y: 50,
            },
            animate: {
              opacity: e ? 1 : 0,
              y: e ? 0 : 50,
            },
            transition: {
              duration: 0.6,
              delay: 0.8,
            },
            children: [
              _.jsx("h3", {
                className: "text-2xl font-semibold text-verde mb-8 text-center",
                children: "Responsabilidad Social",
              }),
              _.jsxs(Me.div, {
                className:
                  "bg-verde/10 p-8 rounded-lg flex flex-col md:flex-row items-center gap-8",
                whileHover: {
                  scale: 1.02,
                },
                transition: {
                  duration: 0.2,
                },
                children: [
                  _.jsx("div", {
                    className: "flex-shrink-0",
                    children: _.jsx("img", {
                      src: "https://imgur.com/2d3jmxd.jpg",
                      alt: "Logo Fundacin Escalar",
                      className: "w-48 h-auto object-contain",
                    }),
                  }),
                  _.jsxs("div", {
                    children: [
                      _.jsx("h4", {
                        className: "text-xl font-semibold mb-2",
                        children: "Casa Hogar Escalar",
                      }),
                      _.jsx("p", {
                        className: "text-medianoche/80",
                        children:
                          "En cada edicin apoyamos a una institucin. Este ao nos enorgullece colaborar con Casa Hogar Escalar, ubicada en Colegio Del Aire, Paseo de la Noria 1500, Zapopan, Jalisco.",
                      }),
                    ],
                  }),
                  _.jsx(VE, {
                    className: "text-beige flex-shrink-0 hidden md:block",
                    size: 48,
                  }),
                ],
              }),
            ],
          }),
          _.jsxs(Me.div, {
            className: "mt-16",
            initial: {
              opacity: 0,
              y: 50,
            },
            animate: {
              opacity: e ? 1 : 0,
              y: e ? 0 : 50,
            },
            transition: {
              duration: 0.6,
              delay: 1,
            },
            children: [
              _.jsx("h3", {
                className: "text-2xl font-semibold text-verde mb-8 text-center",
                children: "Cobertura Meditica",
              }),
              _.jsx("p", {
                className: "subtitle text-medianoche/80 max-w-3xl mx-auto mb-8",
                children:
                  "Tu marca tendr presencia en medios de alto impacto.",
              }),
              _.jsxs("div", {
                className: "bg-verde p-8 rounded-lg text-center",
                children: [
                  _.jsx("div", {
                    className: "text-4xl font-bold text-marfil mb-2",
                    children: "+350,000",
                  }),
                  _.jsx("div", {
                    className: "text-xl text-marfil/80",
                    children: "Impresiones o vistas esperadas",
                  }),
                  _.jsx("div", {
                    className: "mt-4 text-marfil/60",
                    children:
                      "A travs de Instagram, TikTok, Players, Gente Bien y El Mural",
                  }),
                ],
              }),
            ],
          }),
          _.jsxs(Me.div, {
            className: "mt-24",
            initial: {
              opacity: 0,
              y: 50,
            },
            animate: {
              opacity: e ? 1 : 0,
              y: e ? 0 : 50,
            },
            transition: {
              duration: 0.6,
              delay: 1.2,
            },
            children: [
              _.jsx("h3", {
                className: "text-2xl font-semibold text-verde mb-8 text-center",
                children: "Convocatoria",
              }),
              _.jsx("div", {
                className: "flex justify-center",
                children: _.jsx(Me.a, {
                  href: "https://drive.google.com/file/d/1XGBhcbAaAE1hkMAFcCIpF1d9DPskbz_p/view?usp=sharinghttps://drive.google.com/file/d/1XGBhcbAaAE1hkMAFcCIpF1d9DPskbz_p/view?usp=sharing",
                  target: "_blank",
                  rel: "noopener noreferrer",
                  className:
                    "inline-flex items-center px-8 py-4 bg-beige text-marfil rounded-lg hover:bg-verde transition-colors duration-300 transform hover:scale-105",
                  whileHover: {
                    scale: 1.05,
                  },
                  whileTap: {
                    scale: 0.95,
                  },
                  children: "Descargar Convocatoria",
                }),
              }),
            ],
          }),
          _.jsx("div", {
            className: "mt-16",
            children: _.jsx(WD, {}),
          }),
          _.jsx("div", {
            className: "mt-12",
            children: _.jsx(VD, {}),
          }),
        ],
      }),
    });
  },
  XD = "modulepreload",
  qD = function (t) {
    return "/" + t;
  },
  Cy = {},
  go = function (e, n, i) {
    let r = Promise.resolve();
    if (n && n.length > 0) {
      document.getElementsByTagName("link");
      const a = document.querySelector("meta[property=csp-nonce]"),
        o =
          (a == null ? void 0 : a.nonce) ||
          (a == null ? void 0 : a.getAttribute("nonce"));
      r = Promise.allSettled(
        n.map((l) => {
          if (((l = qD(l)), l in Cy)) return;
          Cy[l] = !0;
          const c = l.endsWith(".css"),
            u = c ? '[rel="stylesheet"]' : "";
          if (document.querySelector(`link[href="${l}"]${u}`)) return;
          const d = document.createElement("link");
          if (
            ((d.rel = c ? "stylesheet" : XD),
            c || (d.as = "script"),
            (d.crossOrigin = ""),
            (d.href = l),
            o && d.setAttribute("nonce", o),
            document.head.appendChild(d),
            c)
          )
            return new Promise((h, p) => {
              d.addEventListener("load", h),
                d.addEventListener("error", () =>
                  p(new Error(`Unable to preload CSS for ${l}`))
                );
            });
        })
      );
    }
    function s(a) {
      const o = new Event("vite:preloadError", {
        cancelable: !0,
      });
      if (((o.payload = a), window.dispatchEvent(o), !o.defaultPrevented))
        throw a;
    }
    return r.then((a) => {
      for (const o of a || []) o.status === "rejected" && s(o.reason);
      return e().catch(s);
    });
  },
  YD = (t) => {
    let e;
    return (
      t
        ? (e = t)
        : typeof fetch > "u"
        ? (e = (...n) =>
            go(async () => {
              const { default: i } = await Promise.resolve().then(() => No);
              return {
                default: i,
              };
            }, void 0).then(({ default: i }) => i(...n)))
        : (e = fetch),
      (...n) => e(...n)
    );
  };
class wv extends Error {
  constructor(e, n = "FunctionsError", i) {
    super(e), (this.name = n), (this.context = i);
  }
}
class ZD extends wv {
  constructor(e) {
    super(
      "Failed to send a request to the Edge Function",
      "FunctionsFetchError",
      e
    );
  }
}
class KD extends wv {
  constructor(e) {
    super("Relay Error invoking the Edge Function", "FunctionsRelayError", e);
  }
}
class JD extends wv {
  constructor(e) {
    super(
      "Edge Function returned a non-2xx status code",
      "FunctionsHttpError",
      e
    );
  }
}
var xm;
(function (t) {
  (t.Any = "any"),
    (t.ApNortheast1 = "ap-northeast-1"),
    (t.ApNortheast2 = "ap-northeast-2"),
    (t.ApSouth1 = "ap-south-1"),
    (t.ApSoutheast1 = "ap-southeast-1"),
    (t.ApSoutheast2 = "ap-southeast-2"),
    (t.CaCentral1 = "ca-central-1"),
    (t.EuCentral1 = "eu-central-1"),
    (t.EuWest1 = "eu-west-1"),
    (t.EuWest2 = "eu-west-2"),
    (t.EuWest3 = "eu-west-3"),
    (t.SaEast1 = "sa-east-1"),
    (t.UsEast1 = "us-east-1"),
    (t.UsWest1 = "us-west-1"),
    (t.UsWest2 = "us-west-2");
})(xm || (xm = {}));
var QD = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
class ek {
  constructor(e, { headers: n = {}, customFetch: i, region: r = xm.Any } = {}) {
    (this.url = e), (this.headers = n), (this.region = r), (this.fetch = YD(i));
  }
  setAuth(e) {
    this.headers.Authorization = `Bearer ${e}`;
  }
  invoke(e, n = {}) {
    var i;
    return QD(this, void 0, void 0, function* () {
      try {
        const { headers: r, method: s, body: a } = n;
        let o = {},
          { region: l } = n;
        l || (l = this.region), l && l !== "any" && (o["x-region"] = l);
        let c;
        a &&
          ((r && !Object.prototype.hasOwnProperty.call(r, "Content-Type")) ||
            !r) &&
          ((typeof Blob < "u" && a instanceof Blob) || a instanceof ArrayBuffer
            ? ((o["Content-Type"] = "application/octet-stream"), (c = a))
            : typeof a == "string"
            ? ((o["Content-Type"] = "text/plain"), (c = a))
            : typeof FormData < "u" && a instanceof FormData
            ? (c = a)
            : ((o["Content-Type"] = "application/json"),
              (c = JSON.stringify(a))));
        const u = yield this.fetch(`${this.url}/${e}`, {
            method: s || "POST",
            headers: Object.assign(
              Object.assign(Object.assign({}, o), this.headers),
              r
            ),
            body: c,
          }).catch((v) => {
            throw new ZD(v);
          }),
          d = u.headers.get("x-relay-error");
        if (d && d === "true") throw new KD(u);
        if (!u.ok) throw new JD(u);
        let h = (
            (i = u.headers.get("Content-Type")) !== null && i !== void 0
              ? i
              : "text/plain"
          )
            .split(";")[0]
            .trim(),
          p;
        return (
          h === "application/json"
            ? (p = yield u.json())
            : h === "application/octet-stream"
            ? (p = yield u.blob())
            : h === "text/event-stream"
            ? (p = u)
            : h === "multipart/form-data"
            ? (p = yield u.formData())
            : (p = yield u.text()),
          {
            data: p,
            error: null,
          }
        );
      } catch (r) {
        return {
          data: null,
          error: r,
        };
      }
    });
  }
}
var An = {},
  Ev = {},
  ph = {},
  Tc = {},
  mh = {},
  gh = {},
  tk = function () {
    if (typeof self < "u") return self;
    if (typeof window < "u") return window;
    if (typeof global < "u") return global;
    throw new Error("unable to locate global object");
  },
  vo = tk();
const nk = vo.fetch,
  MT = vo.fetch.bind(vo),
  bT = vo.Headers,
  ik = vo.Request,
  rk = vo.Response,
  No = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        Headers: bT,
        Request: ik,
        Response: rk,
        default: MT,
        fetch: nk,
      },
      Symbol.toStringTag,
      {
        value: "Module",
      }
    )
  ),
  sk = $M(No);
var vh = {};
Object.defineProperty(vh, "__esModule", {
  value: !0,
});
let ak = class extends Error {
  constructor(e) {
    super(e.message),
      (this.name = "PostgrestError"),
      (this.details = e.details),
      (this.hint = e.hint),
      (this.code = e.code);
  }
};
vh.default = ak;
var AT =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(gh, "__esModule", {
  value: !0,
});
const ok = AT(sk),
  lk = AT(vh);
let ck = class {
  constructor(e) {
    (this.shouldThrowOnError = !1),
      (this.method = e.method),
      (this.url = e.url),
      (this.headers = e.headers),
      (this.schema = e.schema),
      (this.body = e.body),
      (this.shouldThrowOnError = e.shouldThrowOnError),
      (this.signal = e.signal),
      (this.isMaybeSingle = e.isMaybeSingle),
      e.fetch
        ? (this.fetch = e.fetch)
        : typeof fetch > "u"
        ? (this.fetch = ok.default)
        : (this.fetch = fetch);
  }
  throwOnError() {
    return (this.shouldThrowOnError = !0), this;
  }
  setHeader(e, n) {
    return (
      (this.headers = Object.assign({}, this.headers)),
      (this.headers[e] = n),
      this
    );
  }
  then(e, n) {
    this.schema === void 0 ||
      (["GET", "HEAD"].includes(this.method)
        ? (this.headers["Accept-Profile"] = this.schema)
        : (this.headers["Content-Profile"] = this.schema)),
      this.method !== "GET" &&
        this.method !== "HEAD" &&
        (this.headers["Content-Type"] = "application/json");
    const i = this.fetch;
    let r = i(this.url.toString(), {
      method: this.method,
      headers: this.headers,
      body: JSON.stringify(this.body),
      signal: this.signal,
    }).then(async (s) => {
      var a, o, l;
      let c = null,
        u = null,
        d = null,
        h = s.status,
        p = s.statusText;
      if (s.ok) {
        if (this.method !== "HEAD") {
          const f = await s.text();
          f === "" ||
            (this.headers.Accept === "text/csv" ||
            (this.headers.Accept &&
              this.headers.Accept.includes("application/vnd.pgrst.plan+text"))
              ? (u = f)
              : (u = JSON.parse(f)));
        }
        const x =
            (a = this.headers.Prefer) === null || a === void 0
              ? void 0
              : a.match(/count=(exact|planned|estimated)/),
          m =
            (o = s.headers.get("content-range")) === null || o === void 0
              ? void 0
              : o.split("/");
        x && m && m.length > 1 && (d = parseInt(m[1])),
          this.isMaybeSingle &&
            this.method === "GET" &&
            Array.isArray(u) &&
            (u.length > 1
              ? ((c = {
                  code: "PGRST116",
                  details: `Results contain ${u.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                  hint: null,
                  message:
                    "JSON object requested, multiple (or no) rows returned",
                }),
                (u = null),
                (d = null),
                (h = 406),
                (p = "Not Acceptable"))
              : u.length === 1
              ? (u = u[0])
              : (u = null));
      } else {
        const x = await s.text();
        try {
          (c = JSON.parse(x)),
            Array.isArray(c) &&
              s.status === 404 &&
              ((u = []), (c = null), (h = 200), (p = "OK"));
        } catch {
          s.status === 404 && x === ""
            ? ((h = 204), (p = "No Content"))
            : (c = {
                message: x,
              });
        }
        if (
          (c &&
            this.isMaybeSingle &&
            !((l = c == null ? void 0 : c.details) === null || l === void 0) &&
            l.includes("0 rows") &&
            ((c = null), (h = 200), (p = "OK")),
          c && this.shouldThrowOnError)
        )
          throw new lk.default(c);
      }
      return {
        error: c,
        data: u,
        count: d,
        status: h,
        statusText: p,
      };
    });
    return (
      this.shouldThrowOnError ||
        (r = r.catch((s) => {
          var a, o, l;
          return {
            error: {
              message: `${
                (a = s == null ? void 0 : s.name) !== null && a !== void 0
                  ? a
                  : "FetchError"
              }: ${s == null ? void 0 : s.message}`,
              details: `${
                (o = s == null ? void 0 : s.stack) !== null && o !== void 0
                  ? o
                  : ""
              }`,
              hint: "",
              code: `${
                (l = s == null ? void 0 : s.code) !== null && l !== void 0
                  ? l
                  : ""
              }`,
            },
            data: null,
            count: null,
            status: 0,
            statusText: "",
          };
        })),
      r.then(e, n)
    );
  }
  returns() {
    return this;
  }
  overrideTypes() {
    return this;
  }
};
gh.default = ck;
var uk =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(mh, "__esModule", {
  value: !0,
});
const dk = uk(gh);
let hk = class extends dk.default {
  select(e) {
    let n = !1;
    const i = (e ?? "*")
      .split("")
      .map((r) => (/\s/.test(r) && !n ? "" : (r === '"' && (n = !n), r)))
      .join("");
    return (
      this.url.searchParams.set("select", i),
      this.headers.Prefer && (this.headers.Prefer += ","),
      (this.headers.Prefer += "return=representation"),
      this
    );
  }
  order(
    e,
    {
      ascending: n = !0,
      nullsFirst: i,
      foreignTable: r,
      referencedTable: s = r,
    } = {}
  ) {
    const a = s ? `${s}.order` : "order",
      o = this.url.searchParams.get(a);
    return (
      this.url.searchParams.set(
        a,
        `${o ? `${o},` : ""}${e}.${n ? "asc" : "desc"}${
          i === void 0 ? "" : i ? ".nullsfirst" : ".nullslast"
        }`
      ),
      this
    );
  }
  limit(e, { foreignTable: n, referencedTable: i = n } = {}) {
    const r = typeof i > "u" ? "limit" : `${i}.limit`;
    return this.url.searchParams.set(r, `${e}`), this;
  }
  range(e, n, { foreignTable: i, referencedTable: r = i } = {}) {
    const s = typeof r > "u" ? "offset" : `${r}.offset`,
      a = typeof r > "u" ? "limit" : `${r}.limit`;
    return (
      this.url.searchParams.set(s, `${e}`),
      this.url.searchParams.set(a, `${n - e + 1}`),
      this
    );
  }
  abortSignal(e) {
    return (this.signal = e), this;
  }
  single() {
    return (this.headers.Accept = "application/vnd.pgrst.object+json"), this;
  }
  maybeSingle() {
    return (
      this.method === "GET"
        ? (this.headers.Accept = "application/json")
        : (this.headers.Accept = "application/vnd.pgrst.object+json"),
      (this.isMaybeSingle = !0),
      this
    );
  }
  csv() {
    return (this.headers.Accept = "text/csv"), this;
  }
  geojson() {
    return (this.headers.Accept = "application/geo+json"), this;
  }
  explain({
    analyze: e = !1,
    verbose: n = !1,
    settings: i = !1,
    buffers: r = !1,
    wal: s = !1,
    format: a = "text",
  } = {}) {
    var o;
    const l = [
        e ? "analyze" : null,
        n ? "verbose" : null,
        i ? "settings" : null,
        r ? "buffers" : null,
        s ? "wal" : null,
      ]
        .filter(Boolean)
        .join("|"),
      c =
        (o = this.headers.Accept) !== null && o !== void 0
          ? o
          : "application/json";
    return (
      (this.headers.Accept = `application/vnd.pgrst.plan+${a}; for="${c}"; options=${l};`),
      a === "json" ? this : this
    );
  }
  rollback() {
    var e;
    return (
      ((e = this.headers.Prefer) !== null && e !== void 0 ? e : "").trim()
        .length > 0
        ? (this.headers.Prefer += ",tx=rollback")
        : (this.headers.Prefer = "tx=rollback"),
      this
    );
  }
  returns() {
    return this;
  }
};
mh.default = hk;
var fk =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(Tc, "__esModule", {
  value: !0,
});
const pk = fk(mh);
let mk = class extends pk.default {
  eq(e, n) {
    return this.url.searchParams.append(e, `eq.${n}`), this;
  }
  neq(e, n) {
    return this.url.searchParams.append(e, `neq.${n}`), this;
  }
  gt(e, n) {
    return this.url.searchParams.append(e, `gt.${n}`), this;
  }
  gte(e, n) {
    return this.url.searchParams.append(e, `gte.${n}`), this;
  }
  lt(e, n) {
    return this.url.searchParams.append(e, `lt.${n}`), this;
  }
  lte(e, n) {
    return this.url.searchParams.append(e, `lte.${n}`), this;
  }
  like(e, n) {
    return this.url.searchParams.append(e, `like.${n}`), this;
  }
  likeAllOf(e, n) {
    return this.url.searchParams.append(e, `like(all).{${n.join(",")}}`), this;
  }
  likeAnyOf(e, n) {
    return this.url.searchParams.append(e, `like(any).{${n.join(",")}}`), this;
  }
  ilike(e, n) {
    return this.url.searchParams.append(e, `ilike.${n}`), this;
  }
  ilikeAllOf(e, n) {
    return this.url.searchParams.append(e, `ilike(all).{${n.join(",")}}`), this;
  }
  ilikeAnyOf(e, n) {
    return this.url.searchParams.append(e, `ilike(any).{${n.join(",")}}`), this;
  }
  is(e, n) {
    return this.url.searchParams.append(e, `is.${n}`), this;
  }
  in(e, n) {
    const i = Array.from(new Set(n))
      .map((r) =>
        typeof r == "string" && new RegExp("[,()]").test(r) ? `"${r}"` : `${r}`
      )
      .join(",");
    return this.url.searchParams.append(e, `in.(${i})`), this;
  }
  contains(e, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(e, `cs.${n}`)
        : Array.isArray(n)
        ? this.url.searchParams.append(e, `cs.{${n.join(",")}}`)
        : this.url.searchParams.append(e, `cs.${JSON.stringify(n)}`),
      this
    );
  }
  containedBy(e, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(e, `cd.${n}`)
        : Array.isArray(n)
        ? this.url.searchParams.append(e, `cd.{${n.join(",")}}`)
        : this.url.searchParams.append(e, `cd.${JSON.stringify(n)}`),
      this
    );
  }
  rangeGt(e, n) {
    return this.url.searchParams.append(e, `sr.${n}`), this;
  }
  rangeGte(e, n) {
    return this.url.searchParams.append(e, `nxl.${n}`), this;
  }
  rangeLt(e, n) {
    return this.url.searchParams.append(e, `sl.${n}`), this;
  }
  rangeLte(e, n) {
    return this.url.searchParams.append(e, `nxr.${n}`), this;
  }
  rangeAdjacent(e, n) {
    return this.url.searchParams.append(e, `adj.${n}`), this;
  }
  overlaps(e, n) {
    return (
      typeof n == "string"
        ? this.url.searchParams.append(e, `ov.${n}`)
        : this.url.searchParams.append(e, `ov.{${n.join(",")}}`),
      this
    );
  }
  textSearch(e, n, { config: i, type: r } = {}) {
    let s = "";
    r === "plain"
      ? (s = "pl")
      : r === "phrase"
      ? (s = "ph")
      : r === "websearch" && (s = "w");
    const a = i === void 0 ? "" : `(${i})`;
    return this.url.searchParams.append(e, `${s}fts${a}.${n}`), this;
  }
  match(e) {
    return (
      Object.entries(e).forEach(([n, i]) => {
        this.url.searchParams.append(n, `eq.${i}`);
      }),
      this
    );
  }
  not(e, n, i) {
    return this.url.searchParams.append(e, `not.${n}.${i}`), this;
  }
  or(e, { foreignTable: n, referencedTable: i = n } = {}) {
    const r = i ? `${i}.or` : "or";
    return this.url.searchParams.append(r, `(${e})`), this;
  }
  filter(e, n, i) {
    return this.url.searchParams.append(e, `${n}.${i}`), this;
  }
};
Tc.default = mk;
var gk =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(ph, "__esModule", {
  value: !0,
});
const Xo = gk(Tc);
let vk = class {
  constructor(e, { headers: n = {}, schema: i, fetch: r }) {
    (this.url = e), (this.headers = n), (this.schema = i), (this.fetch = r);
  }
  select(e, { head: n = !1, count: i } = {}) {
    const r = n ? "HEAD" : "GET";
    let s = !1;
    const a = (e ?? "*")
      .split("")
      .map((o) => (/\s/.test(o) && !s ? "" : (o === '"' && (s = !s), o)))
      .join("");
    return (
      this.url.searchParams.set("select", a),
      i && (this.headers.Prefer = `count=${i}`),
      new Xo.default({
        method: r,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
  insert(e, { count: n, defaultToNull: i = !0 } = {}) {
    const r = "POST",
      s = [];
    if (
      (this.headers.Prefer && s.push(this.headers.Prefer),
      n && s.push(`count=${n}`),
      i || s.push("missing=default"),
      (this.headers.Prefer = s.join(",")),
      Array.isArray(e))
    ) {
      const a = e.reduce((o, l) => o.concat(Object.keys(l)), []);
      if (a.length > 0) {
        const o = [...new Set(a)].map((l) => `"${l}"`);
        this.url.searchParams.set("columns", o.join(","));
      }
    }
    return new Xo.default({
      method: r,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: e,
      fetch: this.fetch,
      allowEmpty: !1,
    });
  }
  upsert(
    e,
    {
      onConflict: n,
      ignoreDuplicates: i = !1,
      count: r,
      defaultToNull: s = !0,
    } = {}
  ) {
    const a = "POST",
      o = [`resolution=${i ? "ignore" : "merge"}-duplicates`];
    if (
      (n !== void 0 && this.url.searchParams.set("on_conflict", n),
      this.headers.Prefer && o.push(this.headers.Prefer),
      r && o.push(`count=${r}`),
      s || o.push("missing=default"),
      (this.headers.Prefer = o.join(",")),
      Array.isArray(e))
    ) {
      const l = e.reduce((c, u) => c.concat(Object.keys(u)), []);
      if (l.length > 0) {
        const c = [...new Set(l)].map((u) => `"${u}"`);
        this.url.searchParams.set("columns", c.join(","));
      }
    }
    return new Xo.default({
      method: a,
      url: this.url,
      headers: this.headers,
      schema: this.schema,
      body: e,
      fetch: this.fetch,
      allowEmpty: !1,
    });
  }
  update(e, { count: n } = {}) {
    const i = "PATCH",
      r = [];
    return (
      this.headers.Prefer && r.push(this.headers.Prefer),
      n && r.push(`count=${n}`),
      (this.headers.Prefer = r.join(",")),
      new Xo.default({
        method: i,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        body: e,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
  delete({ count: e } = {}) {
    const n = "DELETE",
      i = [];
    return (
      e && i.push(`count=${e}`),
      this.headers.Prefer && i.unshift(this.headers.Prefer),
      (this.headers.Prefer = i.join(",")),
      new Xo.default({
        method: n,
        url: this.url,
        headers: this.headers,
        schema: this.schema,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
};
ph.default = vk;
var _h = {},
  yh = {};
Object.defineProperty(yh, "__esModule", {
  value: !0,
});
yh.version = void 0;
yh.version = "0.0.0-automated";
Object.defineProperty(_h, "__esModule", {
  value: !0,
});
_h.DEFAULT_HEADERS = void 0;
const _k = yh;
_h.DEFAULT_HEADERS = {
  "X-Client-Info": `postgrest-js/${_k.version}`,
};
var CT =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(Ev, "__esModule", {
  value: !0,
});
const yk = CT(ph),
  xk = CT(Tc),
  Sk = _h;
let wk = class RT {
  constructor(e, { headers: n = {}, schema: i, fetch: r } = {}) {
    (this.url = e),
      (this.headers = Object.assign(Object.assign({}, Sk.DEFAULT_HEADERS), n)),
      (this.schemaName = i),
      (this.fetch = r);
  }
  from(e) {
    const n = new URL(`${this.url}/${e}`);
    return new yk.default(n, {
      headers: Object.assign({}, this.headers),
      schema: this.schemaName,
      fetch: this.fetch,
    });
  }
  schema(e) {
    return new RT(this.url, {
      headers: this.headers,
      schema: e,
      fetch: this.fetch,
    });
  }
  rpc(e, n = {}, { head: i = !1, get: r = !1, count: s } = {}) {
    let a;
    const o = new URL(`${this.url}/rpc/${e}`);
    let l;
    i || r
      ? ((a = i ? "HEAD" : "GET"),
        Object.entries(n)
          .filter(([u, d]) => d !== void 0)
          .map(([u, d]) => [u, Array.isArray(d) ? `{${d.join(",")}}` : `${d}`])
          .forEach(([u, d]) => {
            o.searchParams.append(u, d);
          }))
      : ((a = "POST"), (l = n));
    const c = Object.assign({}, this.headers);
    return (
      s && (c.Prefer = `count=${s}`),
      new xk.default({
        method: a,
        url: o,
        headers: c,
        schema: this.schemaName,
        body: l,
        fetch: this.fetch,
        allowEmpty: !1,
      })
    );
  }
};
Ev.default = wk;
var Do =
  (ri && ri.__importDefault) ||
  function (t) {
    return t && t.__esModule
      ? t
      : {
          default: t,
        };
  };
Object.defineProperty(An, "__esModule", {
  value: !0,
});
An.PostgrestError =
  An.PostgrestBuilder =
  An.PostgrestTransformBuilder =
  An.PostgrestFilterBuilder =
  An.PostgrestQueryBuilder =
  An.PostgrestClient =
    void 0;
const PT = Do(Ev);
An.PostgrestClient = PT.default;
const LT = Do(ph);
An.PostgrestQueryBuilder = LT.default;
const NT = Do(Tc);
An.PostgrestFilterBuilder = NT.default;
const DT = Do(mh);
An.PostgrestTransformBuilder = DT.default;
const kT = Do(gh);
An.PostgrestBuilder = kT.default;
const IT = Do(vh);
An.PostgrestError = IT.default;
var Ek = (An.default = {
  PostgrestClient: PT.default,
  PostgrestQueryBuilder: LT.default,
  PostgrestFilterBuilder: NT.default,
  PostgrestTransformBuilder: DT.default,
  PostgrestBuilder: kT.default,
  PostgrestError: IT.default,
});
const {
    PostgrestClient: Tk,
    PostgrestQueryBuilder: Jj,
    PostgrestFilterBuilder: Qj,
    PostgrestTransformBuilder: eV,
    PostgrestBuilder: tV,
    PostgrestError: nV,
  } = Ek,
  Mk = "2.11.2",
  bk = {
    "X-Client-Info": `realtime-js/${Mk}`,
  },
  Ak = "1.0.0",
  UT = 1e4,
  Ck = 1e3;
var no;
(function (t) {
  (t[(t.connecting = 0)] = "connecting"),
    (t[(t.open = 1)] = "open"),
    (t[(t.closing = 2)] = "closing"),
    (t[(t.closed = 3)] = "closed");
})(no || (no = {}));
var Bn;
(function (t) {
  (t.closed = "closed"),
    (t.errored = "errored"),
    (t.joined = "joined"),
    (t.joining = "joining"),
    (t.leaving = "leaving");
})(Bn || (Bn = {}));
var mi;
(function (t) {
  (t.close = "phx_close"),
    (t.error = "phx_error"),
    (t.join = "phx_join"),
    (t.reply = "phx_reply"),
    (t.leave = "phx_leave"),
    (t.access_token = "access_token");
})(mi || (mi = {}));
var Sm;
(function (t) {
  t.websocket = "websocket";
})(Sm || (Sm = {}));
var Ls;
(function (t) {
  (t.Connecting = "connecting"),
    (t.Open = "open"),
    (t.Closing = "closing"),
    (t.Closed = "closed");
})(Ls || (Ls = {}));
class Rk {
  constructor() {
    this.HEADER_LENGTH = 1;
  }
  decode(e, n) {
    return e.constructor === ArrayBuffer
      ? n(this._binaryDecode(e))
      : n(typeof e == "string" ? JSON.parse(e) : {});
  }
  _binaryDecode(e) {
    const n = new DataView(e),
      i = new TextDecoder();
    return this._decodeBroadcast(e, n, i);
  }
  _decodeBroadcast(e, n, i) {
    const r = n.getUint8(1),
      s = n.getUint8(2);
    let a = this.HEADER_LENGTH + 2;
    const o = i.decode(e.slice(a, a + r));
    a = a + r;
    const l = i.decode(e.slice(a, a + s));
    a = a + s;
    const c = JSON.parse(i.decode(e.slice(a, e.byteLength)));
    return {
      ref: null,
      topic: o,
      event: l,
      payload: c,
    };
  }
}
class OT {
  constructor(e, n) {
    (this.callback = e),
      (this.timerCalc = n),
      (this.timer = void 0),
      (this.tries = 0),
      (this.callback = e),
      (this.timerCalc = n);
  }
  reset() {
    (this.tries = 0), clearTimeout(this.timer);
  }
  scheduleTimeout() {
    clearTimeout(this.timer),
      (this.timer = setTimeout(() => {
        (this.tries = this.tries + 1), this.callback();
      }, this.timerCalc(this.tries + 1)));
  }
}
var pt;
(function (t) {
  (t.abstime = "abstime"),
    (t.bool = "bool"),
    (t.date = "date"),
    (t.daterange = "daterange"),
    (t.float4 = "float4"),
    (t.float8 = "float8"),
    (t.int2 = "int2"),
    (t.int4 = "int4"),
    (t.int4range = "int4range"),
    (t.int8 = "int8"),
    (t.int8range = "int8range"),
    (t.json = "json"),
    (t.jsonb = "jsonb"),
    (t.money = "money"),
    (t.numeric = "numeric"),
    (t.oid = "oid"),
    (t.reltime = "reltime"),
    (t.text = "text"),
    (t.time = "time"),
    (t.timestamp = "timestamp"),
    (t.timestamptz = "timestamptz"),
    (t.timetz = "timetz"),
    (t.tsrange = "tsrange"),
    (t.tstzrange = "tstzrange");
})(pt || (pt = {}));
const Ry = (t, e, n = {}) => {
    var i;
    const r = (i = n.skipTypes) !== null && i !== void 0 ? i : [];
    return Object.keys(e).reduce((s, a) => ((s[a] = Pk(a, t, e, r)), s), {});
  },
  Pk = (t, e, n, i) => {
    const r = e.find((o) => o.name === t),
      s = r == null ? void 0 : r.type,
      a = n[t];
    return s && !i.includes(s) ? FT(s, a) : wm(a);
  },
  FT = (t, e) => {
    if (t.charAt(0) === "_") {
      const n = t.slice(1, t.length);
      return kk(e, n);
    }
    switch (t) {
      case pt.bool:
        return Lk(e);
      case pt.float4:
      case pt.float8:
      case pt.int2:
      case pt.int4:
      case pt.int8:
      case pt.numeric:
      case pt.oid:
        return Nk(e);
      case pt.json:
      case pt.jsonb:
        return Dk(e);
      case pt.timestamp:
        return Ik(e);
      case pt.abstime:
      case pt.date:
      case pt.daterange:
      case pt.int4range:
      case pt.int8range:
      case pt.money:
      case pt.reltime:
      case pt.text:
      case pt.time:
      case pt.timestamptz:
      case pt.timetz:
      case pt.tsrange:
      case pt.tstzrange:
        return wm(e);
      default:
        return wm(e);
    }
  },
  wm = (t) => t,
  Lk = (t) => {
    switch (t) {
      case "t":
        return !0;
      case "f":
        return !1;
      default:
        return t;
    }
  },
  Nk = (t) => {
    if (typeof t == "string") {
      const e = parseFloat(t);
      if (!Number.isNaN(e)) return e;
    }
    return t;
  },
  Dk = (t) => {
    if (typeof t == "string")
      try {
        return JSON.parse(t);
      } catch (e) {
        return console.log(`JSON parse error: ${e}`), t;
      }
    return t;
  },
  kk = (t, e) => {
    if (typeof t != "string") return t;
    const n = t.length - 1,
      i = t[n];
    if (t[0] === "{" && i === "}") {
      let s;
      const a = t.slice(1, n);
      try {
        s = JSON.parse("[" + a + "]");
      } catch {
        s = a ? a.split(",") : [];
      }
      return s.map((o) => FT(e, o));
    }
    return t;
  },
  Ik = (t) => (typeof t == "string" ? t.replace(" ", "T") : t),
  BT = (t) => {
    let e = t;
    return (
      (e = e.replace(/^ws/i, "http")),
      (e = e.replace(/(\/socket\/websocket|\/socket|\/websocket)\/?$/i, "")),
      e.replace(/\/+$/, "")
    );
  };
class xf {
  constructor(e, n, i = {}, r = UT) {
    (this.channel = e),
      (this.event = n),
      (this.payload = i),
      (this.timeout = r),
      (this.sent = !1),
      (this.timeoutTimer = void 0),
      (this.ref = ""),
      (this.receivedResp = null),
      (this.recHooks = []),
      (this.refEvent = null);
  }
  resend(e) {
    (this.timeout = e),
      this._cancelRefEvent(),
      (this.ref = ""),
      (this.refEvent = null),
      (this.receivedResp = null),
      (this.sent = !1),
      this.send();
  }
  send() {
    this._hasReceived("timeout") ||
      (this.startTimeout(),
      (this.sent = !0),
      this.channel.socket.push({
        topic: this.channel.topic,
        event: this.event,
        payload: this.payload,
        ref: this.ref,
        join_ref: this.channel._joinRef(),
      }));
  }
  updatePayload(e) {
    this.payload = Object.assign(Object.assign({}, this.payload), e);
  }
  receive(e, n) {
    var i;
    return (
      this._hasReceived(e) &&
        n(
          (i = this.receivedResp) === null || i === void 0 ? void 0 : i.response
        ),
      this.recHooks.push({
        status: e,
        callback: n,
      }),
      this
    );
  }
  startTimeout() {
    if (this.timeoutTimer) return;
    (this.ref = this.channel.socket._makeRef()),
      (this.refEvent = this.channel._replyEventName(this.ref));
    const e = (n) => {
      this._cancelRefEvent(),
        this._cancelTimeout(),
        (this.receivedResp = n),
        this._matchReceive(n);
    };
    this.channel._on(this.refEvent, {}, e),
      (this.timeoutTimer = setTimeout(() => {
        this.trigger("timeout", {});
      }, this.timeout));
  }
  trigger(e, n) {
    this.refEvent &&
      this.channel._trigger(this.refEvent, {
        status: e,
        response: n,
      });
  }
  destroy() {
    this._cancelRefEvent(), this._cancelTimeout();
  }
  _cancelRefEvent() {
    this.refEvent && this.channel._off(this.refEvent, {});
  }
  _cancelTimeout() {
    clearTimeout(this.timeoutTimer), (this.timeoutTimer = void 0);
  }
  _matchReceive({ status: e, response: n }) {
    this.recHooks.filter((i) => i.status === e).forEach((i) => i.callback(n));
  }
  _hasReceived(e) {
    return this.receivedResp && this.receivedResp.status === e;
  }
}
var Py;
(function (t) {
  (t.SYNC = "sync"), (t.JOIN = "join"), (t.LEAVE = "leave");
})(Py || (Py = {}));
class bl {
  constructor(e, n) {
    (this.channel = e),
      (this.state = {}),
      (this.pendingDiffs = []),
      (this.joinRef = null),
      (this.caller = {
        onJoin: () => {},
        onLeave: () => {},
        onSync: () => {},
      });
    const i = (n == null ? void 0 : n.events) || {
      state: "presence_state",
      diff: "presence_diff",
    };
    this.channel._on(i.state, {}, (r) => {
      const { onJoin: s, onLeave: a, onSync: o } = this.caller;
      (this.joinRef = this.channel._joinRef()),
        (this.state = bl.syncState(this.state, r, s, a)),
        this.pendingDiffs.forEach((l) => {
          this.state = bl.syncDiff(this.state, l, s, a);
        }),
        (this.pendingDiffs = []),
        o();
    }),
      this.channel._on(i.diff, {}, (r) => {
        const { onJoin: s, onLeave: a, onSync: o } = this.caller;
        this.inPendingSyncState()
          ? this.pendingDiffs.push(r)
          : ((this.state = bl.syncDiff(this.state, r, s, a)), o());
      }),
      this.onJoin((r, s, a) => {
        this.channel._trigger("presence", {
          event: "join",
          key: r,
          currentPresences: s,
          newPresences: a,
        });
      }),
      this.onLeave((r, s, a) => {
        this.channel._trigger("presence", {
          event: "leave",
          key: r,
          currentPresences: s,
          leftPresences: a,
        });
      }),
      this.onSync(() => {
        this.channel._trigger("presence", {
          event: "sync",
        });
      });
  }
  static syncState(e, n, i, r) {
    const s = this.cloneDeep(e),
      a = this.transformState(n),
      o = {},
      l = {};
    return (
      this.map(s, (c, u) => {
        a[c] || (l[c] = u);
      }),
      this.map(a, (c, u) => {
        const d = s[c];
        if (d) {
          const h = u.map((m) => m.presence_ref),
            p = d.map((m) => m.presence_ref),
            v = u.filter((m) => p.indexOf(m.presence_ref) < 0),
            x = d.filter((m) => h.indexOf(m.presence_ref) < 0);
          v.length > 0 && (o[c] = v), x.length > 0 && (l[c] = x);
        } else o[c] = u;
      }),
      this.syncDiff(
        s,
        {
          joins: o,
          leaves: l,
        },
        i,
        r
      )
    );
  }
  static syncDiff(e, n, i, r) {
    const { joins: s, leaves: a } = {
      joins: this.transformState(n.joins),
      leaves: this.transformState(n.leaves),
    };
    return (
      i || (i = () => {}),
      r || (r = () => {}),
      this.map(s, (o, l) => {
        var c;
        const u = (c = e[o]) !== null && c !== void 0 ? c : [];
        if (((e[o] = this.cloneDeep(l)), u.length > 0)) {
          const d = e[o].map((p) => p.presence_ref),
            h = u.filter((p) => d.indexOf(p.presence_ref) < 0);
          e[o].unshift(...h);
        }
        i(o, u, l);
      }),
      this.map(a, (o, l) => {
        let c = e[o];
        if (!c) return;
        const u = l.map((d) => d.presence_ref);
        (c = c.filter((d) => u.indexOf(d.presence_ref) < 0)),
          (e[o] = c),
          r(o, c, l),
          c.length === 0 && delete e[o];
      }),
      e
    );
  }
  static map(e, n) {
    return Object.getOwnPropertyNames(e).map((i) => n(i, e[i]));
  }
  static transformState(e) {
    return (
      (e = this.cloneDeep(e)),
      Object.getOwnPropertyNames(e).reduce((n, i) => {
        const r = e[i];
        return (
          "metas" in r
            ? (n[i] = r.metas.map(
                (s) => (
                  (s.presence_ref = s.phx_ref),
                  delete s.phx_ref,
                  delete s.phx_ref_prev,
                  s
                )
              ))
            : (n[i] = r),
          n
        );
      }, {})
    );
  }
  static cloneDeep(e) {
    return JSON.parse(JSON.stringify(e));
  }
  onJoin(e) {
    this.caller.onJoin = e;
  }
  onLeave(e) {
    this.caller.onLeave = e;
  }
  onSync(e) {
    this.caller.onSync = e;
  }
  inPendingSyncState() {
    return !this.joinRef || this.joinRef !== this.channel._joinRef();
  }
}
var Ly;
(function (t) {
  (t.ALL = "*"),
    (t.INSERT = "INSERT"),
    (t.UPDATE = "UPDATE"),
    (t.DELETE = "DELETE");
})(Ly || (Ly = {}));
var Ny;
(function (t) {
  (t.BROADCAST = "broadcast"),
    (t.PRESENCE = "presence"),
    (t.POSTGRES_CHANGES = "postgres_changes"),
    (t.SYSTEM = "system");
})(Ny || (Ny = {}));
var Qi;
(function (t) {
  (t.SUBSCRIBED = "SUBSCRIBED"),
    (t.TIMED_OUT = "TIMED_OUT"),
    (t.CLOSED = "CLOSED"),
    (t.CHANNEL_ERROR = "CHANNEL_ERROR");
})(Qi || (Qi = {}));
class Tv {
  constructor(
    e,
    n = {
      config: {},
    },
    i
  ) {
    (this.topic = e),
      (this.params = n),
      (this.socket = i),
      (this.bindings = {}),
      (this.state = Bn.closed),
      (this.joinedOnce = !1),
      (this.pushBuffer = []),
      (this.subTopic = e.replace(/^realtime:/i, "")),
      (this.params.config = Object.assign(
        {
          broadcast: {
            ack: !1,
            self: !1,
          },
          presence: {
            key: "",
          },
          private: !1,
        },
        n.config
      )),
      (this.timeout = this.socket.timeout),
      (this.joinPush = new xf(this, mi.join, this.params, this.timeout)),
      (this.rejoinTimer = new OT(
        () => this._rejoinUntilConnected(),
        this.socket.reconnectAfterMs
      )),
      this.joinPush.receive("ok", () => {
        (this.state = Bn.joined),
          this.rejoinTimer.reset(),
          this.pushBuffer.forEach((r) => r.send()),
          (this.pushBuffer = []);
      }),
      this._onClose(() => {
        this.rejoinTimer.reset(),
          this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
          (this.state = Bn.closed),
          this.socket._remove(this);
      }),
      this._onError((r) => {
        this._isLeaving() ||
          this._isClosed() ||
          (this.socket.log("channel", `error ${this.topic}`, r),
          (this.state = Bn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this.joinPush.receive("timeout", () => {
        this._isJoining() &&
          (this.socket.log(
            "channel",
            `timeout ${this.topic}`,
            this.joinPush.timeout
          ),
          (this.state = Bn.errored),
          this.rejoinTimer.scheduleTimeout());
      }),
      this._on(mi.reply, {}, (r, s) => {
        this._trigger(this._replyEventName(s), r);
      }),
      (this.presence = new bl(this)),
      (this.broadcastEndpointURL = BT(this.socket.endPoint) + "/api/broadcast"),
      (this.private = this.params.config.private || !1);
  }
  subscribe(e, n = this.timeout) {
    var i, r;
    if ((this.socket.isConnected() || this.socket.connect(), this.joinedOnce))
      throw "tried to subscribe multiple times. 'subscribe' can only be called a single time per channel instance";
    {
      const {
        config: { broadcast: s, presence: a, private: o },
      } = this.params;
      this._onError((u) => (e == null ? void 0 : e(Qi.CHANNEL_ERROR, u))),
        this._onClose(() => (e == null ? void 0 : e(Qi.CLOSED)));
      const l = {},
        c = {
          broadcast: s,
          presence: a,
          postgres_changes:
            (r =
              (i = this.bindings.postgres_changes) === null || i === void 0
                ? void 0
                : i.map((u) => u.filter)) !== null && r !== void 0
              ? r
              : [],
          private: o,
        };
      this.socket.accessTokenValue &&
        (l.access_token = this.socket.accessTokenValue),
        this.updateJoinPayload(
          Object.assign(
            {
              config: c,
            },
            l
          )
        ),
        (this.joinedOnce = !0),
        this._rejoin(n),
        this.joinPush
          .receive("ok", async ({ postgres_changes: u }) => {
            var d;
            if ((this.socket.setAuth(), u === void 0)) {
              e == null || e(Qi.SUBSCRIBED);
              return;
            } else {
              const h = this.bindings.postgres_changes,
                p =
                  (d = h == null ? void 0 : h.length) !== null && d !== void 0
                    ? d
                    : 0,
                v = [];
              for (let x = 0; x < p; x++) {
                const m = h[x],
                  {
                    filter: { event: f, schema: y, table: g, filter: S },
                  } = m,
                  T = u && u[x];
                if (
                  T &&
                  T.event === f &&
                  T.schema === y &&
                  T.table === g &&
                  T.filter === S
                )
                  v.push(
                    Object.assign(Object.assign({}, m), {
                      id: T.id,
                    })
                  );
                else {
                  this.unsubscribe(),
                    e == null ||
                      e(
                        Qi.CHANNEL_ERROR,
                        new Error(
                          "mismatch between server and client bindings for postgres changes"
                        )
                      );
                  return;
                }
              }
              (this.bindings.postgres_changes = v), e && e(Qi.SUBSCRIBED);
              return;
            }
          })
          .receive("error", (u) => {
            e == null ||
              e(
                Qi.CHANNEL_ERROR,
                new Error(
                  JSON.stringify(Object.values(u).join(", ") || "error")
                )
              );
          })
          .receive("timeout", () => {
            e == null || e(Qi.TIMED_OUT);
          });
    }
    return this;
  }
  presenceState() {
    return this.presence.state;
  }
  async track(e, n = {}) {
    return await this.send(
      {
        type: "presence",
        event: "track",
        payload: e,
      },
      n.timeout || this.timeout
    );
  }
  async untrack(e = {}) {
    return await this.send(
      {
        type: "presence",
        event: "untrack",
      },
      e
    );
  }
  on(e, n, i) {
    return this._on(e, n, i);
  }
  async send(e, n = {}) {
    var i, r;
    if (!this._canPush() && e.type === "broadcast") {
      const { event: s, payload: a } = e,
        l = {
          method: "POST",
          headers: {
            Authorization: this.socket.accessTokenValue
              ? `Bearer ${this.socket.accessTokenValue}`
              : "",
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            messages: [
              {
                topic: this.subTopic,
                event: s,
                payload: a,
                private: this.private,
              },
            ],
          }),
        };
      try {
        const c = await this._fetchWithTimeout(
          this.broadcastEndpointURL,
          l,
          (i = n.timeout) !== null && i !== void 0 ? i : this.timeout
        );
        return (
          await ((r = c.body) === null || r === void 0 ? void 0 : r.cancel()),
          c.ok ? "ok" : "error"
        );
      } catch (c) {
        return c.name === "AbortError" ? "timed out" : "error";
      }
    } else
      return new Promise((s) => {
        var a, o, l;
        const c = this._push(e.type, e, n.timeout || this.timeout);
        e.type === "broadcast" &&
          !(
            !(
              (l =
                (o =
                  (a = this.params) === null || a === void 0
                    ? void 0
                    : a.config) === null || o === void 0
                  ? void 0
                  : o.broadcast) === null || l === void 0
            ) && l.ack
          ) &&
          s("ok"),
          c.receive("ok", () => s("ok")),
          c.receive("error", () => s("error")),
          c.receive("timeout", () => s("timed out"));
      });
  }
  updateJoinPayload(e) {
    this.joinPush.updatePayload(e);
  }
  unsubscribe(e = this.timeout) {
    this.state = Bn.leaving;
    const n = () => {
      this.socket.log("channel", `leave ${this.topic}`),
        this._trigger(mi.close, "leave", this._joinRef());
    };
    return (
      this.rejoinTimer.reset(),
      this.joinPush.destroy(),
      new Promise((i) => {
        const r = new xf(this, mi.leave, {}, e);
        r
          .receive("ok", () => {
            n(), i("ok");
          })
          .receive("timeout", () => {
            n(), i("timed out");
          })
          .receive("error", () => {
            i("error");
          }),
          r.send(),
          this._canPush() || r.trigger("ok", {});
      })
    );
  }
  async _fetchWithTimeout(e, n, i) {
    const r = new AbortController(),
      s = setTimeout(() => r.abort(), i),
      a = await this.socket.fetch(
        e,
        Object.assign(Object.assign({}, n), {
          signal: r.signal,
        })
      );
    return clearTimeout(s), a;
  }
  _push(e, n, i = this.timeout) {
    if (!this.joinedOnce)
      throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
    let r = new xf(this, e, n, i);
    return (
      this._canPush() ? r.send() : (r.startTimeout(), this.pushBuffer.push(r)),
      r
    );
  }
  _onMessage(e, n, i) {
    return n;
  }
  _isMember(e) {
    return this.topic === e;
  }
  _joinRef() {
    return this.joinPush.ref;
  }
  _trigger(e, n, i) {
    var r, s;
    const a = e.toLocaleLowerCase(),
      { close: o, error: l, leave: c, join: u } = mi;
    if (i && [o, l, c, u].indexOf(a) >= 0 && i !== this._joinRef()) return;
    let h = this._onMessage(a, n, i);
    if (n && !h)
      throw "channel onMessage callbacks must return the payload, modified or unmodified";
    ["insert", "update", "delete"].includes(a)
      ? (r = this.bindings.postgres_changes) === null ||
        r === void 0 ||
        r
          .filter((p) => {
            var v, x, m;
            return (
              ((v = p.filter) === null || v === void 0 ? void 0 : v.event) ===
                "*" ||
              ((m =
                (x = p.filter) === null || x === void 0 ? void 0 : x.event) ===
                null || m === void 0
                ? void 0
                : m.toLocaleLowerCase()) === a
            );
          })
          .map((p) => p.callback(h, i))
      : (s = this.bindings[a]) === null ||
        s === void 0 ||
        s
          .filter((p) => {
            var v, x, m, f, y, g;
            if (["broadcast", "presence", "postgres_changes"].includes(a))
              if ("id" in p) {
                const S = p.id,
                  T =
                    (v = p.filter) === null || v === void 0 ? void 0 : v.event;
                return (
                  S &&
                  ((x = n.ids) === null || x === void 0
                    ? void 0
                    : x.includes(S)) &&
                  (T === "*" ||
                    (T == null ? void 0 : T.toLocaleLowerCase()) ===
                      ((m = n.data) === null || m === void 0
                        ? void 0
                        : m.type.toLocaleLowerCase()))
                );
              } else {
                const S =
                  (y =
                    (f = p == null ? void 0 : p.filter) === null || f === void 0
                      ? void 0
                      : f.event) === null || y === void 0
                    ? void 0
                    : y.toLocaleLowerCase();
                return (
                  S === "*" ||
                  S ===
                    ((g = n == null ? void 0 : n.event) === null || g === void 0
                      ? void 0
                      : g.toLocaleLowerCase())
                );
              }
            else return p.type.toLocaleLowerCase() === a;
          })
          .map((p) => {
            if (typeof h == "object" && "ids" in h) {
              const v = h.data,
                {
                  schema: x,
                  table: m,
                  commit_timestamp: f,
                  type: y,
                  errors: g,
                } = v;
              h = Object.assign(
                Object.assign(
                  {},
                  {
                    schema: x,
                    table: m,
                    commit_timestamp: f,
                    eventType: y,
                    new: {},
                    old: {},
                    errors: g,
                  }
                ),
                this._getPayloadRecords(v)
              );
            }
            p.callback(h, i);
          });
  }
  _isClosed() {
    return this.state === Bn.closed;
  }
  _isJoined() {
    return this.state === Bn.joined;
  }
  _isJoining() {
    return this.state === Bn.joining;
  }
  _isLeaving() {
    return this.state === Bn.leaving;
  }
  _replyEventName(e) {
    return `chan_reply_${e}`;
  }
  _on(e, n, i) {
    const r = e.toLocaleLowerCase(),
      s = {
        type: r,
        filter: n,
        callback: i,
      };
    return (
      this.bindings[r] ? this.bindings[r].push(s) : (this.bindings[r] = [s]),
      this
    );
  }
  _off(e, n) {
    const i = e.toLocaleLowerCase();
    return (
      (this.bindings[i] = this.bindings[i].filter((r) => {
        var s;
        return !(
          ((s = r.type) === null || s === void 0
            ? void 0
            : s.toLocaleLowerCase()) === i && Tv.isEqual(r.filter, n)
        );
      })),
      this
    );
  }
  static isEqual(e, n) {
    if (Object.keys(e).length !== Object.keys(n).length) return !1;
    for (const i in e) if (e[i] !== n[i]) return !1;
    return !0;
  }
  _rejoinUntilConnected() {
    this.rejoinTimer.scheduleTimeout(),
      this.socket.isConnected() && this._rejoin();
  }
  _onClose(e) {
    this._on(mi.close, {}, e);
  }
  _onError(e) {
    this._on(mi.error, {}, (n) => e(n));
  }
  _canPush() {
    return this.socket.isConnected() && this._isJoined();
  }
  _rejoin(e = this.timeout) {
    this._isLeaving() ||
      (this.socket._leaveOpenTopic(this.topic),
      (this.state = Bn.joining),
      this.joinPush.resend(e));
  }
  _getPayloadRecords(e) {
    const n = {
      new: {},
      old: {},
    };
    return (
      (e.type === "INSERT" || e.type === "UPDATE") &&
        (n.new = Ry(e.columns, e.record)),
      (e.type === "UPDATE" || e.type === "DELETE") &&
        (n.old = Ry(e.columns, e.old_record)),
      n
    );
  }
}
const Uk = () => {},
  Ok = typeof WebSocket < "u",
  Fk = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;

class Bk {
  constructor(e, n) {
    var i;
    (this.accessTokenValue = null),
      (this.apiKey = null),
      (this.channels = []),
      (this.endPoint = ""),
      (this.httpEndpoint = ""),
      (this.headers = bk),
      (this.params = {}),
      (this.timeout = UT),
      (this.heartbeatIntervalMs = 3e4),
      (this.heartbeatTimer = void 0),
      (this.pendingHeartbeatRef = null),
      (this.ref = 0),
      (this.logger = Uk),
      (this.conn = null),
      (this.sendBuffer = []),
      (this.serializer = new Rk()),
      (this.stateChangeCallbacks = {
        open: [],
        close: [],
        error: [],
        message: [],
      }),
      (this.accessToken = null),
      (this._resolveFetch = (s) => {
        let a;
        return (
          s
            ? (a = s)
            : typeof fetch > "u"
            ? (a = (...o) =>
                go(async () => {
                  const { default: l } = await Promise.resolve().then(() => No);
                  return {
                    default: l,
                  };
                }, void 0).then(({ default: l }) => l(...o)))
            : (a = fetch),
          (...o) => a(...o)
        );
      }),
      (this.endPoint = `${e}/${Sm.websocket}`),
      (this.httpEndpoint = BT(e)),
      n != null && n.transport
        ? (this.transport = n.transport)
        : (this.transport = null),
      n != null && n.params && (this.params = n.params),
      n != null &&
        n.headers &&
        (this.headers = Object.assign(
          Object.assign({}, this.headers),
          n.headers
        )),
      n != null && n.timeout && (this.timeout = n.timeout),
      n != null && n.logger && (this.logger = n.logger),
      n != null &&
        n.heartbeatIntervalMs &&
        (this.heartbeatIntervalMs = n.heartbeatIntervalMs);
    const r =
      (i = n == null ? void 0 : n.params) === null || i === void 0
        ? void 0
        : i.apikey;
    if (
      (r && ((this.accessTokenValue = r), (this.apiKey = r)),
      (this.reconnectAfterMs =
        n != null && n.reconnectAfterMs
          ? n.reconnectAfterMs
          : (s) => [1e3, 2e3, 5e3, 1e4][s - 1] || 1e4),
      (this.encode =
        n != null && n.encode ? n.encode : (s, a) => a(JSON.stringify(s))),
      (this.decode =
        n != null && n.decode
          ? n.decode
          : this.serializer.decode.bind(this.serializer)),
      (this.reconnectTimer = new OT(async () => {
        this.disconnect(), this.connect();
      }, this.reconnectAfterMs)),
      (this.fetch = this._resolveFetch(n == null ? void 0 : n.fetch)),
      n != null && n.worker)
    ) {
      if (typeof window < "u" && !window.Worker)
        throw new Error("Web Worker is not supported");
      (this.worker = (n == null ? void 0 : n.worker) || !1),
        (this.workerUrl = n == null ? void 0 : n.workerUrl);
    }
    this.accessToken = (n == null ? void 0 : n.accessToken) || null;
  }
  connect() {
    if (!this.conn) {
      if (this.transport) {
        this.conn = new this.transport(this.endpointURL(), void 0, {
          headers: this.headers,
        });
        return;
      }
      if (Ok) {
        (this.conn = new WebSocket(this.endpointURL())), this.setupConnection();
        return;
      }
      (this.conn = new zk(this.endpointURL(), void 0, {
        close: () => {
          this.conn = null;
        },
      })),
        go(async () => {
          const { default: e } = await import("./browser-CW-d5XKJ.js").then(
            (n) => n.b
          );
          return {
            default: e,
          };
        }, []).then(({ default: e }) => {
          (this.conn = new e(this.endpointURL(), void 0, {
            headers: this.headers,
          })),
            this.setupConnection();
        });
    }
  }
  endpointURL() {
    return this._appendParams(
      this.endPoint,
      Object.assign({}, this.params, {
        vsn: Ak,
      })
    );
  }
  disconnect(e, n) {
    this.conn &&
      ((this.conn.onclose = function () {}),
      e ? this.conn.close(e, n ?? "") : this.conn.close(),
      (this.conn = null),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.reset());
  }
  getChannels() {
    return this.channels;
  }
  async removeChannel(e) {
    const n = await e.unsubscribe();
    return this.channels.length === 0 && this.disconnect(), n;
  }
  async removeAllChannels() {
    const e = await Promise.all(this.channels.map((n) => n.unsubscribe()));
    return this.disconnect(), e;
  }
  log(e, n, i) {
    this.logger(e, n, i);
  }
  connectionState() {
    switch (this.conn && this.conn.readyState) {
      case no.connecting:
        return Ls.Connecting;
      case no.open:
        return Ls.Open;
      case no.closing:
        return Ls.Closing;
      default:
        return Ls.Closed;
    }
  }
  isConnected() {
    return this.connectionState() === Ls.Open;
  }
  channel(
    e,
    n = {
      config: {},
    }
  ) {
    const i = new Tv(`realtime:${e}`, n, this);
    return this.channels.push(i), i;
  }
  push(e) {
    const { topic: n, event: i, payload: r, ref: s } = e,
      a = () => {
        this.encode(e, (o) => {
          var l;
          (l = this.conn) === null || l === void 0 || l.send(o);
        });
      };
    this.log("push", `${n} ${i} (${s})`, r),
      this.isConnected() ? a() : this.sendBuffer.push(a);
  }
  async setAuth(e = null) {
    let n =
      e ||
      (this.accessToken && (await this.accessToken())) ||
      this.accessTokenValue;
    if (n) {
      let i = null;
      try {
        i = JSON.parse(atob(n.split(".")[1]));
      } catch {}
      if (i && i.exp && !(Math.floor(Date.now() / 1e3) - i.exp < 0))
        return (
          this.log(
            "auth",
            `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${i.exp}`
          ),
          Promise.reject(
            `InvalidJWTToken: Invalid value for JWT claim "exp" with value ${i.exp}`
          )
        );
      (this.accessTokenValue = n),
        this.channels.forEach((r) => {
          n &&
            r.updateJoinPayload({
              access_token: n,
            }),
            r.joinedOnce &&
              r._isJoined() &&
              r._push(mi.access_token, {
                access_token: n,
              });
        });
    }
  }
  async sendHeartbeat() {
    var e;
    if (this.isConnected()) {
      if (this.pendingHeartbeatRef) {
        (this.pendingHeartbeatRef = null),
          this.log(
            "transport",
            "heartbeat timeout. Attempting to re-establish connection"
          ),
          (e = this.conn) === null ||
            e === void 0 ||
            e.close(Ck, "hearbeat timeout");
        return;
      }
      (this.pendingHeartbeatRef = this._makeRef()),
        this.push({
          topic: "phoenix",
          event: "heartbeat",
          payload: {},
          ref: this.pendingHeartbeatRef,
        }),
        this.setAuth();
    }
  }
  flushSendBuffer() {
    this.isConnected() &&
      this.sendBuffer.length > 0 &&
      (this.sendBuffer.forEach((e) => e()), (this.sendBuffer = []));
  }
  _makeRef() {
    let e = this.ref + 1;
    return (
      e === this.ref ? (this.ref = 0) : (this.ref = e), this.ref.toString()
    );
  }
  _leaveOpenTopic(e) {
    let n = this.channels.find(
      (i) => i.topic === e && (i._isJoined() || i._isJoining())
    );
    n &&
      (this.log("transport", `leaving duplicate topic "${e}"`),
      n.unsubscribe());
  }
  _remove(e) {
    this.channels = this.channels.filter((n) => n._joinRef() !== e._joinRef());
  }
  setupConnection() {
    this.conn &&
      ((this.conn.binaryType = "arraybuffer"),
      (this.conn.onopen = () => this._onConnOpen()),
      (this.conn.onerror = (e) => this._onConnError(e)),
      (this.conn.onmessage = (e) => this._onConnMessage(e)),
      (this.conn.onclose = (e) => this._onConnClose(e)));
  }
  _onConnMessage(e) {
    this.decode(e.data, (n) => {
      let { topic: i, event: r, payload: s, ref: a } = n;
      a && a === this.pendingHeartbeatRef && (this.pendingHeartbeatRef = null),
        this.log(
          "receive",
          `${s.status || ""} ${i} ${r} ${(a && "(" + a + ")") || ""}`,
          s
        ),
        this.channels
          .filter((o) => o._isMember(i))
          .forEach((o) => o._trigger(r, s, a)),
        this.stateChangeCallbacks.message.forEach((o) => o(n));
    });
  }
  async _onConnOpen() {
    if (
      (this.log("transport", `connected to ${this.endpointURL()}`),
      this.flushSendBuffer(),
      this.reconnectTimer.reset(),
      !this.worker)
    )
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        (this.heartbeatTimer = setInterval(
          () => this.sendHeartbeat(),
          this.heartbeatIntervalMs
        ));
    else {
      this.workerUrl
        ? this.log("worker", `starting worker for from ${this.workerUrl}`)
        : this.log("worker", "starting default worker");
      const e = this._workerObjectUrl(this.workerUrl);
      (this.workerRef = new Worker(e)),
        (this.workerRef.onerror = (n) => {
          this.log("worker", "worker error", n.message),
            this.workerRef.terminate();
        }),
        (this.workerRef.onmessage = (n) => {
          n.data.event === "keepAlive" && this.sendHeartbeat();
        }),
        this.workerRef.postMessage({
          event: "start",
          interval: this.heartbeatIntervalMs,
        });
    }
    this.stateChangeCallbacks.open.forEach((e) => e());
  }
  _onConnClose(e) {
    this.log("transport", "close", e),
      this._triggerChanError(),
      this.heartbeatTimer && clearInterval(this.heartbeatTimer),
      this.reconnectTimer.scheduleTimeout(),
      this.stateChangeCallbacks.close.forEach((n) => n(e));
  }
  _onConnError(e) {
    this.log("transport", e.message),
      this._triggerChanError(),
      this.stateChangeCallbacks.error.forEach((n) => n(e));
  }
  _triggerChanError() {
    this.channels.forEach((e) => e._trigger(mi.error));
  }
  _appendParams(e, n) {
    if (Object.keys(n).length === 0) return e;
    const i = e.match(/\?/) ? "&" : "?",
      r = new URLSearchParams(n);
    return `${e}${i}${r}`;
  }
  _workerObjectUrl(e) {
    let n;
    if (e) n = e;
    else {
      const i = new Blob([Fk], {
        type: "application/javascript",
      });
      n = URL.createObjectURL(i);
    }
    return n;
  }
}
class zk {
  constructor(e, n, i) {
    (this.binaryType = "arraybuffer"),
      (this.onclose = () => {}),
      (this.onerror = () => {}),
      (this.onmessage = () => {}),
      (this.onopen = () => {}),
      (this.readyState = no.connecting),
      (this.send = () => {}),
      (this.url = null),
      (this.url = e),
      (this.close = i.close);
  }
}
class Mv extends Error {
  constructor(e) {
    super(e), (this.__isStorageError = !0), (this.name = "StorageError");
  }
}
function $t(t) {
  return typeof t == "object" && t !== null && "__isStorageError" in t;
}
class jk extends Mv {
  constructor(e, n) {
    super(e), (this.name = "StorageApiError"), (this.status = n);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
    };
  }
}
class Em extends Mv {
  constructor(e, n) {
    super(e), (this.name = "StorageUnknownError"), (this.originalError = n);
  }
}
var Vk = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
const zT = (t) => {
    let e;
    return (
      t
        ? (e = t)
        : typeof fetch > "u"
        ? (e = (...n) =>
            go(async () => {
              const { default: i } = await Promise.resolve().then(() => No);
              return {
                default: i,
              };
            }, void 0).then(({ default: i }) => i(...n)))
        : (e = fetch),
      (...n) => e(...n)
    );
  },
  Hk = () =>
    Vk(void 0, void 0, void 0, function* () {
      return typeof Response > "u"
        ? (yield go(() => Promise.resolve().then(() => No), void 0)).Response
        : Response;
    }),
  Tm = (t) => {
    if (Array.isArray(t)) return t.map((n) => Tm(n));
    if (typeof t == "function" || t !== Object(t)) return t;
    const e = {};
    return (
      Object.entries(t).forEach(([n, i]) => {
        const r = n.replace(/([-_][a-z])/gi, (s) =>
          s.toUpperCase().replace(/[-_]/g, "")
        );
        e[r] = Tm(i);
      }),
      e
    );
  };
var oa = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
const Sf = (t) =>
    t.msg || t.message || t.error_description || t.error || JSON.stringify(t),
  Gk = (t, e, n) =>
    oa(void 0, void 0, void 0, function* () {
      const i = yield Hk();
      t instanceof i && !(n != null && n.noResolveJson)
        ? t
            .json()
            .then((r) => {
              e(new jk(Sf(r), t.status || 500));
            })
            .catch((r) => {
              e(new Em(Sf(r), r));
            })
        : e(new Em(Sf(t), t));
    }),
  Wk = (t, e, n, i) => {
    const r = {
      method: t,
      headers: (e == null ? void 0 : e.headers) || {},
    };
    return t === "GET"
      ? r
      : ((r.headers = Object.assign(
          {
            "Content-Type": "application/json",
          },
          e == null ? void 0 : e.headers
        )),
        i && (r.body = JSON.stringify(i)),
        Object.assign(Object.assign({}, r), n));
  };
function Mc(t, e, n, i, r, s) {
  return oa(this, void 0, void 0, function* () {
    return new Promise((a, o) => {
      t(n, Wk(e, i, r, s))
        .then((l) => {
          if (!l.ok) throw l;
          return i != null && i.noResolveJson ? l : l.json();
        })
        .then((l) => a(l))
        .catch((l) => Gk(l, o, i));
    });
  });
}
function Rd(t, e, n, i) {
  return oa(this, void 0, void 0, function* () {
    return Mc(t, "GET", e, n, i);
  });
}
function Nr(t, e, n, i, r) {
  return oa(this, void 0, void 0, function* () {
    return Mc(t, "POST", e, i, r, n);
  });
}
function $k(t, e, n, i, r) {
  return oa(this, void 0, void 0, function* () {
    return Mc(t, "PUT", e, i, r, n);
  });
}
function Xk(t, e, n, i) {
  return oa(this, void 0, void 0, function* () {
    return Mc(
      t,
      "HEAD",
      e,
      Object.assign(Object.assign({}, n), {
        noResolveJson: !0,
      }),
      i
    );
  });
}
function jT(t, e, n, i, r) {
  return oa(this, void 0, void 0, function* () {
    return Mc(t, "DELETE", e, i, r, n);
  });
}
var En = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
const qk = {
    limit: 100,
    offset: 0,
    sortBy: {
      column: "name",
      order: "asc",
    },
  },
  Dy = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1,
  };
class Yk {
  constructor(e, n = {}, i, r) {
    (this.url = e),
      (this.headers = n),
      (this.bucketId = i),
      (this.fetch = zT(r));
  }
  uploadOrUpdate(e, n, i, r) {
    return En(this, void 0, void 0, function* () {
      try {
        let s;
        const a = Object.assign(Object.assign({}, Dy), r);
        let o = Object.assign(
          Object.assign({}, this.headers),
          e === "POST" && {
            "x-upsert": String(a.upsert),
          }
        );
        const l = a.metadata;
        typeof Blob < "u" && i instanceof Blob
          ? ((s = new FormData()),
            s.append("cacheControl", a.cacheControl),
            l && s.append("metadata", this.encodeMetadata(l)),
            s.append("", i))
          : typeof FormData < "u" && i instanceof FormData
          ? ((s = i),
            s.append("cacheControl", a.cacheControl),
            l && s.append("metadata", this.encodeMetadata(l)))
          : ((s = i),
            (o["cache-control"] = `max-age=${a.cacheControl}`),
            (o["content-type"] = a.contentType),
            l && (o["x-metadata"] = this.toBase64(this.encodeMetadata(l)))),
          r != null &&
            r.headers &&
            (o = Object.assign(Object.assign({}, o), r.headers));
        const c = this._removeEmptyFolders(n),
          u = this._getFinalPath(c),
          d = yield this.fetch(
            `${this.url}/object/${u}`,
            Object.assign(
              {
                method: e,
                body: s,
                headers: o,
              },
              a != null && a.duplex
                ? {
                    duplex: a.duplex,
                  }
                : {}
            )
          ),
          h = yield d.json();
        return d.ok
          ? {
              data: {
                path: c,
                id: h.Id,
                fullPath: h.Key,
              },
              error: null,
            }
          : {
              data: null,
              error: h,
            };
      } catch (s) {
        if ($t(s))
          return {
            data: null,
            error: s,
          };
        throw s;
      }
    });
  }
  upload(e, n, i) {
    return En(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("POST", e, n, i);
    });
  }
  uploadToSignedUrl(e, n, i, r) {
    return En(this, void 0, void 0, function* () {
      const s = this._removeEmptyFolders(e),
        a = this._getFinalPath(s),
        o = new URL(this.url + `/object/upload/sign/${a}`);
      o.searchParams.set("token", n);
      try {
        let l;
        const c = Object.assign(
            {
              upsert: Dy.upsert,
            },
            r
          ),
          u = Object.assign(Object.assign({}, this.headers), {
            "x-upsert": String(c.upsert),
          });
        typeof Blob < "u" && i instanceof Blob
          ? ((l = new FormData()),
            l.append("cacheControl", c.cacheControl),
            l.append("", i))
          : typeof FormData < "u" && i instanceof FormData
          ? ((l = i), l.append("cacheControl", c.cacheControl))
          : ((l = i),
            (u["cache-control"] = `max-age=${c.cacheControl}`),
            (u["content-type"] = c.contentType));
        const d = yield this.fetch(o.toString(), {
            method: "PUT",
            body: l,
            headers: u,
          }),
          h = yield d.json();
        return d.ok
          ? {
              data: {
                path: s,
                fullPath: h.Key,
              },
              error: null,
            }
          : {
              data: null,
              error: h,
            };
      } catch (l) {
        if ($t(l))
          return {
            data: null,
            error: l,
          };
        throw l;
      }
    });
  }
  createSignedUploadUrl(e, n) {
    return En(this, void 0, void 0, function* () {
      try {
        let i = this._getFinalPath(e);
        const r = Object.assign({}, this.headers);
        n != null && n.upsert && (r["x-upsert"] = "true");
        const s = yield Nr(
            this.fetch,
            `${this.url}/object/upload/sign/${i}`,
            {},
            {
              headers: r,
            }
          ),
          a = new URL(this.url + s.url),
          o = a.searchParams.get("token");
        if (!o) throw new Mv("No token returned by API");
        return {
          data: {
            signedUrl: a.toString(),
            path: e,
            token: o,
          },
          error: null,
        };
      } catch (i) {
        if ($t(i))
          return {
            data: null,
            error: i,
          };
        throw i;
      }
    });
  }
  update(e, n, i) {
    return En(this, void 0, void 0, function* () {
      return this.uploadOrUpdate("PUT", e, n, i);
    });
  }
  move(e, n, i) {
    return En(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Nr(
            this.fetch,
            `${this.url}/object/move`,
            {
              bucketId: this.bucketId,
              sourceKey: e,
              destinationKey: n,
              destinationBucket: i == null ? void 0 : i.destinationBucket,
            },
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (r) {
        if ($t(r))
          return {
            data: null,
            error: r,
          };
        throw r;
      }
    });
  }
  copy(e, n, i) {
    return En(this, void 0, void 0, function* () {
      try {
        return {
          data: {
            path: (yield Nr(
              this.fetch,
              `${this.url}/object/copy`,
              {
                bucketId: this.bucketId,
                sourceKey: e,
                destinationKey: n,
                destinationBucket: i == null ? void 0 : i.destinationBucket,
              },
              {
                headers: this.headers,
              }
            )).Key,
          },
          error: null,
        };
      } catch (r) {
        if ($t(r))
          return {
            data: null,
            error: r,
          };
        throw r;
      }
    });
  }
  createSignedUrl(e, n, i) {
    return En(this, void 0, void 0, function* () {
      try {
        let r = this._getFinalPath(e),
          s = yield Nr(
            this.fetch,
            `${this.url}/object/sign/${r}`,
            Object.assign(
              {
                expiresIn: n,
              },
              i != null && i.transform
                ? {
                    transform: i.transform,
                  }
                : {}
            ),
            {
              headers: this.headers,
            }
          );
        const a =
          i != null && i.download
            ? `&download=${i.download === !0 ? "" : i.download}`
            : "";
        return (
          (s = {
            signedUrl: encodeURI(`${this.url}${s.signedURL}${a}`),
          }),
          {
            data: s,
            error: null,
          }
        );
      } catch (r) {
        if ($t(r))
          return {
            data: null,
            error: r,
          };
        throw r;
      }
    });
  }
  createSignedUrls(e, n, i) {
    return En(this, void 0, void 0, function* () {
      try {
        const r = yield Nr(
            this.fetch,
            `${this.url}/object/sign/${this.bucketId}`,
            {
              expiresIn: n,
              paths: e,
            },
            {
              headers: this.headers,
            }
          ),
          s =
            i != null && i.download
              ? `&download=${i.download === !0 ? "" : i.download}`
              : "";
        return {
          data: r.map((a) =>
            Object.assign(Object.assign({}, a), {
              signedUrl: a.signedURL
                ? encodeURI(`${this.url}${a.signedURL}${s}`)
                : null,
            })
          ),
          error: null,
        };
      } catch (r) {
        if ($t(r))
          return {
            data: null,
            error: r,
          };
        throw r;
      }
    });
  }
  download(e, n) {
    return En(this, void 0, void 0, function* () {
      const r =
          typeof (n == null ? void 0 : n.transform) < "u"
            ? "render/image/authenticated"
            : "object",
        s = this.transformOptsToQueryString(
          (n == null ? void 0 : n.transform) || {}
        ),
        a = s ? `?${s}` : "";
      try {
        const o = this._getFinalPath(e);
        return {
          data: yield (yield Rd(this.fetch, `${this.url}/${r}/${o}${a}`, {
            headers: this.headers,
            noResolveJson: !0,
          })).blob(),
          error: null,
        };
      } catch (o) {
        if ($t(o))
          return {
            data: null,
            error: o,
          };
        throw o;
      }
    });
  }
  info(e) {
    return En(this, void 0, void 0, function* () {
      const n = this._getFinalPath(e);
      try {
        const i = yield Rd(this.fetch, `${this.url}/object/info/${n}`, {
          headers: this.headers,
        });
        return {
          data: Tm(i),
          error: null,
        };
      } catch (i) {
        if ($t(i))
          return {
            data: null,
            error: i,
          };
        throw i;
      }
    });
  }
  exists(e) {
    return En(this, void 0, void 0, function* () {
      const n = this._getFinalPath(e);
      try {
        return (
          yield Xk(this.fetch, `${this.url}/object/${n}`, {
            headers: this.headers,
          }),
          {
            data: !0,
            error: null,
          }
        );
      } catch (i) {
        if ($t(i) && i instanceof Em) {
          const r = i.originalError;
          if ([400, 404].includes(r == null ? void 0 : r.status))
            return {
              data: !1,
              error: i,
            };
        }
        throw i;
      }
    });
  }
  getPublicUrl(e, n) {
    const i = this._getFinalPath(e),
      r = [],
      s =
        n != null && n.download
          ? `download=${n.download === !0 ? "" : n.download}`
          : "";
    s !== "" && r.push(s);
    const o =
        typeof (n == null ? void 0 : n.transform) < "u"
          ? "render/image"
          : "object",
      l = this.transformOptsToQueryString(
        (n == null ? void 0 : n.transform) || {}
      );
    l !== "" && r.push(l);
    let c = r.join("&");
    return (
      c !== "" && (c = `?${c}`),
      {
        data: {
          publicUrl: encodeURI(`${this.url}/${o}/public/${i}${c}`),
        },
      }
    );
  }
  remove(e) {
    return En(this, void 0, void 0, function* () {
      try {
        return {
          data: yield jT(
            this.fetch,
            `${this.url}/object/${this.bucketId}`,
            {
              prefixes: e,
            },
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (n) {
        if ($t(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
  list(e, n, i) {
    return En(this, void 0, void 0, function* () {
      try {
        const r = Object.assign(Object.assign(Object.assign({}, qk), n), {
          prefix: e || "",
        });
        return {
          data: yield Nr(
            this.fetch,
            `${this.url}/object/list/${this.bucketId}`,
            r,
            {
              headers: this.headers,
            },
            i
          ),
          error: null,
        };
      } catch (r) {
        if ($t(r))
          return {
            data: null,
            error: r,
          };
        throw r;
      }
    });
  }
  encodeMetadata(e) {
    return JSON.stringify(e);
  }
  toBase64(e) {
    return typeof Buffer < "u" ? Buffer.from(e).toString("base64") : btoa(e);
  }
  _getFinalPath(e) {
    return `${this.bucketId}/${e}`;
  }
  _removeEmptyFolders(e) {
    return e.replace(/^\/|\/$/g, "").replace(/\/+/g, "/");
  }
  transformOptsToQueryString(e) {
    const n = [];
    return (
      e.width && n.push(`width=${e.width}`),
      e.height && n.push(`height=${e.height}`),
      e.resize && n.push(`resize=${e.resize}`),
      e.format && n.push(`format=${e.format}`),
      e.quality && n.push(`quality=${e.quality}`),
      n.join("&")
    );
  }
}
const Zk = "2.7.1",
  Kk = {
    "X-Client-Info": `storage-js/${Zk}`,
  };
var ca = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
class Jk {
  constructor(e, n = {}, i) {
    (this.url = e),
      (this.headers = Object.assign(Object.assign({}, Kk), n)),
      (this.fetch = zT(i));
  }
  listBuckets() {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Rd(this.fetch, `${this.url}/bucket`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (e) {
        if ($t(e))
          return {
            data: null,
            error: e,
          };
        throw e;
      }
    });
  }
  getBucket(e) {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Rd(this.fetch, `${this.url}/bucket/${e}`, {
            headers: this.headers,
          }),
          error: null,
        };
      } catch (n) {
        if ($t(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
  createBucket(
    e,
    n = {
      public: !1,
    }
  ) {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Nr(
            this.fetch,
            `${this.url}/bucket`,
            {
              id: e,
              name: e,
              public: n.public,
              file_size_limit: n.fileSizeLimit,
              allowed_mime_types: n.allowedMimeTypes,
            },
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (i) {
        if ($t(i))
          return {
            data: null,
            error: i,
          };
        throw i;
      }
    });
  }
  updateBucket(e, n) {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield $k(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {
              id: e,
              name: e,
              public: n.public,
              file_size_limit: n.fileSizeLimit,
              allowed_mime_types: n.allowedMimeTypes,
            },
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (i) {
        if ($t(i))
          return {
            data: null,
            error: i,
          };
        throw i;
      }
    });
  }
  emptyBucket(e) {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield Nr(
            this.fetch,
            `${this.url}/bucket/${e}/empty`,
            {},
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (n) {
        if ($t(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
  deleteBucket(e) {
    return ca(this, void 0, void 0, function* () {
      try {
        return {
          data: yield jT(
            this.fetch,
            `${this.url}/bucket/${e}`,
            {},
            {
              headers: this.headers,
            }
          ),
          error: null,
        };
      } catch (n) {
        if ($t(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
}
class Qk extends Jk {
  constructor(e, n = {}, i) {
    super(e, n, i);
  }
  from(e) {
    return new Yk(this.url, this.headers, e, this.fetch);
  }
}
const eI = "2.49.4";
let ll = "";
typeof Deno < "u"
  ? (ll = "deno")
  : typeof document < "u"
  ? (ll = "web")
  : typeof navigator < "u" && navigator.product === "ReactNative"
  ? (ll = "react-native")
  : (ll = "node");
const tI = {
    "X-Client-Info": `supabase-js-${ll}/${eI}`,
  },
  nI = {
    headers: tI,
  },
  iI = {
    schema: "public",
  },
  rI = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit",
  },
  sI = {};
var aI = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
const oI = (t) => {
    let e;
    return (
      t ? (e = t) : typeof fetch > "u" ? (e = MT) : (e = fetch),
      (...n) => e(...n)
    );
  },
  lI = () => (typeof Headers > "u" ? bT : Headers),
  cI = (t, e, n) => {
    const i = oI(n),
      r = lI();
    return (s, a) =>
      aI(void 0, void 0, void 0, function* () {
        var o;
        const l = (o = yield e()) !== null && o !== void 0 ? o : t;
        let c = new r(a == null ? void 0 : a.headers);
        return (
          c.has("apikey") || c.set("apikey", t),
          c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
          i(
            s,
            Object.assign(Object.assign({}, a), {
              headers: c,
            })
          )
        );
      });
  };
var uI = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
function dI(t) {
  return t.replace(/\/$/, "");
}
function hI(t, e) {
  const { db: n, auth: i, realtime: r, global: s } = t,
    { db: a, auth: o, realtime: l, global: c } = e,
    u = {
      db: Object.assign(Object.assign({}, a), n),
      auth: Object.assign(Object.assign({}, o), i),
      realtime: Object.assign(Object.assign({}, l), r),
      global: Object.assign(Object.assign({}, c), s),
      accessToken: () =>
        uI(this, void 0, void 0, function* () {
          return "";
        }),
    };
  return (
    t.accessToken ? (u.accessToken = t.accessToken) : delete u.accessToken, u
  );
}
const VT = "2.69.1",
  Ca = 30 * 1e3,
  Mm = 3,
  wf = Mm * Ca,
  fI = "http://localhost:9999",
  pI = "supabase.auth.token",
  mI = {
    "X-Client-Info": `gotrue-js/${VT}`,
  },
  bm = "X-Supabase-Api-Version",
  HT = {
    "2024-01-01": {
      timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
      name: "2024-01-01",
    },
  },
  gI = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i,
  vI = 6e5;
class bv extends Error {
  constructor(e, n, i) {
    super(e),
      (this.__isAuthError = !0),
      (this.name = "AuthError"),
      (this.status = n),
      (this.code = i);
  }
}
function je(t) {
  return typeof t == "object" && t !== null && "__isAuthError" in t;
}
class _I extends bv {
  constructor(e, n, i) {
    super(e, n, i),
      (this.name = "AuthApiError"),
      (this.status = n),
      (this.code = i);
  }
}
function yI(t) {
  return je(t) && t.name === "AuthApiError";
}
class GT extends bv {
  constructor(e, n) {
    super(e), (this.name = "AuthUnknownError"), (this.originalError = n);
  }
}
class hs extends bv {
  constructor(e, n, i, r) {
    super(e, i, r), (this.name = n), (this.status = i);
  }
}
class Cr extends hs {
  constructor() {
    super("Auth session missing!", "AuthSessionMissingError", 400, void 0);
  }
}
function xI(t) {
  return je(t) && t.name === "AuthSessionMissingError";
}
class Ef extends hs {
  constructor() {
    super(
      "Auth session or user missing",
      "AuthInvalidTokenResponseError",
      500,
      void 0
    );
  }
}
class nu extends hs {
  constructor(e) {
    super(e, "AuthInvalidCredentialsError", 400, void 0);
  }
}
class iu extends hs {
  constructor(e, n = null) {
    super(e, "AuthImplicitGrantRedirectError", 500, void 0),
      (this.details = null),
      (this.details = n);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
function SI(t) {
  return je(t) && t.name === "AuthImplicitGrantRedirectError";
}
class ky extends hs {
  constructor(e, n = null) {
    super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
      (this.details = null),
      (this.details = n);
  }
  toJSON() {
    return {
      name: this.name,
      message: this.message,
      status: this.status,
      details: this.details,
    };
  }
}
class Am extends hs {
  constructor(e, n) {
    super(e, "AuthRetryableFetchError", n, void 0);
  }
}
function Tf(t) {
  return je(t) && t.name === "AuthRetryableFetchError";
}
class Iy extends hs {
  constructor(e, n, i) {
    super(e, "AuthWeakPasswordError", n, "weak_password"), (this.reasons = i);
  }
}
class Al extends hs {
  constructor(e) {
    super(e, "AuthInvalidJwtError", 400, "invalid_jwt");
  }
}
const Uy =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split(
      ""
    ),
  Oy = ` 	
\r=`.split(""),
  wI = (() => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1) t[e] = -1;
    for (let e = 0; e < Oy.length; e += 1) t[Oy[e].charCodeAt(0)] = -2;
    for (let e = 0; e < Uy.length; e += 1) t[Uy[e].charCodeAt(0)] = e;
    return t;
  })();
function WT(t, e, n) {
  const i = wI[t];
  if (i > -1)
    for (e.queue = (e.queue << 6) | i, e.queuedBits += 6; e.queuedBits >= 8; )
      n((e.queue >> (e.queuedBits - 8)) & 255), (e.queuedBits -= 8);
  else {
    if (i === -2) return;
    throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`);
  }
}
function Fy(t) {
  const e = [],
    n = (a) => {
      e.push(String.fromCodePoint(a));
    },
    i = {
      utf8seq: 0,
      codepoint: 0,
    },
    r = {
      queue: 0,
      queuedBits: 0,
    },
    s = (a) => {
      MI(a, i, n);
    };
  for (let a = 0; a < t.length; a += 1) WT(t.charCodeAt(a), r, s);
  return e.join("");
}
function EI(t, e) {
  if (t <= 127) {
    e(t);
    return;
  } else if (t <= 2047) {
    e(192 | (t >> 6)), e(128 | (t & 63));
    return;
  } else if (t <= 65535) {
    e(224 | (t >> 12)), e(128 | ((t >> 6) & 63)), e(128 | (t & 63));
    return;
  } else if (t <= 1114111) {
    e(240 | (t >> 18)),
      e(128 | ((t >> 12) & 63)),
      e(128 | ((t >> 6) & 63)),
      e(128 | (t & 63));
    return;
  }
  throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`);
}
function TI(t, e) {
  for (let n = 0; n < t.length; n += 1) {
    let i = t.charCodeAt(n);
    if (i > 55295 && i <= 56319) {
      const r = ((i - 55296) * 1024) & 65535;
      (i = (((t.charCodeAt(n + 1) - 56320) & 65535) | r) + 65536), (n += 1);
    }
    EI(i, e);
  }
}
function MI(t, e, n) {
  if (e.utf8seq === 0) {
    if (t <= 127) {
      n(t);
      return;
    }
    for (let i = 1; i < 6; i += 1)
      if (!((t >> (7 - i)) & 1)) {
        e.utf8seq = i;
        break;
      }
    if (e.utf8seq === 2) e.codepoint = t & 31;
    else if (e.utf8seq === 3) e.codepoint = t & 15;
    else if (e.utf8seq === 4) e.codepoint = t & 7;
    else throw new Error("Invalid UTF-8 sequence");
    e.utf8seq -= 1;
  } else if (e.utf8seq > 0) {
    if (t <= 127) throw new Error("Invalid UTF-8 sequence");
    (e.codepoint = (e.codepoint << 6) | (t & 63)),
      (e.utf8seq -= 1),
      e.utf8seq === 0 && n(e.codepoint);
  }
}
function bI(t) {
  const e = [],
    n = {
      queue: 0,
      queuedBits: 0,
    },
    i = (r) => {
      e.push(r);
    };
  for (let r = 0; r < t.length; r += 1) WT(t.charCodeAt(r), n, i);
  return new Uint8Array(e);
}
function AI(t) {
  const e = [];
  return TI(t, (n) => e.push(n)), new Uint8Array(e);
}
function CI(t) {
  return Math.round(Date.now() / 1e3) + t;
}
function RI() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (t) {
    const e = (Math.random() * 16) | 0;
    return (t == "x" ? e : (e & 3) | 8).toString(16);
  });
}
const Ri = () => typeof window < "u" && typeof document < "u",
  vs = {
    tested: !1,
    writable: !1,
  },
  Cl = () => {
    if (!Ri()) return !1;
    try {
      if (typeof globalThis.localStorage != "object") return !1;
    } catch {
      return !1;
    }
    if (vs.tested) return vs.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
      globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        (vs.tested = !0),
        (vs.writable = !0);
    } catch {
      (vs.tested = !0), (vs.writable = !1);
    }
    return vs.writable;
  };
function PI(t) {
  const e = {},
    n = new URL(t);
  if (n.hash && n.hash[0] === "#")
    try {
      new URLSearchParams(n.hash.substring(1)).forEach((r, s) => {
        e[s] = r;
      });
    } catch {}
  return (
    n.searchParams.forEach((i, r) => {
      e[r] = i;
    }),
    e
  );
}
const $T = (t) => {
    let e;
    return (
      t
        ? (e = t)
        : typeof fetch > "u"
        ? (e = (...n) =>
            go(async () => {
              const { default: i } = await Promise.resolve().then(() => No);
              return {
                default: i,
              };
            }, void 0).then(({ default: i }) => i(...n)))
        : (e = fetch),
      (...n) => e(...n)
    );
  },
  LI = (t) =>
    typeof t == "object" &&
    t !== null &&
    "status" in t &&
    "ok" in t &&
    "json" in t &&
    typeof t.json == "function",
  XT = async (t, e, n) => {
    await t.setItem(e, JSON.stringify(n));
  },
  ru = async (t, e) => {
    const n = await t.getItem(e);
    if (!n) return null;
    try {
      return JSON.parse(n);
    } catch {
      return n;
    }
  },
  su = async (t, e) => {
    await t.removeItem(e);
  };
class xh {
  constructor() {
    this.promise = new xh.promiseConstructor((e, n) => {
      (this.resolve = e), (this.reject = n);
    });
  }
}
xh.promiseConstructor = Promise;
function Mf(t) {
  const e = t.split(".");
  if (e.length !== 3) throw new Al("Invalid JWT structure");
  for (let i = 0; i < e.length; i++)
    if (!gI.test(e[i])) throw new Al("JWT not in base64url format");
  return {
    header: JSON.parse(Fy(e[0])),
    payload: JSON.parse(Fy(e[1])),
    signature: bI(e[2]),
    raw: {
      header: e[0],
      payload: e[1],
    },
  };
}
async function NI(t) {
  return await new Promise((e) => {
    setTimeout(() => e(null), t);
  });
}
function DI(t, e) {
  return new Promise((i, r) => {
    (async () => {
      for (let s = 0; s < 1 / 0; s++)
        try {
          const a = await t(s);
          if (!e(s, null, a)) {
            i(a);
            return;
          }
        } catch (a) {
          if (!e(s, a)) {
            r(a);
            return;
          }
        }
    })();
  });
}
function kI(t) {
  return ("0" + t.toString(16)).substr(-2);
}
function II() {
  const e = new Uint32Array(56);
  if (typeof crypto > "u") {
    const n =
        "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~",
      i = n.length;
    let r = "";
    for (let s = 0; s < 56; s++) r += n.charAt(Math.floor(Math.random() * i));
    return r;
  }
  return crypto.getRandomValues(e), Array.from(e, kI).join("");
}
async function UI(t) {
  const n = new TextEncoder().encode(t),
    i = await crypto.subtle.digest("SHA-256", n),
    r = new Uint8Array(i);
  return Array.from(r)
    .map((s) => String.fromCharCode(s))
    .join("");
}
async function OI(t) {
  if (
    !(
      typeof crypto < "u" &&
      typeof crypto.subtle < "u" &&
      typeof TextEncoder < "u"
    )
  )
    return (
      console.warn(
        "WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."
      ),
      t
    );
  const n = await UI(t);
  return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
async function ua(t, e, n = !1) {
  const i = II();
  let r = i;
  n && (r += "/PASSWORD_RECOVERY"), await XT(t, `${e}-code-verifier`, r);
  const s = await OI(i);
  return [s, i === s ? "plain" : "s256"];
}
const FI = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function BI(t) {
  const e = t.headers.get(bm);
  if (!e || !e.match(FI)) return null;
  try {
    return new Date(`${e}T00:00:00.0Z`);
  } catch {
    return null;
  }
}
function zI(t) {
  if (!t) throw new Error("Missing exp claim");
  const e = Math.floor(Date.now() / 1e3);
  if (t <= e) throw new Error("JWT has expired");
}
function jI(t) {
  switch (t) {
    case "RS256":
      return {
        name: "RSASSA-PKCS1-v1_5",
        hash: {
          name: "SHA-256",
        },
      };
    case "ES256":
      return {
        name: "ECDSA",
        namedCurve: "P-256",
        hash: {
          name: "SHA-256",
        },
      };
    default:
      throw new Error("Invalid alg claim");
  }
}
var VI = function (t, e) {
  var n = {};
  for (var i in t)
    Object.prototype.hasOwnProperty.call(t, i) &&
      e.indexOf(i) < 0 &&
      (n[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, i[r]) &&
        (n[i[r]] = t[i[r]]);
  return n;
};
const Cs = (t) =>
    t.msg || t.message || t.error_description || t.error || JSON.stringify(t),
  HI = [502, 503, 504];
async function By(t) {
  var e;
  if (!LI(t)) throw new Am(Cs(t), 0);
  if (HI.includes(t.status)) throw new Am(Cs(t), t.status);
  let n;
  try {
    n = await t.json();
  } catch (s) {
    throw new GT(Cs(s), s);
  }
  let i;
  const r = BI(t);
  if (
    (r &&
    r.getTime() >= HT["2024-01-01"].timestamp &&
    typeof n == "object" &&
    n &&
    typeof n.code == "string"
      ? (i = n.code)
      : typeof n == "object" &&
        n &&
        typeof n.error_code == "string" &&
        (i = n.error_code),
    i)
  ) {
    if (i === "weak_password")
      throw new Iy(
        Cs(n),
        t.status,
        ((e = n.weak_password) === null || e === void 0 ? void 0 : e.reasons) ||
          []
      );
    if (i === "session_not_found") throw new Cr();
  } else if (
    typeof n == "object" &&
    n &&
    typeof n.weak_password == "object" &&
    n.weak_password &&
    Array.isArray(n.weak_password.reasons) &&
    n.weak_password.reasons.length &&
    n.weak_password.reasons.reduce((s, a) => s && typeof a == "string", !0)
  )
    throw new Iy(Cs(n), t.status, n.weak_password.reasons);
  throw new _I(Cs(n), t.status || 500, i);
}
const GI = (t, e, n, i) => {
  const r = {
    method: t,
    headers: (e == null ? void 0 : e.headers) || {},
  };
  return t === "GET"
    ? r
    : ((r.headers = Object.assign(
        {
          "Content-Type": "application/json;charset=UTF-8",
        },
        e == null ? void 0 : e.headers
      )),
      (r.body = JSON.stringify(i)),
      Object.assign(Object.assign({}, r), n));
};
async function tt(t, e, n, i) {
  var r;
  const s = Object.assign({}, i == null ? void 0 : i.headers);
  s[bm] || (s[bm] = HT["2024-01-01"].name),
    i != null && i.jwt && (s.Authorization = `Bearer ${i.jwt}`);
  const a =
    (r = i == null ? void 0 : i.query) !== null && r !== void 0 ? r : {};
  i != null && i.redirectTo && (a.redirect_to = i.redirectTo);
  const o = Object.keys(a).length
      ? "?" + new URLSearchParams(a).toString()
      : "",
    l = await WI(
      t,
      e,
      n + o,
      {
        headers: s,
        noResolveJson: i == null ? void 0 : i.noResolveJson,
      },
      {},
      i == null ? void 0 : i.body
    );
  return i != null && i.xform
    ? i == null
      ? void 0
      : i.xform(l)
    : {
        data: Object.assign({}, l),
        error: null,
      };
}
async function WI(t, e, n, i, r, s) {
  const a = GI(e, i, r, s);
  let o;
  try {
    o = await t(n, Object.assign({}, a));
  } catch (l) {
    throw (console.error(l), new Am(Cs(l), 0));
  }
  if ((o.ok || (await By(o)), i != null && i.noResolveJson)) return o;
  try {
    return await o.json();
  } catch (l) {
    await By(l);
  }
}
function Rr(t) {
  var e;
  let n = null;
  YI(t) &&
    ((n = Object.assign({}, t)),
    t.expires_at || (n.expires_at = CI(t.expires_in)));
  const i = (e = t.user) !== null && e !== void 0 ? e : t;
  return {
    data: {
      session: n,
      user: i,
    },
    error: null,
  };
}
function zy(t) {
  const e = Rr(t);
  return (
    !e.error &&
      t.weak_password &&
      typeof t.weak_password == "object" &&
      Array.isArray(t.weak_password.reasons) &&
      t.weak_password.reasons.length &&
      t.weak_password.message &&
      typeof t.weak_password.message == "string" &&
      t.weak_password.reasons.reduce((n, i) => n && typeof i == "string", !0) &&
      (e.data.weak_password = t.weak_password),
    e
  );
}
function Ir(t) {
  var e;
  return {
    data: {
      user: (e = t.user) !== null && e !== void 0 ? e : t,
    },
    error: null,
  };
}
function $I(t) {
  return {
    data: t,
    error: null,
  };
}
function XI(t) {
  const {
      action_link: e,
      email_otp: n,
      hashed_token: i,
      redirect_to: r,
      verification_type: s,
    } = t,
    a = VI(t, [
      "action_link",
      "email_otp",
      "hashed_token",
      "redirect_to",
      "verification_type",
    ]),
    o = {
      action_link: e,
      email_otp: n,
      hashed_token: i,
      redirect_to: r,
      verification_type: s,
    },
    l = Object.assign({}, a);
  return {
    data: {
      properties: o,
      user: l,
    },
    error: null,
  };
}
function qI(t) {
  return t;
}
function YI(t) {
  return t.access_token && t.refresh_token && t.expires_in;
}
var ZI = function (t, e) {
  var n = {};
  for (var i in t)
    Object.prototype.hasOwnProperty.call(t, i) &&
      e.indexOf(i) < 0 &&
      (n[i] = t[i]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, i = Object.getOwnPropertySymbols(t); r < i.length; r++)
      e.indexOf(i[r]) < 0 &&
        Object.prototype.propertyIsEnumerable.call(t, i[r]) &&
        (n[i[r]] = t[i[r]]);
  return n;
};
class KI {
  constructor({ url: e = "", headers: n = {}, fetch: i }) {
    (this.url = e),
      (this.headers = n),
      (this.fetch = $T(i)),
      (this.mfa = {
        listFactors: this._listFactors.bind(this),
        deleteFactor: this._deleteFactor.bind(this),
      });
  }
  async signOut(e, n = "global") {
    try {
      return (
        await tt(this.fetch, "POST", `${this.url}/logout?scope=${n}`, {
          headers: this.headers,
          jwt: e,
          noResolveJson: !0,
        }),
        {
          data: null,
          error: null,
        }
      );
    } catch (i) {
      if (je(i))
        return {
          data: null,
          error: i,
        };
      throw i;
    }
  }
  async inviteUserByEmail(e, n = {}) {
    try {
      return await tt(this.fetch, "POST", `${this.url}/invite`, {
        body: {
          email: e,
          data: n.data,
        },
        headers: this.headers,
        redirectTo: n.redirectTo,
        xform: Ir,
      });
    } catch (i) {
      if (je(i))
        return {
          data: {
            user: null,
          },
          error: i,
        };
      throw i;
    }
  }
  async generateLink(e) {
    try {
      const { options: n } = e,
        i = ZI(e, ["options"]),
        r = Object.assign(Object.assign({}, i), n);
      return (
        "newEmail" in i &&
          ((r.new_email = i == null ? void 0 : i.newEmail), delete r.newEmail),
        await tt(this.fetch, "POST", `${this.url}/admin/generate_link`, {
          body: r,
          headers: this.headers,
          xform: XI,
          redirectTo: n == null ? void 0 : n.redirectTo,
        })
      );
    } catch (n) {
      if (je(n))
        return {
          data: {
            properties: null,
            user: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async createUser(e) {
    try {
      return await tt(this.fetch, "POST", `${this.url}/admin/users`, {
        body: e,
        headers: this.headers,
        xform: Ir,
      });
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async listUsers(e) {
    var n, i, r, s, a, o, l;
    try {
      const c = {
          nextPage: null,
          lastPage: 0,
          total: 0,
        },
        u = await tt(this.fetch, "GET", `${this.url}/admin/users`, {
          headers: this.headers,
          noResolveJson: !0,
          query: {
            page:
              (i =
                (n = e == null ? void 0 : e.page) === null || n === void 0
                  ? void 0
                  : n.toString()) !== null && i !== void 0
                ? i
                : "",
            per_page:
              (s =
                (r = e == null ? void 0 : e.perPage) === null || r === void 0
                  ? void 0
                  : r.toString()) !== null && s !== void 0
                ? s
                : "",
          },
          xform: qI,
        });
      if (u.error) throw u.error;
      const d = await u.json(),
        h =
          (a = u.headers.get("x-total-count")) !== null && a !== void 0 ? a : 0,
        p =
          (l =
            (o = u.headers.get("link")) === null || o === void 0
              ? void 0
              : o.split(",")) !== null && l !== void 0
            ? l
            : [];
      return (
        p.length > 0 &&
          (p.forEach((v) => {
            const x = parseInt(v.split(";")[0].split("=")[1].substring(0, 1)),
              m = JSON.parse(v.split(";")[1].split("=")[1]);
            c[`${m}Page`] = x;
          }),
          (c.total = parseInt(h))),
        {
          data: Object.assign(Object.assign({}, d), c),
          error: null,
        }
      );
    } catch (c) {
      if (je(c))
        return {
          data: {
            users: [],
          },
          error: c,
        };
      throw c;
    }
  }
  async getUserById(e) {
    try {
      return await tt(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        xform: Ir,
      });
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async updateUserById(e, n) {
    try {
      return await tt(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
        body: n,
        headers: this.headers,
        xform: Ir,
      });
    } catch (i) {
      if (je(i))
        return {
          data: {
            user: null,
          },
          error: i,
        };
      throw i;
    }
  }
  async deleteUser(e, n = !1) {
    try {
      return await tt(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
        headers: this.headers,
        body: {
          should_soft_delete: n,
        },
        xform: Ir,
      });
    } catch (i) {
      if (je(i))
        return {
          data: {
            user: null,
          },
          error: i,
        };
      throw i;
    }
  }
  async _listFactors(e) {
    try {
      const { data: n, error: i } = await tt(
        this.fetch,
        "GET",
        `${this.url}/admin/users/${e.userId}/factors`,
        {
          headers: this.headers,
          xform: (r) => ({
            data: {
              factors: r,
            },
            error: null,
          }),
        }
      );
      return {
        data: n,
        error: i,
      };
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
  async _deleteFactor(e) {
    try {
      return {
        data: await tt(
          this.fetch,
          "DELETE",
          `${this.url}/admin/users/${e.userId}/factors/${e.id}`,
          {
            headers: this.headers,
          }
        ),
        error: null,
      };
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
}
const JI = {
  getItem: (t) => (Cl() ? globalThis.localStorage.getItem(t) : null),
  setItem: (t, e) => {
    Cl() && globalThis.localStorage.setItem(t, e);
  },
  removeItem: (t) => {
    Cl() && globalThis.localStorage.removeItem(t);
  },
};
function jy(t = {}) {
  return {
    getItem: (e) => t[e] || null,
    setItem: (e, n) => {
      t[e] = n;
    },
    removeItem: (e) => {
      delete t[e];
    },
  };
}
function QI() {
  if (typeof globalThis != "object")
    try {
      Object.defineProperty(Object.prototype, "__magic__", {
        get: function () {
          return this;
        },
        configurable: !0,
      }),
        (__magic__.globalThis = __magic__),
        delete Object.prototype.__magic__;
    } catch {
      typeof self < "u" && (self.globalThis = self);
    }
}
const da = {
  debug: !!(
    globalThis &&
    Cl() &&
    globalThis.localStorage &&
    globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true"
  ),
};
class qT extends Error {
  constructor(e) {
    super(e), (this.isAcquireTimeout = !0);
  }
}
class e3 extends qT {}
async function t3(t, e, n) {
  da.debug &&
    console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
  const i = new globalThis.AbortController();
  return (
    e > 0 &&
      setTimeout(() => {
        i.abort(),
          da.debug &&
            console.log(
              "@supabase/gotrue-js: navigatorLock acquire timed out",
              t
            );
      }, e),
    await Promise.resolve().then(() =>
      globalThis.navigator.locks.request(
        t,
        e === 0
          ? {
              mode: "exclusive",
              ifAvailable: !0,
            }
          : {
              mode: "exclusive",
              signal: i.signal,
            },
        async (r) => {
          if (r) {
            da.debug &&
              console.log(
                "@supabase/gotrue-js: navigatorLock: acquired",
                t,
                r.name
              );
            try {
              return await n();
            } finally {
              da.debug &&
                console.log(
                  "@supabase/gotrue-js: navigatorLock: released",
                  t,
                  r.name
                );
            }
          } else {
            if (e === 0)
              throw (
                (da.debug &&
                  console.log(
                    "@supabase/gotrue-js: navigatorLock: not immediately available",
                    t
                  ),
                new e3(
                  `Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`
                ))
              );
            if (da.debug)
              try {
                const s = await globalThis.navigator.locks.query();
                console.log(
                  "@supabase/gotrue-js: Navigator LockManager state",
                  JSON.stringify(s, null, "  ")
                );
              } catch (s) {
                console.warn(
                  "@supabase/gotrue-js: Error when querying Navigator LockManager state",
                  s
                );
              }
            return (
              console.warn(
                "@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"
              ),
              await n()
            );
          }
        }
      )
    )
  );
}
QI();
const n3 = {
  url: fI,
  storageKey: pI,
  autoRefreshToken: !0,
  persistSession: !0,
  detectSessionInUrl: !0,
  headers: mI,
  flowType: "implicit",
  debug: !1,
  hasCustomAuthorizationHeader: !1,
};
async function Vy(t, e, n) {
  return await n();
}
class Jl {
  constructor(e) {
    var n, i;
    (this.memoryStorage = null),
      (this.stateChangeEmitters = new Map()),
      (this.autoRefreshTicker = null),
      (this.visibilityChangedCallback = null),
      (this.refreshingDeferred = null),
      (this.initializePromise = null),
      (this.detectSessionInUrl = !0),
      (this.hasCustomAuthorizationHeader = !1),
      (this.suppressGetSessionWarning = !1),
      (this.lockAcquired = !1),
      (this.pendingInLock = []),
      (this.broadcastChannel = null),
      (this.logger = console.log),
      (this.instanceID = Jl.nextInstanceID),
      (Jl.nextInstanceID += 1),
      this.instanceID > 0 &&
        Ri() &&
        console.warn(
          "Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key."
        );
    const r = Object.assign(Object.assign({}, n3), e);
    if (
      ((this.logDebugMessages = !!r.debug),
      typeof r.debug == "function" && (this.logger = r.debug),
      (this.persistSession = r.persistSession),
      (this.storageKey = r.storageKey),
      (this.autoRefreshToken = r.autoRefreshToken),
      (this.admin = new KI({
        url: r.url,
        headers: r.headers,
        fetch: r.fetch,
      })),
      (this.url = r.url),
      (this.headers = r.headers),
      (this.fetch = $T(r.fetch)),
      (this.lock = r.lock || Vy),
      (this.detectSessionInUrl = r.detectSessionInUrl),
      (this.flowType = r.flowType),
      (this.hasCustomAuthorizationHeader = r.hasCustomAuthorizationHeader),
      r.lock
        ? (this.lock = r.lock)
        : Ri() &&
          !(
            (n = globalThis == null ? void 0 : globalThis.navigator) === null ||
            n === void 0
          ) &&
          n.locks
        ? (this.lock = t3)
        : (this.lock = Vy),
      (this.jwks = {
        keys: [],
      }),
      (this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
      (this.mfa = {
        verify: this._verify.bind(this),
        enroll: this._enroll.bind(this),
        unenroll: this._unenroll.bind(this),
        challenge: this._challenge.bind(this),
        listFactors: this._listFactors.bind(this),
        challengeAndVerify: this._challengeAndVerify.bind(this),
        getAuthenticatorAssuranceLevel:
          this._getAuthenticatorAssuranceLevel.bind(this),
      }),
      this.persistSession
        ? r.storage
          ? (this.storage = r.storage)
          : Cl()
          ? (this.storage = JI)
          : ((this.memoryStorage = {}), (this.storage = jy(this.memoryStorage)))
        : ((this.memoryStorage = {}), (this.storage = jy(this.memoryStorage))),
      Ri() &&
        globalThis.BroadcastChannel &&
        this.persistSession &&
        this.storageKey)
    ) {
      try {
        this.broadcastChannel = new globalThis.BroadcastChannel(
          this.storageKey
        );
      } catch (s) {
        console.error(
          "Failed to create a new BroadcastChannel, multi-tab state changes will not be available",
          s
        );
      }
      (i = this.broadcastChannel) === null ||
        i === void 0 ||
        i.addEventListener("message", async (s) => {
          this._debug(
            "received broadcast notification from other tab or client",
            s
          ),
            await this._notifyAllSubscribers(s.data.event, s.data.session, !1);
        });
    }
    this.initialize();
  }
  _debug(...e) {
    return (
      this.logDebugMessages &&
        this.logger(
          `GoTrueClient@${this.instanceID} (${VT}) ${new Date().toISOString()}`,
          ...e
        ),
      this
    );
  }
  async initialize() {
    return this.initializePromise
      ? await this.initializePromise
      : ((this.initializePromise = (async () =>
          await this._acquireLock(-1, async () => await this._initialize()))()),
        await this.initializePromise);
  }
  async _initialize() {
    var e;
    try {
      const n = PI(window.location.href);
      let i = "none";
      if (
        (this._isImplicitGrantCallback(n)
          ? (i = "implicit")
          : (await this._isPKCECallback(n)) && (i = "pkce"),
        Ri() && this.detectSessionInUrl && i !== "none")
      ) {
        const { data: r, error: s } = await this._getSessionFromURL(n, i);
        if (s) {
          if (
            (this._debug(
              "#_initialize()",
              "error detecting session from URL",
              s
            ),
            SI(s))
          ) {
            const l =
              (e = s.details) === null || e === void 0 ? void 0 : e.code;
            if (
              l === "identity_already_exists" ||
              l === "identity_not_found" ||
              l === "single_identity_not_deletable"
            )
              return {
                error: s,
              };
          }
          return (
            await this._removeSession(),
            {
              error: s,
            }
          );
        }
        const { session: a, redirectType: o } = r;
        return (
          this._debug(
            "#_initialize()",
            "detected session in URL",
            a,
            "redirect type",
            o
          ),
          await this._saveSession(a),
          setTimeout(async () => {
            o === "recovery"
              ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", a)
              : await this._notifyAllSubscribers("SIGNED_IN", a);
          }, 0),
          {
            error: null,
          }
        );
      }
      return (
        await this._recoverAndRefresh(),
        {
          error: null,
        }
      );
    } catch (n) {
      return je(n)
        ? {
            error: n,
          }
        : {
            error: new GT("Unexpected error during initialization", n),
          };
    } finally {
      await this._handleVisibilityChange(),
        this._debug("#_initialize()", "end");
    }
  }
  async signInAnonymously(e) {
    var n, i, r;
    try {
      const s = await tt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            data:
              (i =
                (n = e == null ? void 0 : e.options) === null || n === void 0
                  ? void 0
                  : n.data) !== null && i !== void 0
                ? i
                : {},
            gotrue_meta_security: {
              captcha_token:
                (r = e == null ? void 0 : e.options) === null || r === void 0
                  ? void 0
                  : r.captchaToken,
            },
          },
          xform: Rr,
        }),
        { data: a, error: o } = s;
      if (o || !a)
        return {
          data: {
            user: null,
            session: null,
          },
          error: o,
        };
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        {
          data: {
            user: c,
            session: l,
          },
          error: null,
        }
      );
    } catch (s) {
      if (je(s))
        return {
          data: {
            user: null,
            session: null,
          },
          error: s,
        };
      throw s;
    }
  }
  async signUp(e) {
    var n, i, r;
    try {
      let s;
      if ("email" in e) {
        const { email: u, password: d, options: h } = e;
        let p = null,
          v = null;
        this.flowType === "pkce" &&
          ([p, v] = await ua(this.storage, this.storageKey)),
          (s = await tt(this.fetch, "POST", `${this.url}/signup`, {
            headers: this.headers,
            redirectTo: h == null ? void 0 : h.emailRedirectTo,
            body: {
              email: u,
              password: d,
              data:
                (n = h == null ? void 0 : h.data) !== null && n !== void 0
                  ? n
                  : {},
              gotrue_meta_security: {
                captcha_token: h == null ? void 0 : h.captchaToken,
              },
              code_challenge: p,
              code_challenge_method: v,
            },
            xform: Rr,
          }));
      } else if ("phone" in e) {
        const { phone: u, password: d, options: h } = e;
        s = await tt(this.fetch, "POST", `${this.url}/signup`, {
          headers: this.headers,
          body: {
            phone: u,
            password: d,
            data:
              (i = h == null ? void 0 : h.data) !== null && i !== void 0
                ? i
                : {},
            channel:
              (r = h == null ? void 0 : h.channel) !== null && r !== void 0
                ? r
                : "sms",
            gotrue_meta_security: {
              captcha_token: h == null ? void 0 : h.captchaToken,
            },
          },
          xform: Rr,
        });
      } else
        throw new nu(
          "You must provide either an email or phone number and a password"
        );
      const { data: a, error: o } = s;
      if (o || !a)
        return {
          data: {
            user: null,
            session: null,
          },
          error: o,
        };
      const l = a.session,
        c = a.user;
      return (
        a.session &&
          (await this._saveSession(a.session),
          await this._notifyAllSubscribers("SIGNED_IN", l)),
        {
          data: {
            user: c,
            session: l,
          },
          error: null,
        }
      );
    } catch (s) {
      if (je(s))
        return {
          data: {
            user: null,
            session: null,
          },
          error: s,
        };
      throw s;
    }
  }
  async signInWithPassword(e) {
    try {
      let n;
      if ("email" in e) {
        const { email: s, password: a, options: o } = e;
        n = await tt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              email: s,
              password: a,
              gotrue_meta_security: {
                captcha_token: o == null ? void 0 : o.captchaToken,
              },
            },
            xform: zy,
          }
        );
      } else if ("phone" in e) {
        const { phone: s, password: a, options: o } = e;
        n = await tt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=password`,
          {
            headers: this.headers,
            body: {
              phone: s,
              password: a,
              gotrue_meta_security: {
                captcha_token: o == null ? void 0 : o.captchaToken,
              },
            },
            xform: zy,
          }
        );
      } else
        throw new nu(
          "You must provide either an email or phone number and a password"
        );
      const { data: i, error: r } = n;
      return r
        ? {
            data: {
              user: null,
              session: null,
            },
            error: r,
          }
        : !i || !i.session || !i.user
        ? {
            data: {
              user: null,
              session: null,
            },
            error: new Ef(),
          }
        : (i.session &&
            (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
          {
            data: Object.assign(
              {
                user: i.user,
                session: i.session,
              },
              i.weak_password
                ? {
                    weakPassword: i.weak_password,
                  }
                : null
            ),
            error: r,
          });
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
            session: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async signInWithOAuth(e) {
    var n, i, r, s;
    return await this._handleProviderSignIn(e.provider, {
      redirectTo:
        (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo,
      scopes: (i = e.options) === null || i === void 0 ? void 0 : i.scopes,
      queryParams:
        (r = e.options) === null || r === void 0 ? void 0 : r.queryParams,
      skipBrowserRedirect:
        (s = e.options) === null || s === void 0
          ? void 0
          : s.skipBrowserRedirect,
    });
  }
  async exchangeCodeForSession(e) {
    return (
      await this.initializePromise,
      this._acquireLock(-1, async () => this._exchangeCodeForSession(e))
    );
  }
  async _exchangeCodeForSession(e) {
    const n = await ru(this.storage, `${this.storageKey}-code-verifier`),
      [i, r] = (n ?? "").split("/");
    try {
      const { data: s, error: a } = await tt(
        this.fetch,
        "POST",
        `${this.url}/token?grant_type=pkce`,
        {
          headers: this.headers,
          body: {
            auth_code: e,
            code_verifier: i,
          },
          xform: Rr,
        }
      );
      if ((await su(this.storage, `${this.storageKey}-code-verifier`), a))
        throw a;
      return !s || !s.session || !s.user
        ? {
            data: {
              user: null,
              session: null,
              redirectType: null,
            },
            error: new Ef(),
          }
        : (s.session &&
            (await this._saveSession(s.session),
            await this._notifyAllSubscribers("SIGNED_IN", s.session)),
          {
            data: Object.assign(Object.assign({}, s), {
              redirectType: r ?? null,
            }),
            error: a,
          });
    } catch (s) {
      if (je(s))
        return {
          data: {
            user: null,
            session: null,
            redirectType: null,
          },
          error: s,
        };
      throw s;
    }
  }
  async signInWithIdToken(e) {
    try {
      const {
          options: n,
          provider: i,
          token: r,
          access_token: s,
          nonce: a,
        } = e,
        o = await tt(
          this.fetch,
          "POST",
          `${this.url}/token?grant_type=id_token`,
          {
            headers: this.headers,
            body: {
              provider: i,
              id_token: r,
              access_token: s,
              nonce: a,
              gotrue_meta_security: {
                captcha_token: n == null ? void 0 : n.captchaToken,
              },
            },
            xform: Rr,
          }
        ),
        { data: l, error: c } = o;
      return c
        ? {
            data: {
              user: null,
              session: null,
            },
            error: c,
          }
        : !l || !l.session || !l.user
        ? {
            data: {
              user: null,
              session: null,
            },
            error: new Ef(),
          }
        : (l.session &&
            (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
          {
            data: l,
            error: c,
          });
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
            session: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async signInWithOtp(e) {
    var n, i, r, s, a;
    try {
      if ("email" in e) {
        const { email: o, options: l } = e;
        let c = null,
          u = null;
        this.flowType === "pkce" &&
          ([c, u] = await ua(this.storage, this.storageKey));
        const { error: d } = await tt(this.fetch, "POST", `${this.url}/otp`, {
          headers: this.headers,
          body: {
            email: o,
            data:
              (n = l == null ? void 0 : l.data) !== null && n !== void 0
                ? n
                : {},
            create_user:
              (i = l == null ? void 0 : l.shouldCreateUser) !== null &&
              i !== void 0
                ? i
                : !0,
            gotrue_meta_security: {
              captcha_token: l == null ? void 0 : l.captchaToken,
            },
            code_challenge: c,
            code_challenge_method: u,
          },
          redirectTo: l == null ? void 0 : l.emailRedirectTo,
        });
        return {
          data: {
            user: null,
            session: null,
          },
          error: d,
        };
      }
      if ("phone" in e) {
        const { phone: o, options: l } = e,
          { data: c, error: u } = await tt(
            this.fetch,
            "POST",
            `${this.url}/otp`,
            {
              headers: this.headers,
              body: {
                phone: o,
                data:
                  (r = l == null ? void 0 : l.data) !== null && r !== void 0
                    ? r
                    : {},
                create_user:
                  (s = l == null ? void 0 : l.shouldCreateUser) !== null &&
                  s !== void 0
                    ? s
                    : !0,
                gotrue_meta_security: {
                  captcha_token: l == null ? void 0 : l.captchaToken,
                },
                channel:
                  (a = l == null ? void 0 : l.channel) !== null && a !== void 0
                    ? a
                    : "sms",
              },
            }
          );
        return {
          data: {
            user: null,
            session: null,
            messageId: c == null ? void 0 : c.message_id,
          },
          error: u,
        };
      }
      throw new nu("You must provide either an email or phone number.");
    } catch (o) {
      if (je(o))
        return {
          data: {
            user: null,
            session: null,
          },
          error: o,
        };
      throw o;
    }
  }
  async verifyOtp(e) {
    var n, i;
    try {
      let r, s;
      "options" in e &&
        ((r = (n = e.options) === null || n === void 0 ? void 0 : n.redirectTo),
        (s =
          (i = e.options) === null || i === void 0 ? void 0 : i.captchaToken));
      const { data: a, error: o } = await tt(
        this.fetch,
        "POST",
        `${this.url}/verify`,
        {
          headers: this.headers,
          body: Object.assign(Object.assign({}, e), {
            gotrue_meta_security: {
              captcha_token: s,
            },
          }),
          redirectTo: r,
          xform: Rr,
        }
      );
      if (o) throw o;
      if (!a) throw new Error("An error occurred on token verification.");
      const l = a.session,
        c = a.user;
      return (
        l != null &&
          l.access_token &&
          (await this._saveSession(l),
          await this._notifyAllSubscribers(
            e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN",
            l
          )),
        {
          data: {
            user: c,
            session: l,
          },
          error: null,
        }
      );
    } catch (r) {
      if (je(r))
        return {
          data: {
            user: null,
            session: null,
          },
          error: r,
        };
      throw r;
    }
  }
  async signInWithSSO(e) {
    var n, i, r;
    try {
      let s = null,
        a = null;
      return (
        this.flowType === "pkce" &&
          ([s, a] = await ua(this.storage, this.storageKey)),
        await tt(this.fetch, "POST", `${this.url}/sso`, {
          body: Object.assign(
            Object.assign(
              Object.assign(
                Object.assign(
                  Object.assign(
                    {},
                    "providerId" in e
                      ? {
                          provider_id: e.providerId,
                        }
                      : null
                  ),
                  "domain" in e
                    ? {
                        domain: e.domain,
                      }
                    : null
                ),
                {
                  redirect_to:
                    (i =
                      (n = e.options) === null || n === void 0
                        ? void 0
                        : n.redirectTo) !== null && i !== void 0
                      ? i
                      : void 0,
                }
              ),
              !(
                (r = e == null ? void 0 : e.options) === null || r === void 0
              ) && r.captchaToken
                ? {
                    gotrue_meta_security: {
                      captcha_token: e.options.captchaToken,
                    },
                  }
                : null
            ),
            {
              skip_http_redirect: !0,
              code_challenge: s,
              code_challenge_method: a,
            }
          ),
          headers: this.headers,
          xform: $I,
        })
      );
    } catch (s) {
      if (je(s))
        return {
          data: null,
          error: s,
        };
      throw s;
    }
  }
  async reauthenticate() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._reauthenticate())
    );
  }
  async _reauthenticate() {
    try {
      return await this._useSession(async (e) => {
        const {
          data: { session: n },
          error: i,
        } = e;
        if (i) throw i;
        if (!n) throw new Cr();
        const { error: r } = await tt(
          this.fetch,
          "GET",
          `${this.url}/reauthenticate`,
          {
            headers: this.headers,
            jwt: n.access_token,
          }
        );
        return {
          data: {
            user: null,
            session: null,
          },
          error: r,
        };
      });
    } catch (e) {
      if (je(e))
        return {
          data: {
            user: null,
            session: null,
          },
          error: e,
        };
      throw e;
    }
  }
  async resend(e) {
    try {
      const n = `${this.url}/resend`;
      if ("email" in e) {
        const { email: i, type: r, options: s } = e,
          { error: a } = await tt(this.fetch, "POST", n, {
            headers: this.headers,
            body: {
              email: i,
              type: r,
              gotrue_meta_security: {
                captcha_token: s == null ? void 0 : s.captchaToken,
              },
            },
            redirectTo: s == null ? void 0 : s.emailRedirectTo,
          });
        return {
          data: {
            user: null,
            session: null,
          },
          error: a,
        };
      } else if ("phone" in e) {
        const { phone: i, type: r, options: s } = e,
          { data: a, error: o } = await tt(this.fetch, "POST", n, {
            headers: this.headers,
            body: {
              phone: i,
              type: r,
              gotrue_meta_security: {
                captcha_token: s == null ? void 0 : s.captchaToken,
              },
            },
          });
        return {
          data: {
            user: null,
            session: null,
            messageId: a == null ? void 0 : a.message_id,
          },
          error: o,
        };
      }
      throw new nu(
        "You must provide either an email or phone number and a type"
      );
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
            session: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async getSession() {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => this._useSession(async (n) => n))
    );
  }
  async _acquireLock(e, n) {
    this._debug("#_acquireLock", "begin", e);
    try {
      if (this.lockAcquired) {
        const i = this.pendingInLock.length
            ? this.pendingInLock[this.pendingInLock.length - 1]
            : Promise.resolve(),
          r = (async () => (await i, await n()))();
        return (
          this.pendingInLock.push(
            (async () => {
              try {
                await r;
              } catch {}
            })()
          ),
          r
        );
      }
      return await this.lock(`lock:${this.storageKey}`, e, async () => {
        this._debug(
          "#_acquireLock",
          "lock acquired for storage key",
          this.storageKey
        );
        try {
          this.lockAcquired = !0;
          const i = n();
          for (
            this.pendingInLock.push(
              (async () => {
                try {
                  await i;
                } catch {}
              })()
            ),
              await i;
            this.pendingInLock.length;

          ) {
            const r = [...this.pendingInLock];
            await Promise.all(r), this.pendingInLock.splice(0, r.length);
          }
          return await i;
        } finally {
          this._debug(
            "#_acquireLock",
            "lock released for storage key",
            this.storageKey
          ),
            (this.lockAcquired = !1);
        }
      });
    } finally {
      this._debug("#_acquireLock", "end");
    }
  }
  async _useSession(e) {
    this._debug("#_useSession", "begin");
    try {
      const n = await this.__loadSession();
      return await e(n);
    } finally {
      this._debug("#_useSession", "end");
    }
  }
  async __loadSession() {
    this._debug("#__loadSession()", "begin"),
      this.lockAcquired ||
        this._debug(
          "#__loadSession()",
          "used outside of an acquired lock!",
          new Error().stack
        );
    try {
      let e = null;
      const n = await ru(this.storage, this.storageKey);
      if (
        (this._debug("#getSession()", "session from storage", n),
        n !== null &&
          (this._isValidSession(n)
            ? (e = n)
            : (this._debug(
                "#getSession()",
                "session from storage is not valid"
              ),
              await this._removeSession())),
        !e)
      )
        return {
          data: {
            session: null,
          },
          error: null,
        };
      const i = e.expires_at ? e.expires_at * 1e3 - Date.now() < wf : !1;
      if (
        (this._debug(
          "#__loadSession()",
          `session has${i ? "" : " not"} expired`,
          "expires_at",
          e.expires_at
        ),
        !i)
      ) {
        if (this.storage.isServer) {
          let a = this.suppressGetSessionWarning;
          e = new Proxy(e, {
            get: (l, c, u) => (
              !a &&
                c === "user" &&
                (console.warn(
                  "Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."
                ),
                (a = !0),
                (this.suppressGetSessionWarning = !0)),
              Reflect.get(l, c, u)
            ),
          });
        }
        return {
          data: {
            session: e,
          },
          error: null,
        };
      }
      const { session: r, error: s } = await this._callRefreshToken(
        e.refresh_token
      );
      return s
        ? {
            data: {
              session: null,
            },
            error: s,
          }
        : {
            data: {
              session: r,
            },
            error: null,
          };
    } finally {
      this._debug("#__loadSession()", "end");
    }
  }
  async getUser(e) {
    return e
      ? await this._getUser(e)
      : (await this.initializePromise,
        await this._acquireLock(-1, async () => await this._getUser()));
  }
  async _getUser(e) {
    try {
      return e
        ? await tt(this.fetch, "GET", `${this.url}/user`, {
            headers: this.headers,
            jwt: e,
            xform: Ir,
          })
        : await this._useSession(async (n) => {
            var i, r, s;
            const { data: a, error: o } = n;
            if (o) throw o;
            return !(
              !((i = a.session) === null || i === void 0) && i.access_token
            ) && !this.hasCustomAuthorizationHeader
              ? {
                  data: {
                    user: null,
                  },
                  error: new Cr(),
                }
              : await tt(this.fetch, "GET", `${this.url}/user`, {
                  headers: this.headers,
                  jwt:
                    (s =
                      (r = a.session) === null || r === void 0
                        ? void 0
                        : r.access_token) !== null && s !== void 0
                      ? s
                      : void 0,
                  xform: Ir,
                });
          });
    } catch (n) {
      if (je(n))
        return (
          xI(n) &&
            (await this._removeSession(),
            await su(this.storage, `${this.storageKey}-code-verifier`)),
          {
            data: {
              user: null,
            },
            error: n,
          }
        );
      throw n;
    }
  }
  async updateUser(e, n = {}) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._updateUser(e, n))
    );
  }
  async _updateUser(e, n = {}) {
    try {
      return await this._useSession(async (i) => {
        const { data: r, error: s } = i;
        if (s) throw s;
        if (!r.session) throw new Cr();
        const a = r.session;
        let o = null,
          l = null;
        this.flowType === "pkce" &&
          e.email != null &&
          ([o, l] = await ua(this.storage, this.storageKey));
        const { data: c, error: u } = await tt(
          this.fetch,
          "PUT",
          `${this.url}/user`,
          {
            headers: this.headers,
            redirectTo: n == null ? void 0 : n.emailRedirectTo,
            body: Object.assign(Object.assign({}, e), {
              code_challenge: o,
              code_challenge_method: l,
            }),
            jwt: a.access_token,
            xform: Ir,
          }
        );
        if (u) throw u;
        return (
          (a.user = c.user),
          await this._saveSession(a),
          await this._notifyAllSubscribers("USER_UPDATED", a),
          {
            data: {
              user: a.user,
            },
            error: null,
          }
        );
      });
    } catch (i) {
      if (je(i))
        return {
          data: {
            user: null,
          },
          error: i,
        };
      throw i;
    }
  }
  async setSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._setSession(e))
    );
  }
  async _setSession(e) {
    try {
      if (!e.access_token || !e.refresh_token) throw new Cr();
      const n = Date.now() / 1e3;
      let i = n,
        r = !0,
        s = null;
      const { payload: a } = Mf(e.access_token);
      if ((a.exp && ((i = a.exp), (r = i <= n)), r)) {
        const { session: o, error: l } = await this._callRefreshToken(
          e.refresh_token
        );
        if (l)
          return {
            data: {
              user: null,
              session: null,
            },
            error: l,
          };
        if (!o)
          return {
            data: {
              user: null,
              session: null,
            },
            error: null,
          };
        s = o;
      } else {
        const { data: o, error: l } = await this._getUser(e.access_token);
        if (l) throw l;
        (s = {
          access_token: e.access_token,
          refresh_token: e.refresh_token,
          user: o.user,
          token_type: "bearer",
          expires_in: i - n,
          expires_at: i,
        }),
          await this._saveSession(s),
          await this._notifyAllSubscribers("SIGNED_IN", s);
      }
      return {
        data: {
          user: s.user,
          session: s,
        },
        error: null,
      };
    } catch (n) {
      if (je(n))
        return {
          data: {
            session: null,
            user: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async refreshSession(e) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._refreshSession(e))
    );
  }
  async _refreshSession(e) {
    try {
      return await this._useSession(async (n) => {
        var i;
        if (!e) {
          const { data: a, error: o } = n;
          if (o) throw o;
          e = (i = a.session) !== null && i !== void 0 ? i : void 0;
        }
        if (!(e != null && e.refresh_token)) throw new Cr();
        const { session: r, error: s } = await this._callRefreshToken(
          e.refresh_token
        );
        return s
          ? {
              data: {
                user: null,
                session: null,
              },
              error: s,
            }
          : r
          ? {
              data: {
                user: r.user,
                session: r,
              },
              error: null,
            }
          : {
              data: {
                user: null,
                session: null,
              },
              error: null,
            };
      });
    } catch (n) {
      if (je(n))
        return {
          data: {
            user: null,
            session: null,
          },
          error: n,
        };
      throw n;
    }
  }
  async _getSessionFromURL(e, n) {
    try {
      if (!Ri()) throw new iu("No browser detected.");
      if (e.error || e.error_description || e.error_code)
        throw new iu(
          e.error_description ||
            "Error in URL with unspecified error_description",
          {
            error: e.error || "unspecified_error",
            code: e.error_code || "unspecified_code",
          }
        );
      switch (n) {
        case "implicit":
          if (this.flowType === "pkce")
            throw new ky("Not a valid PKCE flow url.");
          break;
        case "pkce":
          if (this.flowType === "implicit")
            throw new iu("Not a valid implicit grant flow url.");
          break;
        default:
      }
      if (n === "pkce") {
        if (
          (this._debug("#_initialize()", "begin", "is PKCE flow", !0), !e.code)
        )
          throw new ky("No code detected.");
        const { data: y, error: g } = await this._exchangeCodeForSession(
          e.code
        );
        if (g) throw g;
        const S = new URL(window.location.href);
        return (
          S.searchParams.delete("code"),
          window.history.replaceState(window.history.state, "", S.toString()),
          {
            data: {
              session: y.session,
              redirectType: null,
            },
            error: null,
          }
        );
      }
      const {
        provider_token: i,
        provider_refresh_token: r,
        access_token: s,
        refresh_token: a,
        expires_in: o,
        expires_at: l,
        token_type: c,
      } = e;
      if (!s || !o || !a || !c) throw new iu("No session defined in URL");
      const u = Math.round(Date.now() / 1e3),
        d = parseInt(o);
      let h = u + d;
      l && (h = parseInt(l));
      const p = h - u;
      p * 1e3 <= Ca &&
        console.warn(
          `@supabase/gotrue-js: Session as retrieved from URL expires in ${p}s, should have been closer to ${d}s`
        );
      const v = h - d;
      u - v >= 120
        ? console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale",
            v,
            h,
            u
          )
        : u - v < 0 &&
          console.warn(
            "@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew",
            v,
            h,
            u
          );
      const { data: x, error: m } = await this._getUser(s);
      if (m) throw m;
      const f = {
        provider_token: i,
        provider_refresh_token: r,
        access_token: s,
        expires_in: d,
        expires_at: h,
        refresh_token: a,
        token_type: c,
        user: x.user,
      };
      return (
        (window.location.hash = ""),
        this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
        {
          data: {
            session: f,
            redirectType: e.type,
          },
          error: null,
        }
      );
    } catch (i) {
      if (je(i))
        return {
          data: {
            session: null,
            redirectType: null,
          },
          error: i,
        };
      throw i;
    }
  }
  _isImplicitGrantCallback(e) {
    return !!(e.access_token || e.error_description);
  }
  async _isPKCECallback(e) {
    const n = await ru(this.storage, `${this.storageKey}-code-verifier`);
    return !!(e.code && n);
  }
  async signOut(
    e = {
      scope: "global",
    }
  ) {
    return (
      await this.initializePromise,
      await this._acquireLock(-1, async () => await this._signOut(e))
    );
  }
  async _signOut(
    { scope: e } = {
      scope: "global",
    }
  ) {
    return await this._useSession(async (n) => {
      var i;
      const { data: r, error: s } = n;
      if (s)
        return {
          error: s,
        };
      const a =
        (i = r.session) === null || i === void 0 ? void 0 : i.access_token;
      if (a) {
        const { error: o } = await this.admin.signOut(a, e);
        if (
          o &&
          !(yI(o) && (o.status === 404 || o.status === 401 || o.status === 403))
        )
          return {
            error: o,
          };
      }
      return (
        e !== "others" &&
          (await this._removeSession(),
          await su(this.storage, `${this.storageKey}-code-verifier`)),
        {
          error: null,
        }
      );
    });
  }
  onAuthStateChange(e) {
    const n = RI(),
      i = {
        id: n,
        callback: e,
        unsubscribe: () => {
          this._debug(
            "#unsubscribe()",
            "state change callback with id removed",
            n
          ),
            this.stateChangeEmitters.delete(n);
        },
      };
    return (
      this._debug("#onAuthStateChange()", "registered callback with id", n),
      this.stateChangeEmitters.set(n, i),
      (async () => (
        await this.initializePromise,
        await this._acquireLock(-1, async () => {
          this._emitInitialSession(n);
        })
      ))(),
      {
        data: {
          subscription: i,
        },
      }
    );
  }
  async _emitInitialSession(e) {
    return await this._useSession(async (n) => {
      var i, r;
      try {
        const {
          data: { session: s },
          error: a,
        } = n;
        if (a) throw a;
        await ((i = this.stateChangeEmitters.get(e)) === null || i === void 0
          ? void 0
          : i.callback("INITIAL_SESSION", s)),
          this._debug("INITIAL_SESSION", "callback id", e, "session", s);
      } catch (s) {
        await ((r = this.stateChangeEmitters.get(e)) === null || r === void 0
          ? void 0
          : r.callback("INITIAL_SESSION", null)),
          this._debug("INITIAL_SESSION", "callback id", e, "error", s),
          console.error(s);
      }
    });
  }
  async resetPasswordForEmail(e, n = {}) {
    let i = null,
      r = null;
    this.flowType === "pkce" &&
      ([i, r] = await ua(this.storage, this.storageKey, !0));
    try {
      return await tt(this.fetch, "POST", `${this.url}/recover`, {
        body: {
          email: e,
          code_challenge: i,
          code_challenge_method: r,
          gotrue_meta_security: {
            captcha_token: n.captchaToken,
          },
        },
        headers: this.headers,
        redirectTo: n.redirectTo,
      });
    } catch (s) {
      if (je(s))
        return {
          data: null,
          error: s,
        };
      throw s;
    }
  }
  async getUserIdentities() {
    var e;
    try {
      const { data: n, error: i } = await this.getUser();
      if (i) throw i;
      return {
        data: {
          identities: (e = n.user.identities) !== null && e !== void 0 ? e : [],
        },
        error: null,
      };
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
  async linkIdentity(e) {
    var n;
    try {
      const { data: i, error: r } = await this._useSession(async (s) => {
        var a, o, l, c, u;
        const { data: d, error: h } = s;
        if (h) throw h;
        const p = await this._getUrlForProvider(
          `${this.url}/user/identities/authorize`,
          e.provider,
          {
            redirectTo:
              (a = e.options) === null || a === void 0 ? void 0 : a.redirectTo,
            scopes:
              (o = e.options) === null || o === void 0 ? void 0 : o.scopes,
            queryParams:
              (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
            skipBrowserRedirect: !0,
          }
        );
        return await tt(this.fetch, "GET", p, {
          headers: this.headers,
          jwt:
            (u =
              (c = d.session) === null || c === void 0
                ? void 0
                : c.access_token) !== null && u !== void 0
              ? u
              : void 0,
        });
      });
      if (r) throw r;
      return (
        Ri() &&
          !(
            !((n = e.options) === null || n === void 0) && n.skipBrowserRedirect
          ) &&
          window.location.assign(i == null ? void 0 : i.url),
        {
          data: {
            provider: e.provider,
            url: i == null ? void 0 : i.url,
          },
          error: null,
        }
      );
    } catch (i) {
      if (je(i))
        return {
          data: {
            provider: e.provider,
            url: null,
          },
          error: i,
        };
      throw i;
    }
  }
  async unlinkIdentity(e) {
    try {
      return await this._useSession(async (n) => {
        var i, r;
        const { data: s, error: a } = n;
        if (a) throw a;
        return await tt(
          this.fetch,
          "DELETE",
          `${this.url}/user/identities/${e.identity_id}`,
          {
            headers: this.headers,
            jwt:
              (r =
                (i = s.session) === null || i === void 0
                  ? void 0
                  : i.access_token) !== null && r !== void 0
                ? r
                : void 0,
          }
        );
      });
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
  async _refreshAccessToken(e) {
    const n = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
    this._debug(n, "begin");
    try {
      const i = Date.now();
      return await DI(
        async (r) => (
          r > 0 && (await NI(200 * Math.pow(2, r - 1))),
          this._debug(n, "refreshing attempt", r),
          await tt(
            this.fetch,
            "POST",
            `${this.url}/token?grant_type=refresh_token`,
            {
              body: {
                refresh_token: e,
              },
              headers: this.headers,
              xform: Rr,
            }
          )
        ),
        (r, s) => {
          const a = 200 * Math.pow(2, r);
          return s && Tf(s) && Date.now() + a - i < Ca;
        }
      );
    } catch (i) {
      if ((this._debug(n, "error", i), je(i)))
        return {
          data: {
            session: null,
            user: null,
          },
          error: i,
        };
      throw i;
    } finally {
      this._debug(n, "end");
    }
  }
  _isValidSession(e) {
    return (
      typeof e == "object" &&
      e !== null &&
      "access_token" in e &&
      "refresh_token" in e &&
      "expires_at" in e
    );
  }
  async _handleProviderSignIn(e, n) {
    const i = await this._getUrlForProvider(`${this.url}/authorize`, e, {
      redirectTo: n.redirectTo,
      scopes: n.scopes,
      queryParams: n.queryParams,
    });
    return (
      this._debug(
        "#_handleProviderSignIn()",
        "provider",
        e,
        "options",
        n,
        "url",
        i
      ),
      Ri() && !n.skipBrowserRedirect && window.location.assign(i),
      {
        data: {
          provider: e,
          url: i,
        },
        error: null,
      }
    );
  }
  async _recoverAndRefresh() {
    var e;
    const n = "#_recoverAndRefresh()";
    this._debug(n, "begin");
    try {
      const i = await ru(this.storage, this.storageKey);
      if (
        (this._debug(n, "session from storage", i), !this._isValidSession(i))
      ) {
        this._debug(n, "session is not valid"),
          i !== null && (await this._removeSession());
        return;
      }
      const r =
        ((e = i.expires_at) !== null && e !== void 0 ? e : 1 / 0) * 1e3 -
          Date.now() <
        wf;
      if (
        (this._debug(
          n,
          `session has${r ? "" : " not"} expired with margin of ${wf}s`
        ),
        r)
      ) {
        if (this.autoRefreshToken && i.refresh_token) {
          const { error: s } = await this._callRefreshToken(i.refresh_token);
          s &&
            (console.error(s),
            Tf(s) ||
              (this._debug(
                n,
                "refresh failed with a non-retryable error, removing the session",
                s
              ),
              await this._removeSession()));
        }
      } else await this._notifyAllSubscribers("SIGNED_IN", i);
    } catch (i) {
      this._debug(n, "error", i), console.error(i);
      return;
    } finally {
      this._debug(n, "end");
    }
  }
  async _callRefreshToken(e) {
    var n, i;
    if (!e) throw new Cr();
    if (this.refreshingDeferred) return this.refreshingDeferred.promise;
    const r = `#_callRefreshToken(${e.substring(0, 5)}...)`;
    this._debug(r, "begin");
    try {
      this.refreshingDeferred = new xh();
      const { data: s, error: a } = await this._refreshAccessToken(e);
      if (a) throw a;
      if (!s.session) throw new Cr();
      await this._saveSession(s.session),
        await this._notifyAllSubscribers("TOKEN_REFRESHED", s.session);
      const o = {
        session: s.session,
        error: null,
      };
      return this.refreshingDeferred.resolve(o), o;
    } catch (s) {
      if ((this._debug(r, "error", s), je(s))) {
        const a = {
          session: null,
          error: s,
        };
        return (
          Tf(s) || (await this._removeSession()),
          (n = this.refreshingDeferred) === null ||
            n === void 0 ||
            n.resolve(a),
          a
        );
      }
      throw (
        ((i = this.refreshingDeferred) === null || i === void 0 || i.reject(s),
        s)
      );
    } finally {
      (this.refreshingDeferred = null), this._debug(r, "end");
    }
  }
  async _notifyAllSubscribers(e, n, i = !0) {
    const r = `#_notifyAllSubscribers(${e})`;
    this._debug(r, "begin", n, `broadcast = ${i}`);
    try {
      this.broadcastChannel &&
        i &&
        this.broadcastChannel.postMessage({
          event: e,
          session: n,
        });
      const s = [],
        a = Array.from(this.stateChangeEmitters.values()).map(async (o) => {
          try {
            await o.callback(e, n);
          } catch (l) {
            s.push(l);
          }
        });
      if ((await Promise.all(a), s.length > 0)) {
        for (let o = 0; o < s.length; o += 1) console.error(s[o]);
        throw s[0];
      }
    } finally {
      this._debug(r, "end");
    }
  }
  async _saveSession(e) {
    this._debug("#_saveSession()", e),
      (this.suppressGetSessionWarning = !0),
      await XT(this.storage, this.storageKey, e);
  }
  async _removeSession() {
    this._debug("#_removeSession()"),
      await su(this.storage, this.storageKey),
      await this._notifyAllSubscribers("SIGNED_OUT", null);
  }
  _removeVisibilityChangedCallback() {
    this._debug("#_removeVisibilityChangedCallback()");
    const e = this.visibilityChangedCallback;
    this.visibilityChangedCallback = null;
    try {
      e &&
        Ri() &&
        window != null &&
        window.removeEventListener &&
        window.removeEventListener("visibilitychange", e);
    } catch (n) {
      console.error("removing visibilitychange callback failed", n);
    }
  }
  async _startAutoRefresh() {
    await this._stopAutoRefresh(), this._debug("#_startAutoRefresh()");
    const e = setInterval(() => this._autoRefreshTokenTick(), Ca);
    (this.autoRefreshTicker = e),
      e && typeof e == "object" && typeof e.unref == "function"
        ? e.unref()
        : typeof Deno < "u" &&
          typeof Deno.unrefTimer == "function" &&
          Deno.unrefTimer(e),
      setTimeout(async () => {
        await this.initializePromise, await this._autoRefreshTokenTick();
      }, 0);
  }
  async _stopAutoRefresh() {
    this._debug("#_stopAutoRefresh()");
    const e = this.autoRefreshTicker;
    (this.autoRefreshTicker = null), e && clearInterval(e);
  }
  async startAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._startAutoRefresh();
  }
  async stopAutoRefresh() {
    this._removeVisibilityChangedCallback(), await this._stopAutoRefresh();
  }
  async _autoRefreshTokenTick() {
    this._debug("#_autoRefreshTokenTick()", "begin");
    try {
      await this._acquireLock(0, async () => {
        try {
          const e = Date.now();
          try {
            return await this._useSession(async (n) => {
              const {
                data: { session: i },
              } = n;
              if (!i || !i.refresh_token || !i.expires_at) {
                this._debug("#_autoRefreshTokenTick()", "no session");
                return;
              }
              const r = Math.floor((i.expires_at * 1e3 - e) / Ca);
              this._debug(
                "#_autoRefreshTokenTick()",
                `access token expires in ${r} ticks, a tick lasts ${Ca}ms, refresh threshold is ${Mm} ticks`
              ),
                r <= Mm && (await this._callRefreshToken(i.refresh_token));
            });
          } catch (n) {
            console.error(
              "Auto refresh tick failed with error. This is likely a transient error.",
              n
            );
          }
        } finally {
          this._debug("#_autoRefreshTokenTick()", "end");
        }
      });
    } catch (e) {
      if (e.isAcquireTimeout || e instanceof qT)
        this._debug("auto refresh token tick lock not available");
      else throw e;
    }
  }
  async _handleVisibilityChange() {
    if (
      (this._debug("#_handleVisibilityChange()"),
      !Ri() || !(window != null && window.addEventListener))
    )
      return this.autoRefreshToken && this.startAutoRefresh(), !1;
    try {
      (this.visibilityChangedCallback = async () =>
        await this._onVisibilityChanged(!1)),
        window == null ||
          window.addEventListener(
            "visibilitychange",
            this.visibilityChangedCallback
          ),
        await this._onVisibilityChanged(!0);
    } catch (e) {
      console.error("_handleVisibilityChange", e);
    }
  }
  async _onVisibilityChanged(e) {
    const n = `#_onVisibilityChanged(${e})`;
    this._debug(n, "visibilityState", document.visibilityState),
      document.visibilityState === "visible"
        ? (this.autoRefreshToken && this._startAutoRefresh(),
          e ||
            (await this.initializePromise,
            await this._acquireLock(-1, async () => {
              if (document.visibilityState !== "visible") {
                this._debug(
                  n,
                  "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting"
                );
                return;
              }
              await this._recoverAndRefresh();
            })))
        : document.visibilityState === "hidden" &&
          this.autoRefreshToken &&
          this._stopAutoRefresh();
  }
  async _getUrlForProvider(e, n, i) {
    const r = [`provider=${encodeURIComponent(n)}`];
    if (
      (i != null &&
        i.redirectTo &&
        r.push(`redirect_to=${encodeURIComponent(i.redirectTo)}`),
      i != null && i.scopes && r.push(`scopes=${encodeURIComponent(i.scopes)}`),
      this.flowType === "pkce")
    ) {
      const [s, a] = await ua(this.storage, this.storageKey),
        o = new URLSearchParams({
          code_challenge: `${encodeURIComponent(s)}`,
          code_challenge_method: `${encodeURIComponent(a)}`,
        });
      r.push(o.toString());
    }
    if (i != null && i.queryParams) {
      const s = new URLSearchParams(i.queryParams);
      r.push(s.toString());
    }
    return (
      i != null &&
        i.skipBrowserRedirect &&
        r.push(`skip_http_redirect=${i.skipBrowserRedirect}`),
      `${e}?${r.join("&")}`
    );
  }
  async _unenroll(e) {
    try {
      return await this._useSession(async (n) => {
        var i;
        const { data: r, error: s } = n;
        return s
          ? {
              data: null,
              error: s,
            }
          : await tt(
              this.fetch,
              "DELETE",
              `${this.url}/factors/${e.factorId}`,
              {
                headers: this.headers,
                jwt:
                  (i = r == null ? void 0 : r.session) === null || i === void 0
                    ? void 0
                    : i.access_token,
              }
            );
      });
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
  async _enroll(e) {
    try {
      return await this._useSession(async (n) => {
        var i, r;
        const { data: s, error: a } = n;
        if (a)
          return {
            data: null,
            error: a,
          };
        const o = Object.assign(
            {
              friendly_name: e.friendlyName,
              factor_type: e.factorType,
            },
            e.factorType === "phone"
              ? {
                  phone: e.phone,
                }
              : {
                  issuer: e.issuer,
                }
          ),
          { data: l, error: c } = await tt(
            this.fetch,
            "POST",
            `${this.url}/factors`,
            {
              body: o,
              headers: this.headers,
              jwt:
                (i = s == null ? void 0 : s.session) === null || i === void 0
                  ? void 0
                  : i.access_token,
            }
          );
        return c
          ? {
              data: null,
              error: c,
            }
          : (e.factorType === "totp" &&
              !((r = l == null ? void 0 : l.totp) === null || r === void 0) &&
              r.qr_code &&
              (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
            {
              data: l,
              error: null,
            });
      });
    } catch (n) {
      if (je(n))
        return {
          data: null,
          error: n,
        };
      throw n;
    }
  }
  async _verify(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (n) => {
          var i;
          const { data: r, error: s } = n;
          if (s)
            return {
              data: null,
              error: s,
            };
          const { data: a, error: o } = await tt(
            this.fetch,
            "POST",
            `${this.url}/factors/${e.factorId}/verify`,
            {
              body: {
                code: e.code,
                challenge_id: e.challengeId,
              },
              headers: this.headers,
              jwt:
                (i = r == null ? void 0 : r.session) === null || i === void 0
                  ? void 0
                  : i.access_token,
            }
          );
          return o
            ? {
                data: null,
                error: o,
              }
            : (await this._saveSession(
                Object.assign(
                  {
                    expires_at: Math.round(Date.now() / 1e3) + a.expires_in,
                  },
                  a
                )
              ),
              await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
              {
                data: a,
                error: o,
              });
        });
      } catch (n) {
        if (je(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
  async _challenge(e) {
    return this._acquireLock(-1, async () => {
      try {
        return await this._useSession(async (n) => {
          var i;
          const { data: r, error: s } = n;
          return s
            ? {
                data: null,
                error: s,
              }
            : await tt(
                this.fetch,
                "POST",
                `${this.url}/factors/${e.factorId}/challenge`,
                {
                  body: {
                    channel: e.channel,
                  },
                  headers: this.headers,
                  jwt:
                    (i = r == null ? void 0 : r.session) === null ||
                    i === void 0
                      ? void 0
                      : i.access_token,
                }
              );
        });
      } catch (n) {
        if (je(n))
          return {
            data: null,
            error: n,
          };
        throw n;
      }
    });
  }
  async _challengeAndVerify(e) {
    const { data: n, error: i } = await this._challenge({
      factorId: e.factorId,
    });
    return i
      ? {
          data: null,
          error: i,
        }
      : await this._verify({
          factorId: e.factorId,
          challengeId: n.id,
          code: e.code,
        });
  }
  async _listFactors() {
    const {
      data: { user: e },
      error: n,
    } = await this.getUser();
    if (n)
      return {
        data: null,
        error: n,
      };
    const i = (e == null ? void 0 : e.factors) || [],
      r = i.filter((a) => a.factor_type === "totp" && a.status === "verified"),
      s = i.filter((a) => a.factor_type === "phone" && a.status === "verified");
    return {
      data: {
        all: i,
        totp: r,
        phone: s,
      },
      error: null,
    };
  }
  async _getAuthenticatorAssuranceLevel() {
    return this._acquireLock(
      -1,
      async () =>
        await this._useSession(async (e) => {
          var n, i;
          const {
            data: { session: r },
            error: s,
          } = e;
          if (s)
            return {
              data: null,
              error: s,
            };
          if (!r)
            return {
              data: {
                currentLevel: null,
                nextLevel: null,
                currentAuthenticationMethods: [],
              },
              error: null,
            };
          const { payload: a } = Mf(r.access_token);
          let o = null;
          a.aal && (o = a.aal);
          let l = o;
          ((i =
            (n = r.user.factors) === null || n === void 0
              ? void 0
              : n.filter((d) => d.status === "verified")) !== null &&
          i !== void 0
            ? i
            : []
          ).length > 0 && (l = "aal2");
          const u = a.amr || [];
          return {
            data: {
              currentLevel: o,
              nextLevel: l,
              currentAuthenticationMethods: u,
            },
            error: null,
          };
        })
    );
  }
  async fetchJwk(
    e,
    n = {
      keys: [],
    }
  ) {
    let i = n.keys.find((a) => a.kid === e);
    if (
      i ||
      ((i = this.jwks.keys.find((a) => a.kid === e)),
      i && this.jwks_cached_at + vI > Date.now())
    )
      return i;
    const { data: r, error: s } = await tt(
      this.fetch,
      "GET",
      `${this.url}/.well-known/jwks.json`,
      {
        headers: this.headers,
      }
    );
    if (s) throw s;
    if (!r.keys || r.keys.length === 0) throw new Al("JWKS is empty");
    if (
      ((this.jwks = r),
      (this.jwks_cached_at = Date.now()),
      (i = r.keys.find((a) => a.kid === e)),
      !i)
    )
      throw new Al("No matching signing key found in JWKS");
    return i;
  }
  async getClaims(
    e,
    n = {
      keys: [],
    }
  ) {
    try {
      let i = e;
      if (!i) {
        const { data: p, error: v } = await this.getSession();
        if (v || !p.session)
          return {
            data: null,
            error: v,
          };
        i = p.session.access_token;
      }
      const {
        header: r,
        payload: s,
        signature: a,
        raw: { header: o, payload: l },
      } = Mf(i);
      if (
        (zI(s.exp),
        !r.kid ||
          r.alg === "HS256" ||
          !("crypto" in globalThis && "subtle" in globalThis.crypto))
      ) {
        const { error: p } = await this.getUser(i);
        if (p) throw p;
        return {
          data: {
            claims: s,
            header: r,
            signature: a,
          },
          error: null,
        };
      }
      const c = jI(r.alg),
        u = await this.fetchJwk(r.kid, n),
        d = await crypto.subtle.importKey("jwk", u, c, !0, ["verify"]);
      if (!(await crypto.subtle.verify(c, d, a, AI(`${o}.${l}`))))
        throw new Al("Invalid JWT signature");
      return {
        data: {
          claims: s,
          header: r,
          signature: a,
        },
        error: null,
      };
    } catch (i) {
      if (je(i))
        return {
          data: null,
          error: i,
        };
      throw i;
    }
  }
}
Jl.nextInstanceID = 0;
const i3 = Jl;
class r3 extends i3 {
  constructor(e) {
    super(e);
  }
}
var s3 = function (t, e, n, i) {
  function r(s) {
    return s instanceof n
      ? s
      : new n(function (a) {
          a(s);
        });
  }
  return new (n || (n = Promise))(function (s, a) {
    function o(u) {
      try {
        c(i.next(u));
      } catch (d) {
        a(d);
      }
    }
    function l(u) {
      try {
        c(i.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? s(u.value) : r(u.value).then(o, l);
    }
    c((i = i.apply(t, e || [])).next());
  });
};
class a3 {
  constructor(e, n, i) {
    var r, s, a;
    if (((this.supabaseUrl = e), (this.supabaseKey = n), !e))
      throw new Error("supabaseUrl is required.");
    if (!n) throw new Error("supabaseKey is required.");
    const o = dI(e);
    (this.realtimeUrl = `${o}/realtime/v1`.replace(/^http/i, "ws")),
      (this.authUrl = `${o}/auth/v1`),
      (this.storageUrl = `${o}/storage/v1`),
      (this.functionsUrl = `${o}/functions/v1`);
    const l = `sb-${new URL(this.authUrl).hostname.split(".")[0]}-auth-token`,
      c = {
        db: iI,
        realtime: sI,
        auth: Object.assign(Object.assign({}, rI), {
          storageKey: l,
        }),
        global: nI,
      },
      u = hI(i ?? {}, c);
    (this.storageKey =
      (r = u.auth.storageKey) !== null && r !== void 0 ? r : ""),
      (this.headers = (s = u.global.headers) !== null && s !== void 0 ? s : {}),
      u.accessToken
        ? ((this.accessToken = u.accessToken),
          (this.auth = new Proxy(
            {},
            {
              get: (d, h) => {
                throw new Error(
                  `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(
                    h
                  )} is not possible`
                );
              },
            }
          )))
        : (this.auth = this._initSupabaseAuthClient(
            (a = u.auth) !== null && a !== void 0 ? a : {},
            this.headers,
            u.global.fetch
          )),
      (this.fetch = cI(n, this._getAccessToken.bind(this), u.global.fetch)),
      (this.realtime = this._initRealtimeClient(
        Object.assign(
          {
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this),
          },
          u.realtime
        )
      )),
      (this.rest = new Tk(`${o}/rest/v1`, {
        headers: this.headers,
        schema: u.db.schema,
        fetch: this.fetch,
      })),
      u.accessToken || this._listenForAuthEvents();
  }
  get functions() {
    return new ek(this.functionsUrl, {
      headers: this.headers,
      customFetch: this.fetch,
    });
  }
  get storage() {
    return new Qk(this.storageUrl, this.headers, this.fetch);
  }
  from(e) {
    return this.rest.from(e);
  }
  schema(e) {
    return this.rest.schema(e);
  }
  rpc(e, n = {}, i = {}) {
    return this.rest.rpc(e, n, i);
  }
  channel(
    e,
    n = {
      config: {},
    }
  ) {
    return this.realtime.channel(e, n);
  }
  getChannels() {
    return this.realtime.getChannels();
  }
  removeChannel(e) {
    return this.realtime.removeChannel(e);
  }
  removeAllChannels() {
    return this.realtime.removeAllChannels();
  }
  _getAccessToken() {
    var e, n;
    return s3(this, void 0, void 0, function* () {
      if (this.accessToken) return yield this.accessToken();
      const { data: i } = yield this.auth.getSession();
      return (n =
        (e = i.session) === null || e === void 0 ? void 0 : e.access_token) !==
        null && n !== void 0
        ? n
        : null;
    });
  }
  _initSupabaseAuthClient(
    {
      autoRefreshToken: e,
      persistSession: n,
      detectSessionInUrl: i,
      storage: r,
      storageKey: s,
      flowType: a,
      lock: o,
      debug: l,
    },
    c,
    u
  ) {
    const d = {
      Authorization: `Bearer ${this.supabaseKey}`,
      apikey: `${this.supabaseKey}`,
    };
    return new r3({
      url: this.authUrl,
      headers: Object.assign(Object.assign({}, d), c),
      storageKey: s,
      autoRefreshToken: e,
      persistSession: n,
      detectSessionInUrl: i,
      storage: r,
      flowType: a,
      lock: o,
      debug: l,
      fetch: u,
      hasCustomAuthorizationHeader: "Authorization" in this.headers,
    });
  }
  _initRealtimeClient(e) {
    return new Bk(
      this.realtimeUrl,
      Object.assign(Object.assign({}, e), {
        params: Object.assign(
          {
            apikey: this.supabaseKey,
          },
          e == null ? void 0 : e.params
        ),
      })
    );
  }
  _listenForAuthEvents() {
    return this.auth.onAuthStateChange((n, i) => {
      this._handleTokenChanged(
        n,
        "CLIENT",
        i == null ? void 0 : i.access_token
      );
    });
  }
  _handleTokenChanged(e, n, i) {
    (e === "TOKEN_REFRESHED" || e === "SIGNED_IN") &&
    this.changedAccessToken !== i
      ? (this.changedAccessToken = i)
      : e === "SIGNED_OUT" &&
        (this.realtime.setAuth(),
        n == "STORAGE" && this.auth.signOut(),
        (this.changedAccessToken = void 0));
  }
}
const o3 = (t, e, n) => new a3(t, e, n),
  l3 = "https://ndgrfzrtclotjswvoxny.supabase.co",
  c3 =
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5kZ3JmenJ0Y2xvdGpzd3ZveG55Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg5NzY4MDMsImV4cCI6MjA2NDU1MjgwM30.ZjPVckgEnZsRGl72WRexfrPnZE_LhqkUsWKhN-r3gpM",
  u3 = o3(l3, c3);
var rt;
(function (t) {
  t.assertEqual = (r) => r;
  function e(r) {}
  t.assertIs = e;
  function n(r) {
    throw new Error();
  }
  (t.assertNever = n),
    (t.arrayToEnum = (r) => {
      const s = {};
      for (const a of r) s[a] = a;
      return s;
    }),
    (t.getValidEnumValues = (r) => {
      const s = t.objectKeys(r).filter((o) => typeof r[r[o]] != "number"),
        a = {};
      for (const o of s) a[o] = r[o];
      return t.objectValues(a);
    }),
    (t.objectValues = (r) =>
      t.objectKeys(r).map(function (s) {
        return r[s];
      })),
    (t.objectKeys =
      typeof Object.keys == "function"
        ? (r) => Object.keys(r)
        : (r) => {
            const s = [];
            for (const a in r)
              Object.prototype.hasOwnProperty.call(r, a) && s.push(a);
            return s;
          }),
    (t.find = (r, s) => {
      for (const a of r) if (s(a)) return a;
    }),
    (t.isInteger =
      typeof Number.isInteger == "function"
        ? (r) => Number.isInteger(r)
        : (r) => typeof r == "number" && isFinite(r) && Math.floor(r) === r);
  function i(r, s = " | ") {
    return r.map((a) => (typeof a == "string" ? `'${a}'` : a)).join(s);
  }
  (t.joinValues = i),
    (t.jsonStringifyReplacer = (r, s) =>
      typeof s == "bigint" ? s.toString() : s);
})(rt || (rt = {}));
var Cm;
(function (t) {
  t.mergeShapes = (e, n) => ({
    ...e,
    ...n,
  });
})(Cm || (Cm = {}));
const me = rt.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
  ]),
  tr = (t) => {
    switch (typeof t) {
      case "undefined":
        return me.undefined;
      case "string":
        return me.string;
      case "number":
        return isNaN(t) ? me.nan : me.number;
      case "boolean":
        return me.boolean;
      case "function":
        return me.function;
      case "bigint":
        return me.bigint;
      case "symbol":
        return me.symbol;
      case "object":
        return Array.isArray(t)
          ? me.array
          : t === null
          ? me.null
          : t.then &&
            typeof t.then == "function" &&
            t.catch &&
            typeof t.catch == "function"
          ? me.promise
          : typeof Map < "u" && t instanceof Map
          ? me.map
          : typeof Set < "u" && t instanceof Set
          ? me.set
          : typeof Date < "u" && t instanceof Date
          ? me.date
          : me.object;
      default:
        return me.unknown;
    }
  },
  te = rt.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
  ]),
  d3 = (t) => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
class Hn extends Error {
  get errors() {
    return this.issues;
  }
  constructor(e) {
    super(),
      (this.issues = []),
      (this.addIssue = (i) => {
        this.issues = [...this.issues, i];
      }),
      (this.addIssues = (i = []) => {
        this.issues = [...this.issues, ...i];
      });
    const n = new.target.prototype;
    Object.setPrototypeOf
      ? Object.setPrototypeOf(this, n)
      : (this.__proto__ = n),
      (this.name = "ZodError"),
      (this.issues = e);
  }
  format(e) {
    const n =
        e ||
        function (s) {
          return s.message;
        },
      i = {
        _errors: [],
      },
      r = (s) => {
        for (const a of s.issues)
          if (a.code === "invalid_union") a.unionErrors.map(r);
          else if (a.code === "invalid_return_type") r(a.returnTypeError);
          else if (a.code === "invalid_arguments") r(a.argumentsError);
          else if (a.path.length === 0) i._errors.push(n(a));
          else {
            let o = i,
              l = 0;
            for (; l < a.path.length; ) {
              const c = a.path[l];
              l === a.path.length - 1
                ? ((o[c] = o[c] || {
                    _errors: [],
                  }),
                  o[c]._errors.push(n(a)))
                : (o[c] = o[c] || {
                    _errors: [],
                  }),
                (o = o[c]),
                l++;
            }
          }
      };
    return r(this), i;
  }
  static assert(e) {
    if (!(e instanceof Hn)) throw new Error(`Not a ZodError: ${e}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, rt.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(e = (n) => n.message) {
    const n = {},
      i = [];
    for (const r of this.issues)
      r.path.length > 0
        ? ((n[r.path[0]] = n[r.path[0]] || []), n[r.path[0]].push(e(r)))
        : i.push(e(r));
    return {
      formErrors: i,
      fieldErrors: n,
    };
  }
  get formErrors() {
    return this.flatten();
  }
}
Hn.create = (t) => new Hn(t);
const _o = (t, e) => {
  let n;
  switch (t.code) {
    case te.invalid_type:
      t.received === me.undefined
        ? (n = "Required")
        : (n = `Expected ${t.expected}, received ${t.received}`);
      break;
    case te.invalid_literal:
      n = `Invalid literal value, expected ${JSON.stringify(
        t.expected,
        rt.jsonStringifyReplacer
      )}`;
      break;
    case te.unrecognized_keys:
      n = `Unrecognized key(s) in object: ${rt.joinValues(t.keys, ", ")}`;
      break;
    case te.invalid_union:
      n = "Invalid input";
      break;
    case te.invalid_union_discriminator:
      n = `Invalid discriminator value. Expected ${rt.joinValues(t.options)}`;
      break;
    case te.invalid_enum_value:
      n = `Invalid enum value. Expected ${rt.joinValues(
        t.options
      )}, received '${t.received}'`;
      break;
    case te.invalid_arguments:
      n = "Invalid function arguments";
      break;
    case te.invalid_return_type:
      n = "Invalid function return type";
      break;
    case te.invalid_date:
      n = "Invalid date";
      break;
    case te.invalid_string:
      typeof t.validation == "object"
        ? "includes" in t.validation
          ? ((n = `Invalid input: must include "${t.validation.includes}"`),
            typeof t.validation.position == "number" &&
              (n = `${n} at one or more positions greater than or equal to ${t.validation.position}`))
          : "startsWith" in t.validation
          ? (n = `Invalid input: must start with "${t.validation.startsWith}"`)
          : "endsWith" in t.validation
          ? (n = `Invalid input: must end with "${t.validation.endsWith}"`)
          : rt.assertNever(t.validation)
        : t.validation !== "regex"
        ? (n = `Invalid ${t.validation}`)
        : (n = "Invalid");
      break;
    case te.too_small:
      t.type === "array"
        ? (n = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "more than"
          } ${t.minimum} element(s)`)
        : t.type === "string"
        ? (n = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at least" : "over"
          } ${t.minimum} character(s)`)
        : t.type === "number"
        ? (n = `Number must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${t.minimum}`)
        : t.type === "date"
        ? (n = `Date must be ${
            t.exact
              ? "exactly equal to "
              : t.inclusive
              ? "greater than or equal to "
              : "greater than "
          }${new Date(Number(t.minimum))}`)
        : (n = "Invalid input");
      break;
    case te.too_big:
      t.type === "array"
        ? (n = `Array must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "less than"
          } ${t.maximum} element(s)`)
        : t.type === "string"
        ? (n = `String must contain ${
            t.exact ? "exactly" : t.inclusive ? "at most" : "under"
          } ${t.maximum} character(s)`)
        : t.type === "number"
        ? (n = `Number must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "bigint"
        ? (n = `BigInt must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "less than or equal to"
              : "less than"
          } ${t.maximum}`)
        : t.type === "date"
        ? (n = `Date must be ${
            t.exact
              ? "exactly"
              : t.inclusive
              ? "smaller than or equal to"
              : "smaller than"
          } ${new Date(Number(t.maximum))}`)
        : (n = "Invalid input");
      break;
    case te.custom:
      n = "Invalid input";
      break;
    case te.invalid_intersection_types:
      n = "Intersection results could not be merged";
      break;
    case te.not_multiple_of:
      n = `Number must be a multiple of ${t.multipleOf}`;
      break;
    case te.not_finite:
      n = "Number must be finite";
      break;
    default:
      (n = e.defaultError), rt.assertNever(t);
  }
  return {
    message: n,
  };
};
let YT = _o;
function h3(t) {
  YT = t;
}
function Pd() {
  return YT;
}
const Ld = (t) => {
    const { data: e, path: n, errorMaps: i, issueData: r } = t,
      s = [...n, ...(r.path || [])],
      a = {
        ...r,
        path: s,
      };
    if (r.message !== void 0)
      return {
        ...r,
        path: s,
        message: r.message,
      };
    let o = "";
    const l = i
      .filter((c) => !!c)
      .slice()
      .reverse();
    for (const c of l)
      o = c(a, {
        data: e,
        defaultError: o,
      }).message;
    return {
      ...r,
      path: s,
      message: o,
    };
  },
  f3 = [];
function ue(t, e) {
  const n = Pd(),
    i = Ld({
      issueData: e,
      data: t.data,
      path: t.path,
      errorMaps: [
        t.common.contextualErrorMap,
        t.schemaErrorMap,
        n,
        n === _o ? void 0 : _o,
      ].filter((r) => !!r),
    });
  t.common.issues.push(i);
}
class fn {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(e, n) {
    const i = [];
    for (const r of n) {
      if (r.status === "aborted") return Le;
      r.status === "dirty" && e.dirty(), i.push(r.value);
    }
    return {
      status: e.value,
      value: i,
    };
  }
  static async mergeObjectAsync(e, n) {
    const i = [];
    for (const r of n) {
      const s = await r.key,
        a = await r.value;
      i.push({
        key: s,
        value: a,
      });
    }
    return fn.mergeObjectSync(e, i);
  }
  static mergeObjectSync(e, n) {
    const i = {};
    for (const r of n) {
      const { key: s, value: a } = r;
      if (s.status === "aborted" || a.status === "aborted") return Le;
      s.status === "dirty" && e.dirty(),
        a.status === "dirty" && e.dirty(),
        s.value !== "__proto__" &&
          (typeof a.value < "u" || r.alwaysSet) &&
          (i[s.value] = a.value);
    }
    return {
      status: e.value,
      value: i,
    };
  }
}
const Le = Object.freeze({
    status: "aborted",
  }),
  Xa = (t) => ({
    status: "dirty",
    value: t,
  }),
  xn = (t) => ({
    status: "valid",
    value: t,
  }),
  Rm = (t) => t.status === "aborted",
  Pm = (t) => t.status === "dirty",
  Js = (t) => t.status === "valid",
  Ql = (t) => typeof Promise < "u" && t instanceof Promise;
function Nd(t, e, n, i) {
  if (typeof e == "function" ? t !== e || !i : !e.has(t))
    throw new TypeError(
      "Cannot read private member from an object whose class did not declare it"
    );
  return e.get(t);
}
function ZT(t, e, n, i, r) {
  if (typeof e == "function" ? t !== e || !r : !e.has(t))
    throw new TypeError(
      "Cannot write private member to an object whose class did not declare it"
    );
  return e.set(t, n), n;
}
var ye;
(function (t) {
  (t.errToObj = (e) =>
    typeof e == "string"
      ? {
          message: e,
        }
      : e || {}),
    (t.toString = (e) =>
      typeof e == "string" ? e : e == null ? void 0 : e.message);
})(ye || (ye = {}));
var cl, ul;
class Vi {
  constructor(e, n, i, r) {
    (this._cachedPath = []),
      (this.parent = e),
      (this.data = n),
      (this._path = i),
      (this._key = r);
  }
  get path() {
    return (
      this._cachedPath.length ||
        (this._key instanceof Array
          ? this._cachedPath.push(...this._path, ...this._key)
          : this._cachedPath.push(...this._path, this._key)),
      this._cachedPath
    );
  }
}
const Hy = (t, e) => {
  if (Js(e))
    return {
      success: !0,
      data: e.value,
    };
  if (!t.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error) return this._error;
      const n = new Hn(t.common.issues);
      return (this._error = n), this._error;
    },
  };
};
function Fe(t) {
  if (!t) return {};
  const {
    errorMap: e,
    invalid_type_error: n,
    required_error: i,
    description: r,
  } = t;
  if (e && (n || i))
    throw new Error(
      `Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`
    );
  return e
    ? {
        errorMap: e,
        description: r,
      }
    : {
        errorMap: (a, o) => {
          var l, c;
          const { message: u } = t;
          return a.code === "invalid_enum_value"
            ? {
                message: u ?? o.defaultError,
              }
            : typeof o.data > "u"
            ? {
                message:
                  (l = u ?? i) !== null && l !== void 0 ? l : o.defaultError,
              }
            : a.code !== "invalid_type"
            ? {
                message: o.defaultError,
              }
            : {
                message:
                  (c = u ?? n) !== null && c !== void 0 ? c : o.defaultError,
              };
        },
        description: r,
      };
}
class Xe {
  get description() {
    return this._def.description;
  }
  _getType(e) {
    return tr(e.data);
  }
  _getOrReturnCtx(e, n) {
    return (
      n || {
        common: e.parent.common,
        data: e.data,
        parsedType: tr(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      }
    );
  }
  _processInputParams(e) {
    return {
      status: new fn(),
      ctx: {
        common: e.parent.common,
        data: e.data,
        parsedType: tr(e.data),
        schemaErrorMap: this._def.errorMap,
        path: e.path,
        parent: e.parent,
      },
    };
  }
  _parseSync(e) {
    const n = this._parse(e);
    if (Ql(n)) throw new Error("Synchronous parse encountered promise.");
    return n;
  }
  _parseAsync(e) {
    const n = this._parse(e);
    return Promise.resolve(n);
  }
  parse(e, n) {
    const i = this.safeParse(e, n);
    if (i.success) return i.data;
    throw i.error;
  }
  safeParse(e, n) {
    var i;
    const r = {
        common: {
          issues: [],
          async:
            (i = n == null ? void 0 : n.async) !== null && i !== void 0
              ? i
              : !1,
          contextualErrorMap: n == null ? void 0 : n.errorMap,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: tr(e),
      },
      s = this._parseSync({
        data: e,
        path: r.path,
        parent: r,
      });
    return Hy(r, s);
  }
  "~validate"(e) {
    var n, i;
    const r = {
      common: {
        issues: [],
        async: !!this["~standard"].async,
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data: e,
      parsedType: tr(e),
    };
    if (!this["~standard"].async)
      try {
        const s = this._parseSync({
          data: e,
          path: [],
          parent: r,
        });
        return Js(s)
          ? {
              value: s.value,
            }
          : {
              issues: r.common.issues,
            };
      } catch (s) {
        !(
          (i =
            (n = s == null ? void 0 : s.message) === null || n === void 0
              ? void 0
              : n.toLowerCase()) === null || i === void 0
        ) &&
          i.includes("encountered") &&
          (this["~standard"].async = !0),
          (r.common = {
            issues: [],
            async: !0,
          });
      }
    return this._parseAsync({
      data: e,
      path: [],
      parent: r,
    }).then((s) =>
      Js(s)
        ? {
            value: s.value,
          }
        : {
            issues: r.common.issues,
          }
    );
  }
  async parseAsync(e, n) {
    const i = await this.safeParseAsync(e, n);
    if (i.success) return i.data;
    throw i.error;
  }
  async safeParseAsync(e, n) {
    const i = {
        common: {
          issues: [],
          contextualErrorMap: n == null ? void 0 : n.errorMap,
          async: !0,
        },
        path: (n == null ? void 0 : n.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data: e,
        parsedType: tr(e),
      },
      r = this._parse({
        data: e,
        path: i.path,
        parent: i,
      }),
      s = await (Ql(r) ? r : Promise.resolve(r));
    return Hy(i, s);
  }
  refine(e, n) {
    const i = (r) =>
      typeof n == "string" || typeof n > "u"
        ? {
            message: n,
          }
        : typeof n == "function"
        ? n(r)
        : n;
    return this._refinement((r, s) => {
      const a = e(r),
        o = () =>
          s.addIssue({
            code: te.custom,
            ...i(r),
          });
      return typeof Promise < "u" && a instanceof Promise
        ? a.then((l) => (l ? !0 : (o(), !1)))
        : a
        ? !0
        : (o(), !1);
    });
  }
  refinement(e, n) {
    return this._refinement((i, r) =>
      e(i) ? !0 : (r.addIssue(typeof n == "function" ? n(i, r) : n), !1)
    );
  }
  _refinement(e) {
    return new bi({
      schema: this,
      typeName: Ce.ZodEffects,
      effect: {
        type: "refinement",
        refinement: e,
      },
    });
  }
  superRefine(e) {
    return this._refinement(e);
  }
  constructor(e) {
    (this.spa = this.safeParseAsync),
      (this._def = e),
      (this.parse = this.parse.bind(this)),
      (this.safeParse = this.safeParse.bind(this)),
      (this.parseAsync = this.parseAsync.bind(this)),
      (this.safeParseAsync = this.safeParseAsync.bind(this)),
      (this.spa = this.spa.bind(this)),
      (this.refine = this.refine.bind(this)),
      (this.refinement = this.refinement.bind(this)),
      (this.superRefine = this.superRefine.bind(this)),
      (this.optional = this.optional.bind(this)),
      (this.nullable = this.nullable.bind(this)),
      (this.nullish = this.nullish.bind(this)),
      (this.array = this.array.bind(this)),
      (this.promise = this.promise.bind(this)),
      (this.or = this.or.bind(this)),
      (this.and = this.and.bind(this)),
      (this.transform = this.transform.bind(this)),
      (this.brand = this.brand.bind(this)),
      (this.default = this.default.bind(this)),
      (this.catch = this.catch.bind(this)),
      (this.describe = this.describe.bind(this)),
      (this.pipe = this.pipe.bind(this)),
      (this.readonly = this.readonly.bind(this)),
      (this.isNullable = this.isNullable.bind(this)),
      (this.isOptional = this.isOptional.bind(this)),
      (this["~standard"] = {
        version: 1,
        vendor: "zod",
        validate: (n) => this["~validate"](n),
      });
  }
  optional() {
    return zi.create(this, this._def);
  }
  nullable() {
    return ss.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return wi.create(this);
  }
  promise() {
    return xo.create(this, this._def);
  }
  or(e) {
    return ic.create([this, e], this._def);
  }
  and(e) {
    return rc.create(this, e, this._def);
  }
  transform(e) {
    return new bi({
      ...Fe(this._def),
      schema: this,
      typeName: Ce.ZodEffects,
      effect: {
        type: "transform",
        transform: e,
      },
    });
  }
  default(e) {
    const n = typeof e == "function" ? e : () => e;
    return new cc({
      ...Fe(this._def),
      innerType: this,
      defaultValue: n,
      typeName: Ce.ZodDefault,
    });
  }
  brand() {
    return new Av({
      typeName: Ce.ZodBranded,
      type: this,
      ...Fe(this._def),
    });
  }
  catch(e) {
    const n = typeof e == "function" ? e : () => e;
    return new uc({
      ...Fe(this._def),
      innerType: this,
      catchValue: n,
      typeName: Ce.ZodCatch,
    });
  }
  describe(e) {
    const n = this.constructor;
    return new n({
      ...this._def,
      description: e,
    });
  }
  pipe(e) {
    return bc.create(this, e);
  }
  readonly() {
    return dc.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const p3 = /^c[^\s-]{8,}$/i,
  m3 = /^[0-9a-z]+$/,
  g3 = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
  v3 =
    /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
  _3 = /^[a-z0-9_-]{21}$/i,
  y3 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
  x3 =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  S3 =
    /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i,
  w3 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let bf;
const E3 =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  T3 =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  M3 =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
  b3 =
    /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  A3 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  C3 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  KT =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  R3 = new RegExp(`^${KT}$`);
function JT(t) {
  let e = "[0-5]\\d";
  t.precision
    ? (e = `${e}\\.\\d{${t.precision}}`)
    : t.precision == null && (e = `${e}(\\.\\d+)?`);
  const n = t.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${n}`;
}
function P3(t) {
  return new RegExp(`^${JT(t)}$`);
}
function QT(t) {
  let e = `${KT}T${JT(t)}`;
  const n = [];
  return (
    n.push(t.local ? "Z?" : "Z"),
    t.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    (e = `${e}(${n.join("|")})`),
    new RegExp(`^${e}$`)
  );
}
function L3(t, e) {
  return !!(
    ((e === "v4" || !e) && E3.test(t)) ||
    ((e === "v6" || !e) && M3.test(t))
  );
}
function N3(t, e) {
  if (!y3.test(t)) return !1;
  try {
    const [n] = t.split("."),
      i = n
        .replace(/-/g, "+")
        .replace(/_/g, "/")
        .padEnd(n.length + ((4 - (n.length % 4)) % 4), "="),
      r = JSON.parse(atob(i));
    return !(
      typeof r != "object" ||
      r === null ||
      !r.typ ||
      !r.alg ||
      (e && r.alg !== e)
    );
  } catch {
    return !1;
  }
}
function D3(t, e) {
  return !!(
    ((e === "v4" || !e) && T3.test(t)) ||
    ((e === "v6" || !e) && b3.test(t))
  );
}
class yi extends Xe {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = String(e.data)),
      this._getType(e) !== me.string)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        ue(s, {
          code: te.invalid_type,
          expected: me.string,
          received: s.parsedType,
        }),
        Le
      );
    }
    const i = new fn();
    let r;
    for (const s of this._def.checks)
      if (s.kind === "min")
        e.data.length < s.value &&
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            code: te.too_small,
            minimum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "max")
        e.data.length > s.value &&
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            code: te.too_big,
            maximum: s.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "length") {
        const a = e.data.length > s.value,
          o = e.data.length < s.value;
        (a || o) &&
          ((r = this._getOrReturnCtx(e, r)),
          a
            ? ue(r, {
                code: te.too_big,
                maximum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              })
            : o &&
              ue(r, {
                code: te.too_small,
                minimum: s.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: s.message,
              }),
          i.dirty());
      } else if (s.kind === "email")
        S3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "email",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "emoji")
        bf || (bf = new RegExp(w3, "u")),
          bf.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "emoji",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty());
      else if (s.kind === "uuid")
        v3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "uuid",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "nanoid")
        _3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "nanoid",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "cuid")
        p3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "cuid",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "cuid2")
        m3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "cuid2",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "ulid")
        g3.test(e.data) ||
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            validation: "ulid",
            code: te.invalid_string,
            message: s.message,
          }),
          i.dirty());
      else if (s.kind === "url")
        try {
          new URL(e.data);
        } catch {
          (r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "url",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty();
        }
      else
        s.kind === "regex"
          ? ((s.regex.lastIndex = 0),
            s.regex.test(e.data) ||
              ((r = this._getOrReturnCtx(e, r)),
              ue(r, {
                validation: "regex",
                code: te.invalid_string,
                message: s.message,
              }),
              i.dirty()))
          : s.kind === "trim"
          ? (e.data = e.data.trim())
          : s.kind === "includes"
          ? e.data.includes(s.value, s.position) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: {
                includes: s.value,
                position: s.position,
              },
              message: s.message,
            }),
            i.dirty())
          : s.kind === "toLowerCase"
          ? (e.data = e.data.toLowerCase())
          : s.kind === "toUpperCase"
          ? (e.data = e.data.toUpperCase())
          : s.kind === "startsWith"
          ? e.data.startsWith(s.value) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: {
                startsWith: s.value,
              },
              message: s.message,
            }),
            i.dirty())
          : s.kind === "endsWith"
          ? e.data.endsWith(s.value) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: {
                endsWith: s.value,
              },
              message: s.message,
            }),
            i.dirty())
          : s.kind === "datetime"
          ? QT(s).test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: "datetime",
              message: s.message,
            }),
            i.dirty())
          : s.kind === "date"
          ? R3.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: "date",
              message: s.message,
            }),
            i.dirty())
          : s.kind === "time"
          ? P3(s).test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              code: te.invalid_string,
              validation: "time",
              message: s.message,
            }),
            i.dirty())
          : s.kind === "duration"
          ? x3.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "duration",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "ip"
          ? L3(e.data, s.version) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "ip",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "jwt"
          ? N3(e.data, s.alg) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "jwt",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "cidr"
          ? D3(e.data, s.version) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "cidr",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "base64"
          ? A3.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "base64",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : s.kind === "base64url"
          ? C3.test(e.data) ||
            ((r = this._getOrReturnCtx(e, r)),
            ue(r, {
              validation: "base64url",
              code: te.invalid_string,
              message: s.message,
            }),
            i.dirty())
          : rt.assertNever(s);
    return {
      status: i.value,
      value: e.data,
    };
  }
  _regex(e, n, i) {
    return this.refinement((r) => e.test(r), {
      validation: n,
      code: te.invalid_string,
      ...ye.errToObj(i),
    });
  }
  _addCheck(e) {
    return new yi({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  email(e) {
    return this._addCheck({
      kind: "email",
      ...ye.errToObj(e),
    });
  }
  url(e) {
    return this._addCheck({
      kind: "url",
      ...ye.errToObj(e),
    });
  }
  emoji(e) {
    return this._addCheck({
      kind: "emoji",
      ...ye.errToObj(e),
    });
  }
  uuid(e) {
    return this._addCheck({
      kind: "uuid",
      ...ye.errToObj(e),
    });
  }
  nanoid(e) {
    return this._addCheck({
      kind: "nanoid",
      ...ye.errToObj(e),
    });
  }
  cuid(e) {
    return this._addCheck({
      kind: "cuid",
      ...ye.errToObj(e),
    });
  }
  cuid2(e) {
    return this._addCheck({
      kind: "cuid2",
      ...ye.errToObj(e),
    });
  }
  ulid(e) {
    return this._addCheck({
      kind: "ulid",
      ...ye.errToObj(e),
    });
  }
  base64(e) {
    return this._addCheck({
      kind: "base64",
      ...ye.errToObj(e),
    });
  }
  base64url(e) {
    return this._addCheck({
      kind: "base64url",
      ...ye.errToObj(e),
    });
  }
  jwt(e) {
    return this._addCheck({
      kind: "jwt",
      ...ye.errToObj(e),
    });
  }
  ip(e) {
    return this._addCheck({
      kind: "ip",
      ...ye.errToObj(e),
    });
  }
  cidr(e) {
    return this._addCheck({
      kind: "cidr",
      ...ye.errToObj(e),
    });
  }
  datetime(e) {
    var n, i;
    return typeof e == "string"
      ? this._addCheck({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: e,
        })
      : this._addCheck({
          kind: "datetime",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          offset:
            (n = e == null ? void 0 : e.offset) !== null && n !== void 0
              ? n
              : !1,
          local:
            (i = e == null ? void 0 : e.local) !== null && i !== void 0
              ? i
              : !1,
          ...ye.errToObj(e == null ? void 0 : e.message),
        });
  }
  date(e) {
    return this._addCheck({
      kind: "date",
      message: e,
    });
  }
  time(e) {
    return typeof e == "string"
      ? this._addCheck({
          kind: "time",
          precision: null,
          message: e,
        })
      : this._addCheck({
          kind: "time",
          precision:
            typeof (e == null ? void 0 : e.precision) > "u"
              ? null
              : e == null
              ? void 0
              : e.precision,
          ...ye.errToObj(e == null ? void 0 : e.message),
        });
  }
  duration(e) {
    return this._addCheck({
      kind: "duration",
      ...ye.errToObj(e),
    });
  }
  regex(e, n) {
    return this._addCheck({
      kind: "regex",
      regex: e,
      ...ye.errToObj(n),
    });
  }
  includes(e, n) {
    return this._addCheck({
      kind: "includes",
      value: e,
      position: n == null ? void 0 : n.position,
      ...ye.errToObj(n == null ? void 0 : n.message),
    });
  }
  startsWith(e, n) {
    return this._addCheck({
      kind: "startsWith",
      value: e,
      ...ye.errToObj(n),
    });
  }
  endsWith(e, n) {
    return this._addCheck({
      kind: "endsWith",
      value: e,
      ...ye.errToObj(n),
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e,
      ...ye.errToObj(n),
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e,
      ...ye.errToObj(n),
    });
  }
  length(e, n) {
    return this._addCheck({
      kind: "length",
      value: e,
      ...ye.errToObj(n),
    });
  }
  nonempty(e) {
    return this.min(1, ye.errToObj(e));
  }
  trim() {
    return new yi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "trim",
        },
      ],
    });
  }
  toLowerCase() {
    return new yi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "toLowerCase",
        },
      ],
    });
  }
  toUpperCase() {
    return new yi({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: "toUpperCase",
        },
      ],
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((e) => e.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((e) => e.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((e) => e.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((e) => e.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((e) => e.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((e) => e.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((e) => e.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((e) => e.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((e) => e.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((e) => e.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((e) => e.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((e) => e.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((e) => e.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((e) => e.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((e) => e.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((e) => e.kind === "base64url");
  }
  get minLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxLength() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
yi.create = (t) => {
  var e;
  return new yi({
    checks: [],
    typeName: Ce.ZodString,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Fe(t),
  });
};
function k3(t, e) {
  const n = (t.toString().split(".")[1] || "").length,
    i = (e.toString().split(".")[1] || "").length,
    r = n > i ? n : i,
    s = parseInt(t.toFixed(r).replace(".", "")),
    a = parseInt(e.toFixed(r).replace(".", ""));
  return (s % a) / Math.pow(10, r);
}
class ns extends Xe {
  constructor() {
    super(...arguments),
      (this.min = this.gte),
      (this.max = this.lte),
      (this.step = this.multipleOf);
  }
  _parse(e) {
    if (
      (this._def.coerce && (e.data = Number(e.data)),
      this._getType(e) !== me.number)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        ue(s, {
          code: te.invalid_type,
          expected: me.number,
          received: s.parsedType,
        }),
        Le
      );
    }
    let i;
    const r = new fn();
    for (const s of this._def.checks)
      s.kind === "int"
        ? rt.isInteger(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.invalid_type,
            expected: "integer",
            received: "float",
            message: s.message,
          }),
          r.dirty())
        : s.kind === "min"
        ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.too_small,
            minimum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          r.dirty())
        : s.kind === "max"
        ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.too_big,
            maximum: s.value,
            type: "number",
            inclusive: s.inclusive,
            exact: !1,
            message: s.message,
          }),
          r.dirty())
        : s.kind === "multipleOf"
        ? k3(e.data, s.value) !== 0 &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          r.dirty())
        : s.kind === "finite"
        ? Number.isFinite(e.data) ||
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.not_finite,
            message: s.message,
          }),
          r.dirty())
        : rt.assertNever(s);
    return {
      status: r.value,
      value: e.data,
    };
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ye.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ye.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ye.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ye.toString(n));
  }
  setLimit(e, n, i, r) {
    return new ns({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: i,
          message: ye.toString(r),
        },
      ],
    });
  }
  _addCheck(e) {
    return new ns({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  int(e) {
    return this._addCheck({
      kind: "int",
      message: ye.toString(e),
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: ye.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: ye.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: ye.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: ye.toString(e),
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ye.toString(n),
    });
  }
  finite(e) {
    return this._addCheck({
      kind: "finite",
      message: ye.toString(e),
    });
  }
  safe(e) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: ye.toString(e),
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: ye.toString(e),
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
  get isInt() {
    return !!this._def.checks.find(
      (e) =>
        e.kind === "int" || (e.kind === "multipleOf" && rt.isInteger(e.value))
    );
  }
  get isFinite() {
    let e = null,
      n = null;
    for (const i of this._def.checks) {
      if (i.kind === "finite" || i.kind === "int" || i.kind === "multipleOf")
        return !0;
      i.kind === "min"
        ? (n === null || i.value > n) && (n = i.value)
        : i.kind === "max" && (e === null || i.value < e) && (e = i.value);
    }
    return Number.isFinite(n) && Number.isFinite(e);
  }
}
ns.create = (t) =>
  new ns({
    checks: [],
    typeName: Ce.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...Fe(t),
  });
class is extends Xe {
  constructor() {
    super(...arguments), (this.min = this.gte), (this.max = this.lte);
  }
  _parse(e) {
    if (this._def.coerce)
      try {
        e.data = BigInt(e.data);
      } catch {
        return this._getInvalidInput(e);
      }
    if (this._getType(e) !== me.bigint) return this._getInvalidInput(e);
    let i;
    const r = new fn();
    for (const s of this._def.checks)
      s.kind === "min"
        ? (s.inclusive ? e.data < s.value : e.data <= s.value) &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.too_small,
            type: "bigint",
            minimum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          r.dirty())
        : s.kind === "max"
        ? (s.inclusive ? e.data > s.value : e.data >= s.value) &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.too_big,
            type: "bigint",
            maximum: s.value,
            inclusive: s.inclusive,
            message: s.message,
          }),
          r.dirty())
        : s.kind === "multipleOf"
        ? e.data % s.value !== BigInt(0) &&
          ((i = this._getOrReturnCtx(e, i)),
          ue(i, {
            code: te.not_multiple_of,
            multipleOf: s.value,
            message: s.message,
          }),
          r.dirty())
        : rt.assertNever(s);
    return {
      status: r.value,
      value: e.data,
    };
  }
  _getInvalidInput(e) {
    const n = this._getOrReturnCtx(e);
    return (
      ue(n, {
        code: te.invalid_type,
        expected: me.bigint,
        received: n.parsedType,
      }),
      Le
    );
  }
  gte(e, n) {
    return this.setLimit("min", e, !0, ye.toString(n));
  }
  gt(e, n) {
    return this.setLimit("min", e, !1, ye.toString(n));
  }
  lte(e, n) {
    return this.setLimit("max", e, !0, ye.toString(n));
  }
  lt(e, n) {
    return this.setLimit("max", e, !1, ye.toString(n));
  }
  setLimit(e, n, i, r) {
    return new is({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind: e,
          value: n,
          inclusive: i,
          message: ye.toString(r),
        },
      ],
    });
  }
  _addCheck(e) {
    return new is({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  positive(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: ye.toString(e),
    });
  }
  negative(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: ye.toString(e),
    });
  }
  nonpositive(e) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: ye.toString(e),
    });
  }
  nonnegative(e) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: ye.toString(e),
    });
  }
  multipleOf(e, n) {
    return this._addCheck({
      kind: "multipleOf",
      value: e,
      message: ye.toString(n),
    });
  }
  get minValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e;
  }
  get maxValue() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e;
  }
}
is.create = (t) => {
  var e;
  return new is({
    checks: [],
    typeName: Ce.ZodBigInt,
    coerce:
      (e = t == null ? void 0 : t.coerce) !== null && e !== void 0 ? e : !1,
    ...Fe(t),
  });
};
class ec extends Xe {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = !!e.data), this._getType(e) !== me.boolean)
    ) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.boolean,
          received: i.parsedType,
        }),
        Le
      );
    }
    return xn(e.data);
  }
}
ec.create = (t) =>
  new ec({
    typeName: Ce.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...Fe(t),
  });
class Qs extends Xe {
  _parse(e) {
    if (
      (this._def.coerce && (e.data = new Date(e.data)),
      this._getType(e) !== me.date)
    ) {
      const s = this._getOrReturnCtx(e);
      return (
        ue(s, {
          code: te.invalid_type,
          expected: me.date,
          received: s.parsedType,
        }),
        Le
      );
    }
    if (isNaN(e.data.getTime())) {
      const s = this._getOrReturnCtx(e);
      return (
        ue(s, {
          code: te.invalid_date,
        }),
        Le
      );
    }
    const i = new fn();
    let r;
    for (const s of this._def.checks)
      s.kind === "min"
        ? e.data.getTime() < s.value &&
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            code: te.too_small,
            message: s.message,
            inclusive: !0,
            exact: !1,
            minimum: s.value,
            type: "date",
          }),
          i.dirty())
        : s.kind === "max"
        ? e.data.getTime() > s.value &&
          ((r = this._getOrReturnCtx(e, r)),
          ue(r, {
            code: te.too_big,
            message: s.message,
            inclusive: !0,
            exact: !1,
            maximum: s.value,
            type: "date",
          }),
          i.dirty())
        : rt.assertNever(s);
    return {
      status: i.value,
      value: new Date(e.data.getTime()),
    };
  }
  _addCheck(e) {
    return new Qs({
      ...this._def,
      checks: [...this._def.checks, e],
    });
  }
  min(e, n) {
    return this._addCheck({
      kind: "min",
      value: e.getTime(),
      message: ye.toString(n),
    });
  }
  max(e, n) {
    return this._addCheck({
      kind: "max",
      value: e.getTime(),
      message: ye.toString(n),
    });
  }
  get minDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "min" && (e === null || n.value > e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
  get maxDate() {
    let e = null;
    for (const n of this._def.checks)
      n.kind === "max" && (e === null || n.value < e) && (e = n.value);
    return e != null ? new Date(e) : null;
  }
}
Qs.create = (t) =>
  new Qs({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: Ce.ZodDate,
    ...Fe(t),
  });
class Dd extends Xe {
  _parse(e) {
    if (this._getType(e) !== me.symbol) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.symbol,
          received: i.parsedType,
        }),
        Le
      );
    }
    return xn(e.data);
  }
}
Dd.create = (t) =>
  new Dd({
    typeName: Ce.ZodSymbol,
    ...Fe(t),
  });
class tc extends Xe {
  _parse(e) {
    if (this._getType(e) !== me.undefined) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.undefined,
          received: i.parsedType,
        }),
        Le
      );
    }
    return xn(e.data);
  }
}
tc.create = (t) =>
  new tc({
    typeName: Ce.ZodUndefined,
    ...Fe(t),
  });
class nc extends Xe {
  _parse(e) {
    if (this._getType(e) !== me.null) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.null,
          received: i.parsedType,
        }),
        Le
      );
    }
    return xn(e.data);
  }
}
nc.create = (t) =>
  new nc({
    typeName: Ce.ZodNull,
    ...Fe(t),
  });
class yo extends Xe {
  constructor() {
    super(...arguments), (this._any = !0);
  }
  _parse(e) {
    return xn(e.data);
  }
}
yo.create = (t) =>
  new yo({
    typeName: Ce.ZodAny,
    ...Fe(t),
  });
class Vs extends Xe {
  constructor() {
    super(...arguments), (this._unknown = !0);
  }
  _parse(e) {
    return xn(e.data);
  }
}
Vs.create = (t) =>
  new Vs({
    typeName: Ce.ZodUnknown,
    ...Fe(t),
  });
class mr extends Xe {
  _parse(e) {
    const n = this._getOrReturnCtx(e);
    return (
      ue(n, {
        code: te.invalid_type,
        expected: me.never,
        received: n.parsedType,
      }),
      Le
    );
  }
}
mr.create = (t) =>
  new mr({
    typeName: Ce.ZodNever,
    ...Fe(t),
  });
class kd extends Xe {
  _parse(e) {
    if (this._getType(e) !== me.undefined) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.void,
          received: i.parsedType,
        }),
        Le
      );
    }
    return xn(e.data);
  }
}
kd.create = (t) =>
  new kd({
    typeName: Ce.ZodVoid,
    ...Fe(t),
  });
class wi extends Xe {
  _parse(e) {
    const { ctx: n, status: i } = this._processInputParams(e),
      r = this._def;
    if (n.parsedType !== me.array)
      return (
        ue(n, {
          code: te.invalid_type,
          expected: me.array,
          received: n.parsedType,
        }),
        Le
      );
    if (r.exactLength !== null) {
      const a = n.data.length > r.exactLength.value,
        o = n.data.length < r.exactLength.value;
      (a || o) &&
        (ue(n, {
          code: a ? te.too_big : te.too_small,
          minimum: o ? r.exactLength.value : void 0,
          maximum: a ? r.exactLength.value : void 0,
          type: "array",
          inclusive: !0,
          exact: !0,
          message: r.exactLength.message,
        }),
        i.dirty());
    }
    if (
      (r.minLength !== null &&
        n.data.length < r.minLength.value &&
        (ue(n, {
          code: te.too_small,
          minimum: r.minLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: r.minLength.message,
        }),
        i.dirty()),
      r.maxLength !== null &&
        n.data.length > r.maxLength.value &&
        (ue(n, {
          code: te.too_big,
          maximum: r.maxLength.value,
          type: "array",
          inclusive: !0,
          exact: !1,
          message: r.maxLength.message,
        }),
        i.dirty()),
      n.common.async)
    )
      return Promise.all(
        [...n.data].map((a, o) => r.type._parseAsync(new Vi(n, a, n.path, o)))
      ).then((a) => fn.mergeArray(i, a));
    const s = [...n.data].map((a, o) =>
      r.type._parseSync(new Vi(n, a, n.path, o))
    );
    return fn.mergeArray(i, s);
  }
  get element() {
    return this._def.type;
  }
  min(e, n) {
    return new wi({
      ...this._def,
      minLength: {
        value: e,
        message: ye.toString(n),
      },
    });
  }
  max(e, n) {
    return new wi({
      ...this._def,
      maxLength: {
        value: e,
        message: ye.toString(n),
      },
    });
  }
  length(e, n) {
    return new wi({
      ...this._def,
      exactLength: {
        value: e,
        message: ye.toString(n),
      },
    });
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
wi.create = (t, e) =>
  new wi({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: Ce.ZodArray,
    ...Fe(e),
  });
function Ra(t) {
  if (t instanceof Et) {
    const e = {};
    for (const n in t.shape) {
      const i = t.shape[n];
      e[n] = zi.create(Ra(i));
    }
    return new Et({
      ...t._def,
      shape: () => e,
    });
  } else
    return t instanceof wi
      ? new wi({
          ...t._def,
          type: Ra(t.element),
        })
      : t instanceof zi
      ? zi.create(Ra(t.unwrap()))
      : t instanceof ss
      ? ss.create(Ra(t.unwrap()))
      : t instanceof Hi
      ? Hi.create(t.items.map((e) => Ra(e)))
      : t;
}
class Et extends Xe {
  constructor() {
    super(...arguments),
      (this._cached = null),
      (this.nonstrict = this.passthrough),
      (this.augment = this.extend);
  }
  _getCached() {
    if (this._cached !== null) return this._cached;
    const e = this._def.shape(),
      n = rt.objectKeys(e);
    return (this._cached = {
      shape: e,
      keys: n,
    });
  }
  _parse(e) {
    if (this._getType(e) !== me.object) {
      const c = this._getOrReturnCtx(e);
      return (
        ue(c, {
          code: te.invalid_type,
          expected: me.object,
          received: c.parsedType,
        }),
        Le
      );
    }
    const { status: i, ctx: r } = this._processInputParams(e),
      { shape: s, keys: a } = this._getCached(),
      o = [];
    if (
      !(this._def.catchall instanceof mr && this._def.unknownKeys === "strip")
    )
      for (const c in r.data) a.includes(c) || o.push(c);
    const l = [];
    for (const c of a) {
      const u = s[c],
        d = r.data[c];
      l.push({
        key: {
          status: "valid",
          value: c,
        },
        value: u._parse(new Vi(r, d, r.path, c)),
        alwaysSet: c in r.data,
      });
    }
    if (this._def.catchall instanceof mr) {
      const c = this._def.unknownKeys;
      if (c === "passthrough")
        for (const u of o)
          l.push({
            key: {
              status: "valid",
              value: u,
            },
            value: {
              status: "valid",
              value: r.data[u],
            },
          });
      else if (c === "strict")
        o.length > 0 &&
          (ue(r, {
            code: te.unrecognized_keys,
            keys: o,
          }),
          i.dirty());
      else if (c !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      const c = this._def.catchall;
      for (const u of o) {
        const d = r.data[u];
        l.push({
          key: {
            status: "valid",
            value: u,
          },
          value: c._parse(new Vi(r, d, r.path, u)),
          alwaysSet: u in r.data,
        });
      }
    }
    return r.common.async
      ? Promise.resolve()
          .then(async () => {
            const c = [];
            for (const u of l) {
              const d = await u.key,
                h = await u.value;
              c.push({
                key: d,
                value: h,
                alwaysSet: u.alwaysSet,
              });
            }
            return c;
          })
          .then((c) => fn.mergeObjectSync(i, c))
      : fn.mergeObjectSync(i, l);
  }
  get shape() {
    return this._def.shape();
  }
  strict(e) {
    return (
      ye.errToObj,
      new Et({
        ...this._def,
        unknownKeys: "strict",
        ...(e !== void 0
          ? {
              errorMap: (n, i) => {
                var r, s, a, o;
                const l =
                  (a =
                    (s = (r = this._def).errorMap) === null || s === void 0
                      ? void 0
                      : s.call(r, n, i).message) !== null && a !== void 0
                    ? a
                    : i.defaultError;
                return n.code === "unrecognized_keys"
                  ? {
                      message:
                        (o = ye.errToObj(e).message) !== null && o !== void 0
                          ? o
                          : l,
                    }
                  : {
                      message: l,
                    };
              },
            }
          : {}),
      })
    );
  }
  strip() {
    return new Et({
      ...this._def,
      unknownKeys: "strip",
    });
  }
  passthrough() {
    return new Et({
      ...this._def,
      unknownKeys: "passthrough",
    });
  }
  extend(e) {
    return new Et({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...e,
      }),
    });
  }
  merge(e) {
    return new Et({
      unknownKeys: e._def.unknownKeys,
      catchall: e._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...e._def.shape(),
      }),
      typeName: Ce.ZodObject,
    });
  }
  setKey(e, n) {
    return this.augment({
      [e]: n,
    });
  }
  catchall(e) {
    return new Et({
      ...this._def,
      catchall: e,
    });
  }
  pick(e) {
    const n = {};
    return (
      rt.objectKeys(e).forEach((i) => {
        e[i] && this.shape[i] && (n[i] = this.shape[i]);
      }),
      new Et({
        ...this._def,
        shape: () => n,
      })
    );
  }
  omit(e) {
    const n = {};
    return (
      rt.objectKeys(this.shape).forEach((i) => {
        e[i] || (n[i] = this.shape[i]);
      }),
      new Et({
        ...this._def,
        shape: () => n,
      })
    );
  }
  deepPartial() {
    return Ra(this);
  }
  partial(e) {
    const n = {};
    return (
      rt.objectKeys(this.shape).forEach((i) => {
        const r = this.shape[i];
        e && !e[i] ? (n[i] = r) : (n[i] = r.optional());
      }),
      new Et({
        ...this._def,
        shape: () => n,
      })
    );
  }
  required(e) {
    const n = {};
    return (
      rt.objectKeys(this.shape).forEach((i) => {
        if (e && !e[i]) n[i] = this.shape[i];
        else {
          let s = this.shape[i];
          for (; s instanceof zi; ) s = s._def.innerType;
          n[i] = s;
        }
      }),
      new Et({
        ...this._def,
        shape: () => n,
      })
    );
  }
  keyof() {
    return eM(rt.objectKeys(this.shape));
  }
}
Et.create = (t, e) =>
  new Et({
    shape: () => t,
    unknownKeys: "strip",
    catchall: mr.create(),
    typeName: Ce.ZodObject,
    ...Fe(e),
  });
Et.strictCreate = (t, e) =>
  new Et({
    shape: () => t,
    unknownKeys: "strict",
    catchall: mr.create(),
    typeName: Ce.ZodObject,
    ...Fe(e),
  });
Et.lazycreate = (t, e) =>
  new Et({
    shape: t,
    unknownKeys: "strip",
    catchall: mr.create(),
    typeName: Ce.ZodObject,
    ...Fe(e),
  });
class ic extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      i = this._def.options;
    function r(s) {
      for (const o of s) if (o.result.status === "valid") return o.result;
      for (const o of s)
        if (o.result.status === "dirty")
          return n.common.issues.push(...o.ctx.common.issues), o.result;
      const a = s.map((o) => new Hn(o.ctx.common.issues));
      return (
        ue(n, {
          code: te.invalid_union,
          unionErrors: a,
        }),
        Le
      );
    }
    if (n.common.async)
      return Promise.all(
        i.map(async (s) => {
          const a = {
            ...n,
            common: {
              ...n.common,
              issues: [],
            },
            parent: null,
          };
          return {
            result: await s._parseAsync({
              data: n.data,
              path: n.path,
              parent: a,
            }),
            ctx: a,
          };
        })
      ).then(r);
    {
      let s;
      const a = [];
      for (const l of i) {
        const c = {
            ...n,
            common: {
              ...n.common,
              issues: [],
            },
            parent: null,
          },
          u = l._parseSync({
            data: n.data,
            path: n.path,
            parent: c,
          });
        if (u.status === "valid") return u;
        u.status === "dirty" &&
          !s &&
          (s = {
            result: u,
            ctx: c,
          }),
          c.common.issues.length && a.push(c.common.issues);
      }
      if (s) return n.common.issues.push(...s.ctx.common.issues), s.result;
      const o = a.map((l) => new Hn(l));
      return (
        ue(n, {
          code: te.invalid_union,
          unionErrors: o,
        }),
        Le
      );
    }
  }
  get options() {
    return this._def.options;
  }
}
ic.create = (t, e) =>
  new ic({
    options: t,
    typeName: Ce.ZodUnion,
    ...Fe(e),
  });
const Zi = (t) =>
  t instanceof ac
    ? Zi(t.schema)
    : t instanceof bi
    ? Zi(t.innerType())
    : t instanceof oc
    ? [t.value]
    : t instanceof rs
    ? t.options
    : t instanceof lc
    ? rt.objectValues(t.enum)
    : t instanceof cc
    ? Zi(t._def.innerType)
    : t instanceof tc
    ? [void 0]
    : t instanceof nc
    ? [null]
    : t instanceof zi
    ? [void 0, ...Zi(t.unwrap())]
    : t instanceof ss
    ? [null, ...Zi(t.unwrap())]
    : t instanceof Av || t instanceof dc
    ? Zi(t.unwrap())
    : t instanceof uc
    ? Zi(t._def.innerType)
    : [];
class Sh extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== me.object)
      return (
        ue(n, {
          code: te.invalid_type,
          expected: me.object,
          received: n.parsedType,
        }),
        Le
      );
    const i = this.discriminator,
      r = n.data[i],
      s = this.optionsMap.get(r);
    return s
      ? n.common.async
        ? s._parseAsync({
            data: n.data,
            path: n.path,
            parent: n,
          })
        : s._parseSync({
            data: n.data,
            path: n.path,
            parent: n,
          })
      : (ue(n, {
          code: te.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [i],
        }),
        Le);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(e, n, i) {
    const r = new Map();
    for (const s of n) {
      const a = Zi(s.shape[e]);
      if (!a.length)
        throw new Error(
          `A discriminator value for key \`${e}\` could not be extracted from all schema options`
        );
      for (const o of a) {
        if (r.has(o))
          throw new Error(
            `Discriminator property ${String(e)} has duplicate value ${String(
              o
            )}`
          );
        r.set(o, s);
      }
    }
    return new Sh({
      typeName: Ce.ZodDiscriminatedUnion,
      discriminator: e,
      options: n,
      optionsMap: r,
      ...Fe(i),
    });
  }
}
function Lm(t, e) {
  const n = tr(t),
    i = tr(e);
  if (t === e)
    return {
      valid: !0,
      data: t,
    };
  if (n === me.object && i === me.object) {
    const r = rt.objectKeys(e),
      s = rt.objectKeys(t).filter((o) => r.indexOf(o) !== -1),
      a = {
        ...t,
        ...e,
      };
    for (const o of s) {
      const l = Lm(t[o], e[o]);
      if (!l.valid)
        return {
          valid: !1,
        };
      a[o] = l.data;
    }
    return {
      valid: !0,
      data: a,
    };
  } else if (n === me.array && i === me.array) {
    if (t.length !== e.length)
      return {
        valid: !1,
      };
    const r = [];
    for (let s = 0; s < t.length; s++) {
      const a = t[s],
        o = e[s],
        l = Lm(a, o);
      if (!l.valid)
        return {
          valid: !1,
        };
      r.push(l.data);
    }
    return {
      valid: !0,
      data: r,
    };
  } else
    return n === me.date && i === me.date && +t == +e
      ? {
          valid: !0,
          data: t,
        }
      : {
          valid: !1,
        };
}
class rc extends Xe {
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e),
      r = (s, a) => {
        if (Rm(s) || Rm(a)) return Le;
        const o = Lm(s.value, a.value);
        return o.valid
          ? ((Pm(s) || Pm(a)) && n.dirty(),
            {
              status: n.value,
              value: o.data,
            })
          : (ue(i, {
              code: te.invalid_intersection_types,
            }),
            Le);
      };
    return i.common.async
      ? Promise.all([
          this._def.left._parseAsync({
            data: i.data,
            path: i.path,
            parent: i,
          }),
          this._def.right._parseAsync({
            data: i.data,
            path: i.path,
            parent: i,
          }),
        ]).then(([s, a]) => r(s, a))
      : r(
          this._def.left._parseSync({
            data: i.data,
            path: i.path,
            parent: i,
          }),
          this._def.right._parseSync({
            data: i.data,
            path: i.path,
            parent: i,
          })
        );
  }
}
rc.create = (t, e, n) =>
  new rc({
    left: t,
    right: e,
    typeName: Ce.ZodIntersection,
    ...Fe(n),
  });
class Hi extends Xe {
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== me.array)
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.array,
          received: i.parsedType,
        }),
        Le
      );
    if (i.data.length < this._def.items.length)
      return (
        ue(i, {
          code: te.too_small,
          minimum: this._def.items.length,
          inclusive: !0,
          exact: !1,
          type: "array",
        }),
        Le
      );
    !this._def.rest &&
      i.data.length > this._def.items.length &&
      (ue(i, {
        code: te.too_big,
        maximum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array",
      }),
      n.dirty());
    const s = [...i.data]
      .map((a, o) => {
        const l = this._def.items[o] || this._def.rest;
        return l ? l._parse(new Vi(i, a, i.path, o)) : null;
      })
      .filter((a) => !!a);
    return i.common.async
      ? Promise.all(s).then((a) => fn.mergeArray(n, a))
      : fn.mergeArray(n, s);
  }
  get items() {
    return this._def.items;
  }
  rest(e) {
    return new Hi({
      ...this._def,
      rest: e,
    });
  }
}
Hi.create = (t, e) => {
  if (!Array.isArray(t))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new Hi({
    items: t,
    typeName: Ce.ZodTuple,
    rest: null,
    ...Fe(e),
  });
};
class sc extends Xe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== me.object)
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.object,
          received: i.parsedType,
        }),
        Le
      );
    const r = [],
      s = this._def.keyType,
      a = this._def.valueType;
    for (const o in i.data)
      r.push({
        key: s._parse(new Vi(i, o, i.path, o)),
        value: a._parse(new Vi(i, i.data[o], i.path, o)),
        alwaysSet: o in i.data,
      });
    return i.common.async
      ? fn.mergeObjectAsync(n, r)
      : fn.mergeObjectSync(n, r);
  }
  get element() {
    return this._def.valueType;
  }
  static create(e, n, i) {
    return n instanceof Xe
      ? new sc({
          keyType: e,
          valueType: n,
          typeName: Ce.ZodRecord,
          ...Fe(i),
        })
      : new sc({
          keyType: yi.create(),
          valueType: e,
          typeName: Ce.ZodRecord,
          ...Fe(n),
        });
  }
}
class Id extends Xe {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== me.map)
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.map,
          received: i.parsedType,
        }),
        Le
      );
    const r = this._def.keyType,
      s = this._def.valueType,
      a = [...i.data.entries()].map(([o, l], c) => ({
        key: r._parse(new Vi(i, o, i.path, [c, "key"])),
        value: s._parse(new Vi(i, l, i.path, [c, "value"])),
      }));
    if (i.common.async) {
      const o = new Map();
      return Promise.resolve().then(async () => {
        for (const l of a) {
          const c = await l.key,
            u = await l.value;
          if (c.status === "aborted" || u.status === "aborted") return Le;
          (c.status === "dirty" || u.status === "dirty") && n.dirty(),
            o.set(c.value, u.value);
        }
        return {
          status: n.value,
          value: o,
        };
      });
    } else {
      const o = new Map();
      for (const l of a) {
        const c = l.key,
          u = l.value;
        if (c.status === "aborted" || u.status === "aborted") return Le;
        (c.status === "dirty" || u.status === "dirty") && n.dirty(),
          o.set(c.value, u.value);
      }
      return {
        status: n.value,
        value: o,
      };
    }
  }
}
Id.create = (t, e, n) =>
  new Id({
    valueType: e,
    keyType: t,
    typeName: Ce.ZodMap,
    ...Fe(n),
  });
class ea extends Xe {
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e);
    if (i.parsedType !== me.set)
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.set,
          received: i.parsedType,
        }),
        Le
      );
    const r = this._def;
    r.minSize !== null &&
      i.data.size < r.minSize.value &&
      (ue(i, {
        code: te.too_small,
        minimum: r.minSize.value,
        type: "set",
        inclusive: !0,
        exact: !1,
        message: r.minSize.message,
      }),
      n.dirty()),
      r.maxSize !== null &&
        i.data.size > r.maxSize.value &&
        (ue(i, {
          code: te.too_big,
          maximum: r.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: r.maxSize.message,
        }),
        n.dirty());
    const s = this._def.valueType;
    function a(l) {
      const c = new Set();
      for (const u of l) {
        if (u.status === "aborted") return Le;
        u.status === "dirty" && n.dirty(), c.add(u.value);
      }
      return {
        status: n.value,
        value: c,
      };
    }
    const o = [...i.data.values()].map((l, c) =>
      s._parse(new Vi(i, l, i.path, c))
    );
    return i.common.async ? Promise.all(o).then((l) => a(l)) : a(o);
  }
  min(e, n) {
    return new ea({
      ...this._def,
      minSize: {
        value: e,
        message: ye.toString(n),
      },
    });
  }
  max(e, n) {
    return new ea({
      ...this._def,
      maxSize: {
        value: e,
        message: ye.toString(n),
      },
    });
  }
  size(e, n) {
    return this.min(e, n).max(e, n);
  }
  nonempty(e) {
    return this.min(1, e);
  }
}
ea.create = (t, e) =>
  new ea({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: Ce.ZodSet,
    ...Fe(e),
  });
class io extends Xe {
  constructor() {
    super(...arguments), (this.validate = this.implement);
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== me.function)
      return (
        ue(n, {
          code: te.invalid_type,
          expected: me.function,
          received: n.parsedType,
        }),
        Le
      );
    function i(o, l) {
      return Ld({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Pd(),
          _o,
        ].filter((c) => !!c),
        issueData: {
          code: te.invalid_arguments,
          argumentsError: l,
        },
      });
    }
    function r(o, l) {
      return Ld({
        data: o,
        path: n.path,
        errorMaps: [
          n.common.contextualErrorMap,
          n.schemaErrorMap,
          Pd(),
          _o,
        ].filter((c) => !!c),
        issueData: {
          code: te.invalid_return_type,
          returnTypeError: l,
        },
      });
    }
    const s = {
        errorMap: n.common.contextualErrorMap,
      },
      a = n.data;
    if (this._def.returns instanceof xo) {
      const o = this;
      return xn(async function (...l) {
        const c = new Hn([]),
          u = await o._def.args.parseAsync(l, s).catch((p) => {
            throw (c.addIssue(i(l, p)), c);
          }),
          d = await Reflect.apply(a, this, u);
        return await o._def.returns._def.type.parseAsync(d, s).catch((p) => {
          throw (c.addIssue(r(d, p)), c);
        });
      });
    } else {
      const o = this;
      return xn(function (...l) {
        const c = o._def.args.safeParse(l, s);
        if (!c.success) throw new Hn([i(l, c.error)]);
        const u = Reflect.apply(a, this, c.data),
          d = o._def.returns.safeParse(u, s);
        if (!d.success) throw new Hn([r(u, d.error)]);
        return d.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...e) {
    return new io({
      ...this._def,
      args: Hi.create(e).rest(Vs.create()),
    });
  }
  returns(e) {
    return new io({
      ...this._def,
      returns: e,
    });
  }
  implement(e) {
    return this.parse(e);
  }
  strictImplement(e) {
    return this.parse(e);
  }
  static create(e, n, i) {
    return new io({
      args: e || Hi.create([]).rest(Vs.create()),
      returns: n || Vs.create(),
      typeName: Ce.ZodFunction,
      ...Fe(i),
    });
  }
}
class ac extends Xe {
  get schema() {
    return this._def.getter();
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    return this._def.getter()._parse({
      data: n.data,
      path: n.path,
      parent: n,
    });
  }
}
ac.create = (t, e) =>
  new ac({
    getter: t,
    typeName: Ce.ZodLazy,
    ...Fe(e),
  });
class oc extends Xe {
  _parse(e) {
    if (e.data !== this._def.value) {
      const n = this._getOrReturnCtx(e);
      return (
        ue(n, {
          received: n.data,
          code: te.invalid_literal,
          expected: this._def.value,
        }),
        Le
      );
    }
    return {
      status: "valid",
      value: e.data,
    };
  }
  get value() {
    return this._def.value;
  }
}
oc.create = (t, e) =>
  new oc({
    value: t,
    typeName: Ce.ZodLiteral,
    ...Fe(e),
  });
function eM(t, e) {
  return new rs({
    values: t,
    typeName: Ce.ZodEnum,
    ...Fe(e),
  });
}
class rs extends Xe {
  constructor() {
    super(...arguments), cl.set(this, void 0);
  }
  _parse(e) {
    if (typeof e.data != "string") {
      const n = this._getOrReturnCtx(e),
        i = this._def.values;
      return (
        ue(n, {
          expected: rt.joinValues(i),
          received: n.parsedType,
          code: te.invalid_type,
        }),
        Le
      );
    }
    if (
      (Nd(this, cl) || ZT(this, cl, new Set(this._def.values)),
      !Nd(this, cl).has(e.data))
    ) {
      const n = this._getOrReturnCtx(e),
        i = this._def.values;
      return (
        ue(n, {
          received: n.data,
          code: te.invalid_enum_value,
          options: i,
        }),
        Le
      );
    }
    return xn(e.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  get Values() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  get Enum() {
    const e = {};
    for (const n of this._def.values) e[n] = n;
    return e;
  }
  extract(e, n = this._def) {
    return rs.create(e, {
      ...this._def,
      ...n,
    });
  }
  exclude(e, n = this._def) {
    return rs.create(
      this.options.filter((i) => !e.includes(i)),
      {
        ...this._def,
        ...n,
      }
    );
  }
}
cl = new WeakMap();
rs.create = eM;
class lc extends Xe {
  constructor() {
    super(...arguments), ul.set(this, void 0);
  }
  _parse(e) {
    const n = rt.getValidEnumValues(this._def.values),
      i = this._getOrReturnCtx(e);
    if (i.parsedType !== me.string && i.parsedType !== me.number) {
      const r = rt.objectValues(n);
      return (
        ue(i, {
          expected: rt.joinValues(r),
          received: i.parsedType,
          code: te.invalid_type,
        }),
        Le
      );
    }
    if (
      (Nd(this, ul) ||
        ZT(this, ul, new Set(rt.getValidEnumValues(this._def.values))),
      !Nd(this, ul).has(e.data))
    ) {
      const r = rt.objectValues(n);
      return (
        ue(i, {
          received: i.data,
          code: te.invalid_enum_value,
          options: r,
        }),
        Le
      );
    }
    return xn(e.data);
  }
  get enum() {
    return this._def.values;
  }
}
ul = new WeakMap();
lc.create = (t, e) =>
  new lc({
    values: t,
    typeName: Ce.ZodNativeEnum,
    ...Fe(e),
  });
class xo extends Xe {
  unwrap() {
    return this._def.type;
  }
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    if (n.parsedType !== me.promise && n.common.async === !1)
      return (
        ue(n, {
          code: te.invalid_type,
          expected: me.promise,
          received: n.parsedType,
        }),
        Le
      );
    const i = n.parsedType === me.promise ? n.data : Promise.resolve(n.data);
    return xn(
      i.then((r) =>
        this._def.type.parseAsync(r, {
          path: n.path,
          errorMap: n.common.contextualErrorMap,
        })
      )
    );
  }
}
xo.create = (t, e) =>
  new xo({
    type: t,
    typeName: Ce.ZodPromise,
    ...Fe(e),
  });
class bi extends Xe {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === Ce.ZodEffects
      ? this._def.schema.sourceType()
      : this._def.schema;
  }
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e),
      r = this._def.effect || null,
      s = {
        addIssue: (a) => {
          ue(i, a), a.fatal ? n.abort() : n.dirty();
        },
        get path() {
          return i.path;
        },
      };
    if (((s.addIssue = s.addIssue.bind(s)), r.type === "preprocess")) {
      const a = r.transform(i.data, s);
      if (i.common.async)
        return Promise.resolve(a).then(async (o) => {
          if (n.value === "aborted") return Le;
          const l = await this._def.schema._parseAsync({
            data: o,
            path: i.path,
            parent: i,
          });
          return l.status === "aborted"
            ? Le
            : l.status === "dirty" || n.value === "dirty"
            ? Xa(l.value)
            : l;
        });
      {
        if (n.value === "aborted") return Le;
        const o = this._def.schema._parseSync({
          data: a,
          path: i.path,
          parent: i,
        });
        return o.status === "aborted"
          ? Le
          : o.status === "dirty" || n.value === "dirty"
          ? Xa(o.value)
          : o;
      }
    }
    if (r.type === "refinement") {
      const a = (o) => {
        const l = r.refinement(o, s);
        if (i.common.async) return Promise.resolve(l);
        if (l instanceof Promise)
          throw new Error(
            "Async refinement encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return o;
      };
      if (i.common.async === !1) {
        const o = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i,
        });
        return o.status === "aborted"
          ? Le
          : (o.status === "dirty" && n.dirty(),
            a(o.value),
            {
              status: n.value,
              value: o.value,
            });
      } else
        return this._def.schema
          ._parseAsync({
            data: i.data,
            path: i.path,
            parent: i,
          })
          .then((o) =>
            o.status === "aborted"
              ? Le
              : (o.status === "dirty" && n.dirty(),
                a(o.value).then(() => ({
                  status: n.value,
                  value: o.value,
                })))
          );
    }
    if (r.type === "transform")
      if (i.common.async === !1) {
        const a = this._def.schema._parseSync({
          data: i.data,
          path: i.path,
          parent: i,
        });
        if (!Js(a)) return a;
        const o = r.transform(a.value, s);
        if (o instanceof Promise)
          throw new Error(
            "Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."
          );
        return {
          status: n.value,
          value: o,
        };
      } else
        return this._def.schema
          ._parseAsync({
            data: i.data,
            path: i.path,
            parent: i,
          })
          .then((a) =>
            Js(a)
              ? Promise.resolve(r.transform(a.value, s)).then((o) => ({
                  status: n.value,
                  value: o,
                }))
              : a
          );
    rt.assertNever(r);
  }
}
bi.create = (t, e, n) =>
  new bi({
    schema: t,
    typeName: Ce.ZodEffects,
    effect: e,
    ...Fe(n),
  });
bi.createWithPreprocess = (t, e, n) =>
  new bi({
    schema: e,
    effect: {
      type: "preprocess",
      transform: t,
    },
    typeName: Ce.ZodEffects,
    ...Fe(n),
  });
class zi extends Xe {
  _parse(e) {
    return this._getType(e) === me.undefined
      ? xn(void 0)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
zi.create = (t, e) =>
  new zi({
    innerType: t,
    typeName: Ce.ZodOptional,
    ...Fe(e),
  });
class ss extends Xe {
  _parse(e) {
    return this._getType(e) === me.null
      ? xn(null)
      : this._def.innerType._parse(e);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ss.create = (t, e) =>
  new ss({
    innerType: t,
    typeName: Ce.ZodNullable,
    ...Fe(e),
  });
class cc extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e);
    let i = n.data;
    return (
      n.parsedType === me.undefined && (i = this._def.defaultValue()),
      this._def.innerType._parse({
        data: i,
        path: n.path,
        parent: n,
      })
    );
  }
  removeDefault() {
    return this._def.innerType;
  }
}
cc.create = (t, e) =>
  new cc({
    innerType: t,
    typeName: Ce.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...Fe(e),
  });
class uc extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      i = {
        ...n,
        common: {
          ...n.common,
          issues: [],
        },
      },
      r = this._def.innerType._parse({
        data: i.data,
        path: i.path,
        parent: {
          ...i,
        },
      });
    return Ql(r)
      ? r.then((s) => ({
          status: "valid",
          value:
            s.status === "valid"
              ? s.value
              : this._def.catchValue({
                  get error() {
                    return new Hn(i.common.issues);
                  },
                  input: i.data,
                }),
        }))
      : {
          status: "valid",
          value:
            r.status === "valid"
              ? r.value
              : this._def.catchValue({
                  get error() {
                    return new Hn(i.common.issues);
                  },
                  input: i.data,
                }),
        };
  }
  removeCatch() {
    return this._def.innerType;
  }
}
uc.create = (t, e) =>
  new uc({
    innerType: t,
    typeName: Ce.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...Fe(e),
  });
class Ud extends Xe {
  _parse(e) {
    if (this._getType(e) !== me.nan) {
      const i = this._getOrReturnCtx(e);
      return (
        ue(i, {
          code: te.invalid_type,
          expected: me.nan,
          received: i.parsedType,
        }),
        Le
      );
    }
    return {
      status: "valid",
      value: e.data,
    };
  }
}
Ud.create = (t) =>
  new Ud({
    typeName: Ce.ZodNaN,
    ...Fe(t),
  });
const I3 = Symbol("zod_brand");
class Av extends Xe {
  _parse(e) {
    const { ctx: n } = this._processInputParams(e),
      i = n.data;
    return this._def.type._parse({
      data: i,
      path: n.path,
      parent: n,
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class bc extends Xe {
  _parse(e) {
    const { status: n, ctx: i } = this._processInputParams(e);
    if (i.common.async)
      return (async () => {
        const s = await this._def.in._parseAsync({
          data: i.data,
          path: i.path,
          parent: i,
        });
        return s.status === "aborted"
          ? Le
          : s.status === "dirty"
          ? (n.dirty(), Xa(s.value))
          : this._def.out._parseAsync({
              data: s.value,
              path: i.path,
              parent: i,
            });
      })();
    {
      const r = this._def.in._parseSync({
        data: i.data,
        path: i.path,
        parent: i,
      });
      return r.status === "aborted"
        ? Le
        : r.status === "dirty"
        ? (n.dirty(),
          {
            status: "dirty",
            value: r.value,
          })
        : this._def.out._parseSync({
            data: r.value,
            path: i.path,
            parent: i,
          });
    }
  }
  static create(e, n) {
    return new bc({
      in: e,
      out: n,
      typeName: Ce.ZodPipeline,
    });
  }
}
class dc extends Xe {
  _parse(e) {
    const n = this._def.innerType._parse(e),
      i = (r) => (Js(r) && (r.value = Object.freeze(r.value)), r);
    return Ql(n) ? n.then((r) => i(r)) : i(n);
  }
  unwrap() {
    return this._def.innerType;
  }
}
dc.create = (t, e) =>
  new dc({
    innerType: t,
    typeName: Ce.ZodReadonly,
    ...Fe(e),
  });
function Gy(t, e) {
  const n =
    typeof t == "function"
      ? t(e)
      : typeof t == "string"
      ? {
          message: t,
        }
      : t;
  return typeof n == "string"
    ? {
        message: n,
      }
    : n;
}
function tM(t, e = {}, n) {
  return t
    ? yo.create().superRefine((i, r) => {
        var s, a;
        const o = t(i);
        if (o instanceof Promise)
          return o.then((l) => {
            var c, u;
            if (!l) {
              const d = Gy(e, i),
                h =
                  (u = (c = d.fatal) !== null && c !== void 0 ? c : n) !==
                    null && u !== void 0
                    ? u
                    : !0;
              r.addIssue({
                code: "custom",
                ...d,
                fatal: h,
              });
            }
          });
        if (!o) {
          const l = Gy(e, i),
            c =
              (a = (s = l.fatal) !== null && s !== void 0 ? s : n) !== null &&
              a !== void 0
                ? a
                : !0;
          r.addIssue({
            code: "custom",
            ...l,
            fatal: c,
          });
        }
      })
    : yo.create();
}
const U3 = {
  object: Et.lazycreate,
};
var Ce;
(function (t) {
  (t.ZodString = "ZodString"),
    (t.ZodNumber = "ZodNumber"),
    (t.ZodNaN = "ZodNaN"),
    (t.ZodBigInt = "ZodBigInt"),
    (t.ZodBoolean = "ZodBoolean"),
    (t.ZodDate = "ZodDate"),
    (t.ZodSymbol = "ZodSymbol"),
    (t.ZodUndefined = "ZodUndefined"),
    (t.ZodNull = "ZodNull"),
    (t.ZodAny = "ZodAny"),
    (t.ZodUnknown = "ZodUnknown"),
    (t.ZodNever = "ZodNever"),
    (t.ZodVoid = "ZodVoid"),
    (t.ZodArray = "ZodArray"),
    (t.ZodObject = "ZodObject"),
    (t.ZodUnion = "ZodUnion"),
    (t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion"),
    (t.ZodIntersection = "ZodIntersection"),
    (t.ZodTuple = "ZodTuple"),
    (t.ZodRecord = "ZodRecord"),
    (t.ZodMap = "ZodMap"),
    (t.ZodSet = "ZodSet"),
    (t.ZodFunction = "ZodFunction"),
    (t.ZodLazy = "ZodLazy"),
    (t.ZodLiteral = "ZodLiteral"),
    (t.ZodEnum = "ZodEnum"),
    (t.ZodEffects = "ZodEffects"),
    (t.ZodNativeEnum = "ZodNativeEnum"),
    (t.ZodOptional = "ZodOptional"),
    (t.ZodNullable = "ZodNullable"),
    (t.ZodDefault = "ZodDefault"),
    (t.ZodCatch = "ZodCatch"),
    (t.ZodPromise = "ZodPromise"),
    (t.ZodBranded = "ZodBranded"),
    (t.ZodPipeline = "ZodPipeline"),
    (t.ZodReadonly = "ZodReadonly");
})(Ce || (Ce = {}));
const O3 = (
    t,
    e = {
      message: `Input not instance of ${t.name}`,
    }
  ) => tM((n) => n instanceof t, e),
  nM = yi.create,
  iM = ns.create,
  F3 = Ud.create,
  B3 = is.create,
  rM = ec.create,
  z3 = Qs.create,
  j3 = Dd.create,
  V3 = tc.create,
  H3 = nc.create,
  G3 = yo.create,
  W3 = Vs.create,
  $3 = mr.create,
  X3 = kd.create,
  q3 = wi.create,
  Y3 = Et.create,
  Z3 = Et.strictCreate,
  K3 = ic.create,
  J3 = Sh.create,
  Q3 = rc.create,
  eU = Hi.create,
  tU = sc.create,
  nU = Id.create,
  iU = ea.create,
  rU = io.create,
  sU = ac.create,
  aU = oc.create,
  oU = rs.create,
  lU = lc.create,
  cU = xo.create,
  Wy = bi.create,
  uU = zi.create,
  dU = ss.create,
  hU = bi.createWithPreprocess,
  fU = bc.create,
  pU = () => nM().optional(),
  mU = () => iM().optional(),
  gU = () => rM().optional(),
  vU = {
    string: (t) =>
      yi.create({
        ...t,
        coerce: !0,
      }),
    number: (t) =>
      ns.create({
        ...t,
        coerce: !0,
      }),
    boolean: (t) =>
      ec.create({
        ...t,
        coerce: !0,
      }),
    bigint: (t) =>
      is.create({
        ...t,
        coerce: !0,
      }),
    date: (t) =>
      Qs.create({
        ...t,
        coerce: !0,
      }),
  },
  _U = Le;
var ln = Object.freeze({
  __proto__: null,
  defaultErrorMap: _o,
  setErrorMap: h3,
  getErrorMap: Pd,
  makeIssue: Ld,
  EMPTY_PATH: f3,
  addIssueToContext: ue,
  ParseStatus: fn,
  INVALID: Le,
  DIRTY: Xa,
  OK: xn,
  isAborted: Rm,
  isDirty: Pm,
  isValid: Js,
  isAsync: Ql,
  get util() {
    return rt;
  },
  get objectUtil() {
    return Cm;
  },
  ZodParsedType: me,
  getParsedType: tr,
  ZodType: Xe,
  datetimeRegex: QT,
  ZodString: yi,
  ZodNumber: ns,
  ZodBigInt: is,
  ZodBoolean: ec,
  ZodDate: Qs,
  ZodSymbol: Dd,
  ZodUndefined: tc,
  ZodNull: nc,
  ZodAny: yo,
  ZodUnknown: Vs,
  ZodNever: mr,
  ZodVoid: kd,
  ZodArray: wi,
  ZodObject: Et,
  ZodUnion: ic,
  ZodDiscriminatedUnion: Sh,
  ZodIntersection: rc,
  ZodTuple: Hi,
  ZodRecord: sc,
  ZodMap: Id,
  ZodSet: ea,
  ZodFunction: io,
  ZodLazy: ac,
  ZodLiteral: oc,
  ZodEnum: rs,
  ZodNativeEnum: lc,
  ZodPromise: xo,
  ZodEffects: bi,
  ZodTransformer: bi,
  ZodOptional: zi,
  ZodNullable: ss,
  ZodDefault: cc,
  ZodCatch: uc,
  ZodNaN: Ud,
  BRAND: I3,
  ZodBranded: Av,
  ZodPipeline: bc,
  ZodReadonly: dc,
  custom: tM,
  Schema: Xe,
  ZodSchema: Xe,
  late: U3,
  get ZodFirstPartyTypeKind() {
    return Ce;
  },
  coerce: vU,
  any: G3,
  array: q3,
  bigint: B3,
  boolean: rM,
  date: z3,
  discriminatedUnion: J3,
  effect: Wy,
  enum: oU,
  function: rU,
  instanceof: O3,
  intersection: Q3,
  lazy: sU,
  literal: aU,
  map: nU,
  nan: F3,
  nativeEnum: lU,
  never: $3,
  null: H3,
  nullable: dU,
  number: iM,
  object: Y3,
  oboolean: gU,
  onumber: mU,
  optional: uU,
  ostring: pU,
  pipeline: fU,
  preprocess: hU,
  promise: cU,
  record: tU,
  set: iU,
  strictObject: Z3,
  string: nM,
  symbol: j3,
  transformer: Wy,
  tuple: eU,
  undefined: V3,
  union: K3,
  unknown: W3,
  void: X3,
  NEVER: _U,
  ZodIssueCode: te,
  quotelessJson: d3,
  ZodError: Hn,
});
ln.object({
  gender: ln.enum(["masculino", "femenino"], {
    errorMap: () => ({
      message: "Gnero invlido",
    }),
  }),
  size: ln.enum(["XS", "S", "M", "L", "XL", "XXL"], {
    errorMap: () => ({
      message: "Talla invlida",
    }),
  }),
});
const $y = ln.object({
    player1Name: ln.string().min(1, "Nombre del jugador 1 es requerido"),
    player2Name: ln.string().min(1, "Nombre del jugador 2 es requerido"),
    email: ln.string().email("Email invlido"),
    player1Age: ln.string().transform((t) => parseInt(t, 10)),
    player2Age: ln.string().transform((t) => parseInt(t, 10)),
    captainWhatsapp: ln.string().min(1, "WhatsApp del capitn es requerido"),
    teamName: ln.string().optional(),
    category: ln.enum(
      [
        "2da-hombres",
        "3ra-hombres",
        "4ta-hombres",
        "5ta-hombres",
        "a-mujeres",
        "b-mujeres",
      ],
      {
        errorMap: () => ({
          message: "Categora invlida",
        }),
      }
    ),
    player1Gender: ln.enum(["masculino", "femenino"], {
      errorMap: () => ({
        message: "Gnero del jugador 1 es requerido",
      }),
    }),
    player1ShirtSize: ln.enum(["XS", "S", "M", "L", "XL", "XXL"], {
      errorMap: () => ({
        message: "Talla del jugador 1 es requerida",
      }),
    }),
    player2Gender: ln.enum(["masculino", "femenino"], {
      errorMap: () => ({
        message: "Gnero del jugador 2 es requerido",
      }),
    }),
    player2ShirtSize: ln.enum(["XS", "S", "M", "L", "XL", "XXL"], {
      errorMap: () => ({
        message: "Talla del jugador 2 es requerida",
      }),
    }),
  }),
  yU = () => {
    const [t, e] = O.useState({
        player1Name: "",
        player2Name: "",
        email: "",
        player1Age: "",
        player2Age: "",
        captainWhatsapp: "",
        teamName: "",
        category: "",
        player1Gender: "",
        player1ShirtSize: "",
        player2Gender: "",
        player2ShirtSize: "",
      }),
      [n, i] = O.useState(!1),
      [r, s] = O.useState(!1),
      [a, o] = O.useState(!1),
      [l, c] = O.useState(null),
      [u, d] = O.useState(!1),
      h = (f) => {
        const { name: y, value: g } = f.target;
        e((S) => ({
          ...S,
          [y]: g,
        })),
          c(null);
      },
      p = (f) => {
        f.preventDefault(), c(null);
        try {
          $y.parse(t), s(!0);
        } catch (y) {
          y instanceof Error &&
            (console.error("Validation error:", y), c(y.message));
        }
      },
      v = async () => {
        if (!(!a || u)) {
          c(null), d(!0);
          try {
            const f = $y.parse(t),
              y = `${f.player1Gender === "masculino" ? "Masc" : "Fem"}-${
                f.player1ShirtSize
              }`,
              g = `${f.player2Gender === "masculino" ? "Masc" : "Fem"}-${
                f.player2ShirtSize
              }`,
              { data: S, error: T } = await u3.functions.invoke(
                "sync-registration",
                {
                  body: {
                    player1_name: f.player1Name,
                    player2_name: f.player2Name,
                    email: f.email,
                    player1_age: f.player1Age,
                    player2_age: f.player2Age,
                    captain_whatsapp: f.captainWhatsapp,
                    team_name: f.teamName || null,
                    category: f.category,
                    status: "pending",
                    player1_shirt_size: y,
                    player2_shirt_size: g,
                  },
                }
              );
            if (T)
              throw (
                (console.error("Edge Function error:", T),
                new Error(T.message || "Error al procesar la inscripcin"))
              );
            if (S != null && S.error) {
              if ((console.error("Registration error:", S.error), S.details)) {
                const A = S.details.map((b) => b.message).join(", ");
                throw new Error(A);
              }
              throw new Error(S.error);
            }
            s(!1), i(!0);
          } catch (f) {
            console.error("Final submission error:", f),
              c(
                f instanceof Error
                  ? f.message
                  : "Error al procesar la inscripcin"
              );
          } finally {
            d(!1);
          }
        }
      },
      x = [
        {
          value: "2da-hombres",
          label: "2da Hombres",
        },
        {
          value: "3ra-hombres",
          label: "3ra Hombres",
        },
        {
          value: "4ta-hombres",
          label: "4ta Hombres",
        },
        {
          value: "5ta-hombres",
          label: "5ta Hombres",
        },
        {
          value: "a-mujeres",
          label: "A Mujeres",
        },
        {
          value: "b-mujeres",
          label: "B Mujeres",
        },
      ],
      m = ["XS", "S", "M", "L", "XL", "XXL"];
    return _.jsxs("section", {
      id: "register",
      className: "section relative overflow-hidden py-24 bg-medianoche",
      children: [
        _.jsx("div", {
          className: "absolute inset-0 bg-no-repeat opacity-85",
          style: {
            backgroundImage: 'url("https://imgur.com/c7QH0c9.jpg")',
            backgroundSize: "contain",
            backgroundPosition: "center",
            filter: "brightness(0.85)",
          },
        }),
        _.jsxs("div", {
          className: "container relative z-10 max-w-6xl mx-auto px-6",
          children: [
            _.jsx("h2", {
              className: "section-title text-marfil mb-8",
              children: "Inscrbete Ahora",
            }),
            _.jsx("p", {
              className: "subtitle text-marfil/90 max-w-3xl mx-auto mb-16",
              children:
                "Asegura tu lugar en el torneo y preprate para una experiencia inolvidable de padel",
            }),
            _.jsxs("div", {
              className: "grid grid-cols-1 md:grid-cols-3 gap-6 mb-12",
              children: [
                _.jsxs(Me.div, {
                  className:
                    "bg-verde/30 backdrop-blur-sm p-6 rounded-xl border border-verde/40 shadow-xl relative overflow-hidden",
                  whileHover: {
                    scale: 1.02,
                  },
                  transition: {
                    duration: 0.2,
                  },
                  children: [
                    _.jsx("div", {
                      className:
                        "absolute top-0 right-0 bg-verde text-marfil px-3 py-1 text-sm",
                      children: "Early Access",
                    }),
                    _.jsxs("div", {
                      className: "flex items-start gap-4",
                      children: [
                        _.jsx(PR, {
                          className: "text-marfil flex-shrink-0",
                          size: 24,
                        }),
                        _.jsxs("div", {
                          children: [
                            _.jsx("div", {
                              className:
                                "text-xl font-semibold mb-2 text-marfil",
                              children: "De Suma 5",
                            }),
                            _.jsx("div", {
                              className: "text-3xl font-bold text-marfil mb-2",
                              children: "$900 MXN",
                            }),
                            _.jsx("div", {
                              className: "text-sm text-marfil/80",
                              children: "5, 6 y 7 de Diciembre",
                            }),
                            // _.jsx("p", {
                            //   className: "mt-2 text-marfil/90 text-sm",
                            //   children:
                            //     "Precio preferencial. Acceso exclusivo para quienes se inscriben primero.",
                            // }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                _.jsxs(Me.div, {
                  className:
                    "bg-verde/30 backdrop-blur-sm p-6 rounded-xl border border-verde/40 shadow-xl relative overflow-hidden",
                  whileHover: {
                    scale: 1.02,
                  },
                  transition: {
                    duration: 0.2,
                  },
                  children: [
                    _.jsx("div", {
                      className:
                        "absolute top-0 right-0 bg-verde text-marfil px-3 py-1 text-sm",
                      children: "Early Access",
                    }),
                    _.jsxs("div", {
                      className: "flex items-start gap-4",
                      children: [
                        _.jsx(PR, {
                          className: "text-marfil flex-shrink-0",
                          size: 24,
                        }),
                        _.jsxs("div", {
                          children: [
                            _.jsx("div", {
                              className:
                                "text-xl font-semibold mb-2 text-marfil",
                              children: "4ta Categora",
                            }),
                            _.jsx("div", {
                              className: "text-3xl font-bold text-marfil mb-2",
                              children: "$900 MXN",
                            }),
                            _.jsx("div", {
                              className: "text-sm text-marfil/80",
                              children: "5, 6 y 7 de Diciembre",
                            }),
                            // _.jsx("p", {
                            //   className: "mt-2 text-marfil/90 text-sm",
                            //   children:
                            //     "Precio preferencial. Acceso exclusivo para quienes se inscriben primero.",
                            // }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                _.jsxs(Me.div, {
                  className:
                    "bg-verde/30 backdrop-blur-sm p-6 rounded-xl border border-verde/40 shadow-xl relative overflow-hidden",
                  whileHover: {
                    scale: 1.02,
                  },
                  transition: {
                    duration: 0.2,
                  },
                  children: [
                    _.jsx("div", {
                      className:
                        "absolute top-0 right-0 bg-verde text-marfil px-3 py-1 text-sm",
                      children: "Early Access",
                    }),
                    _.jsxs("div", {
                      className: "flex items-start gap-4",
                      children: [
                        _.jsx(di, {
                          className: "text-marfil flex-shrink-0",
                          size: 24,
                        }),
                        _.jsxs("div", {
                          children: [
                            _.jsx("div", {
                              className:
                                "text-xl font-semibold mb-2 text-marfil",
                              children: "5ta Categora",
                            }),
                            _.jsx("div", {
                              className: "text-3xl font-bold text-marfil mb-2",
                              children: "$900 MXN",
                            }),
                            _.jsx("div", {
                              className: "text-sm text-marfil/80",
                              children: "5, 6 y 7 de Diciembre",
                            }),
                            // _.jsx("p", {
                            //   className: "mt-2 text-marfil/90 text-sm",
                            //   children:
                            //     "Fase regular. La inscripcin sigue abierta mientras se completan los cuadros.",
                            // }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
                _.jsxs(Me.div, {
                  className:
                    "bg-verde/30 backdrop-blur-sm p-6 rounded-xl border border-verde/40 shadow-xl relative overflow-hidden",
                  whileHover: {
                    scale: 1.02,
                  },
                  transition: {
                    duration: 0.2,
                  },
                  children: [
                    _.jsx("div", {
                      className:
                        "absolute top-0 right-0 bg-verde text-marfil px-3 py-1 text-sm",
                      children: "Early Access",
                    }),
                    _.jsxs("div", {
                      className: "flex items-start gap-4",
                      children: [
                        _.jsx(zg, {
                          className: "text-marfil flex-shrink-0",
                          size: 24,
                        }),
                        _.jsxs("div", {
                          children: [
                            _.jsx("div", {
                              className:
                                "text-xl font-semibold mb-2 text-marfil",
                              children: "6ta categora",
                            }),
                            _.jsx("div", {
                              className: "text-3xl font-bold text-marfil mb-2",
                              children: "$900 MXN",
                            }),
                            _.jsx("div", {
                              className: "text-sm text-marfil/80",
                              children: "5, 6 y 7 de Diciembre",
                            }),
                            // _.jsx("p", {
                            //   className: "mt-2 text-marfil/90 text-sm",
                            //   children:
                            //     "ltimos lugares disponibles. ltima oportunidad para ingresar al torneo.",
                            // }),
                          ],
                        }),
                      ],
                    }),
                  ],
                }),
              ],
            }),
            _.jsxs("div", {
              className: "text-center text-marfil/90 space-y-3 mb-16",
              children: [
                _.jsx("p", {
                  children:
                    "Los partidos de fase de grupos y cuartos se jugarn a 8 juegos y semifinales al mejor de 3 sets completos.",
                }),
                _.jsx("p", {
                  className: "text-sm font-medium",
                  children:
                    "Cierre oficial de inscripciones: lunes 10 de enero",
                }),
                _.jsx("p", {
                  className: "text-sm text-marfil/80",
                  children:
                    "El cierre de inscripciones el 10 de enero es necesario para garantizar la produccin y entrega puntual del equipo oficial (pelotas y gorra) y preparar los materiales del torneo. Queremos brindarte una experiencia de calidad y sin contratiempos.",
                }),
              ],
            }),
            _.jsxs("div", {
              className: "grid grid-cols-1 lg:grid-cols-2 gap-12",
              children: [
                _.jsx("div", {
                  className: "order-2 lg:order-1",
                  children: _.jsxs("div", {
                    className:
                      "bg-verde/30 backdrop-blur-sm p-8 rounded-xl border border-verde/40 shadow-xl",
                    children: [
                      _.jsx("h3", {
                        className: "text-2xl font-semibold text-marfil mb-6",
                        children: "Qu incluye tu inscripcin",
                      }),
                      _.jsx("ul", {
                        className: "space-y-6",
                        children: [
                          "Cancha de prctica exclusiva para los participantes",
                          "Juego de pelotas profesionales Head para el torneo",
                          "Gorra oficial de Padeln",
                          "Barra de snacks y bebidas energticas",
                          "Gana premios y obtn reconocimiento",
                          "Activaciones de marcas y experiencias exclusivas",
                          "Disfruta de un fin de semana lleno de padel y entretenimiento",
                        ].map((f, y) =>
                          _.jsxs(
                            "li",
                            {
                              className: "flex items-start",
                              children: [
                                _.jsx(n_, {
                                  className:
                                    "mr-4 text-marfil flex-shrink-0 mt-1",
                                  size: 20,
                                }),
                                _.jsx("span", {
                                  className: "text-marfil/90",
                                  children: f,
                                }),
                              ],
                            },
                            y
                          )
                        ),
                      }),
                    ],
                  }),
                }),
                _.jsx("div", {
                  className: "order-1 lg:order-2",
                  children: _.jsx("div", {
                    className:
                      "bg-verde/30 backdrop-blur-sm p-8 rounded-xl border border-verde/40 shadow-xl",
                    children: n
                      ? _.jsxs("div", {
                          className: "text-center py-12",
                          children: [
                            _.jsx(Me.div, {
                              initial: {
                                scale: 0,
                              },
                              animate: {
                                scale: 1,
                              },
                              transition: {
                                duration: 0.5,
                              },
                              children: _.jsx(n_, {
                                className: "mx-auto mb-6 text-marfil",
                                size: 64,
                              }),
                            }),
                            _.jsxs(Me.div, {
                              initial: {
                                opacity: 0,
                                y: 20,
                              },
                              animate: {
                                opacity: 1,
                                y: 0,
                              },
                              transition: {
                                delay: 0.3,
                                duration: 0.5,
                              },
                              children: [
                                _.jsx("h3", {
                                  className:
                                    "text-2xl font-semibold mb-6 text-marfil",
                                  children: "Inscripcin Exitosa!",
                                }),
                                _.jsxs("div", {
                                  className: "space-y-4 text-marfil/90",
                                  children: [
                                    _.jsx("p", {
                                      children:
                                        "Tu inscripcin al Padeln ha sido registrada correctamente.",
                                    }),
                                    _.jsx("p", {
                                      children:
                                        "En las prximas 24 horas recibirs un correo electrnico con las instrucciones para completar el pago y asegurar tu lugar en el torneo.",
                                    }),
                                    _.jsx("p", {
                                      className: "mt-8",
                                      children:
                                        "Si tienes alguna duda, puedes contactarnos a travs de:",
                                    }),
                                    _.jsxs("div", {
                                      className:
                                        "flex flex-col items-center gap-3 text-marfil",
                                      children: [
                                        _.jsx("a", {
                                          href: "https://instagram.com/grandslampadelofficial",
                                          target: "_blank",
                                          rel: "noopener noreferrer",
                                          className:
                                            "hover:text-beige transition-colors",
                                          children: "@grandslampadelofficial",
                                        }),
                                        _.jsx("a", {
                                          href: "tel:+523319426363",
                                          className:
                                            "hover:text-beige transition-colors",
                                          children: "33 1942 6363",
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            }),
                          ],
                        })
                      : _.jsxs("form", {
                          onSubmit: p,
                          className: "space-y-6",
                          children: [
                            _.jsxs("div", {
                              className:
                                "grid grid-cols-1 md:grid-cols-2 gap-6",
                              children: [
                                _.jsxs("div", {
                                  className:
                                    "md:col-span-2 bg-verde/10 p-6 rounded-lg",
                                  children: [
                                    _.jsx("h4", {
                                      className:
                                        "text-lg font-semibold text-marfil mb-4",
                                      children: "Jugador 1",
                                    }),
                                    _.jsxs("div", {
                                      className: "space-y-4",
                                      children: [
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player1Name",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Nombre Completo",
                                            }),
                                            _.jsx("input", {
                                              type: "text",
                                              id: "player1Name",
                                              name: "player1Name",
                                              value: t.player1Name,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder:
                                                "Nombre del jugador 1",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player1Age",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Edad",
                                            }),
                                            _.jsx("input", {
                                              type: "number",
                                              id: "player1Age",
                                              name: "player1Age",
                                              value: t.player1Age,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder: "Edad",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player1Gender",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Gnero",
                                            }),
                                            _.jsxs("select", {
                                              id: "player1Gender",
                                              name: "player1Gender",
                                              value: t.player1Gender,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              children: [
                                                _.jsx("option", {
                                                  value: "",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children:
                                                    "Selecciona el gnero",
                                                }),
                                                _.jsx("option", {
                                                  value: "masculino",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children: "Masculino",
                                                }),
                                                _.jsx("option", {
                                                  value: "femenino",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children: "Femenino",
                                                }),
                                              ],
                                            }),
                                          ],
                                        }),
                                        // _.jsxs("div", {
                                        //   children: [
                                        //     _.jsx("label", {
                                        //       htmlFor: "player1ShirtSize",
                                        //       className:
                                        //         "block mb-2 text-sm font-medium text-marfil",
                                        //       children: "Talla de Camiseta",
                                        //     }),
                                        //     _.jsxs("select", {
                                        //       id: "player1ShirtSize",
                                        //       name: "player1ShirtSize",
                                        //       value: t.player1ShirtSize,
                                        //       onChange: h,
                                        //       required: !0,
                                        //       className:
                                        //         "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil focus:border-verde focus:ring-2 focus:ring-verde/50",
                                        //       children: [
                                        //         _.jsx("option", {
                                        //           value: "",
                                        //           className:
                                        //             "bg-verde text-marfil",
                                        //           children:
                                        //             "Selecciona la talla",
                                        //         }),
                                        //         m.map((f) =>
                                        //           _.jsx(
                                        //             "option",
                                        //             {
                                        //               value: f,
                                        //               className:
                                        //                 "bg-verde text-marfil",
                                        //               children: f,
                                        //             },
                                        //             f
                                        //           )
                                        //         ),
                                        //       ],
                                        //     }),
                                        //   ],
                                        // }),
                                      ],
                                    }),
                                  ],
                                }),
                                _.jsxs("div", {
                                  className:
                                    "md:col-span-2 bg-verde/10 p-6 rounded-lg",
                                  children: [
                                    _.jsx("h4", {
                                      className:
                                        "text-lg font-semibold text-marfil mb-4",
                                      children: "Jugador 2",
                                    }),
                                    _.jsxs("div", {
                                      className: "space-y-4",
                                      children: [
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player2Name",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Nombre Completo",
                                            }),
                                            _.jsx("input", {
                                              type: "text",
                                              id: "player2Name",
                                              name: "player2Name",
                                              value: t.player2Name,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder:
                                                "Nombre del jugador 2",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player2Age",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Edad",
                                            }),
                                            _.jsx("input", {
                                              type: "number",
                                              id: "player2Age",
                                              name: "player2Age",
                                              value: t.player2Age,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder: "Edad",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "player2Gender",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Gnero",
                                            }),
                                            _.jsxs("select", {
                                              id: "player2Gender",
                                              name: "player2Gender",
                                              value: t.player2Gender,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              children: [
                                                _.jsx("option", {
                                                  value: "",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children:
                                                    "Selecciona el gnero",
                                                }),
                                                _.jsx("option", {
                                                  value: "masculino",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children: "Masculino",
                                                }),
                                                _.jsx("option", {
                                                  value: "femenino",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children: "Femenino",
                                                }),
                                              ],
                                            }),
                                          ],
                                        }),
                                        // _.jsxs("div", {
                                        //   children: [
                                        //     _.jsx("label", {
                                        //       htmlFor: "player2ShirtSize",
                                        //       className:
                                        //         "block mb-2 text-sm font-medium text-marfil",
                                        //       children: "Talla de Camiseta",
                                        //     }),
                                        //     _.jsxs("select", {
                                        //       id: "player2ShirtSize",
                                        //       name: "player2ShirtSize",
                                        //       value: t.player2ShirtSize,
                                        //       onChange: h,
                                        //       required: !0,
                                        //       className:
                                        //         "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil focus:border-verde focus:ring-2 focus:ring-verde/50",
                                        //       children: [
                                        //         _.jsx("option", {
                                        //           value: "",
                                        //           className:
                                        //             "bg-verde text-marfil",
                                        //           children:
                                        //             "Selecciona la talla",
                                        //         }),
                                        //         m.map((f) =>
                                        //           _.jsx(
                                        //             "option",
                                        //             {
                                        //               value: f,
                                        //               className:
                                        //                 "bg-verde text-marfil",
                                        //               children: f,
                                        //             },
                                        //             f
                                        //           )
                                        //         ),
                                        //       ],
                                        //     }),
                                        //   ],
                                        // }),
                                      ],
                                    }),
                                  ],
                                }),
                                _.jsxs("div", {
                                  className:
                                    "md:col-span-2 bg-verde/10 p-6 rounded-lg",
                                  children: [
                                    _.jsx("h4", {
                                      className:
                                        "text-lg font-semibold text-marfil mb-4",
                                      children: "Informacin del Equipo",
                                    }),
                                    _.jsxs("div", {
                                      className: "space-y-4",
                                      children: [
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "email",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Email",
                                            }),
                                            _.jsx("input", {
                                              type: "email",
                                              id: "email",
                                              name: "email",
                                              value: t.email,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder: "email@ejemplo.com",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "captainWhatsapp",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "WhatsApp del Capitn",
                                            }),
                                            _.jsx("input", {
                                              type: "tel",
                                              id: "captainWhatsapp",
                                              name: "captainWhatsapp",
                                              value: t.captainWhatsapp,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder: "+52 33 1234 5678",
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "category",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children: "Categora",
                                            }),
                                            _.jsxs("select", {
                                              id: "category",
                                              name: "category",
                                              value: t.category,
                                              onChange: h,
                                              required: !0,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              children: [
                                                _.jsx("option", {
                                                  value: "",
                                                  className:
                                                    "bg-verde text-marfil",
                                                  children:
                                                    "Selecciona una categora",
                                                }),
                                                x.map((f) =>
                                                  _.jsx(
                                                    "option",
                                                    {
                                                      value: f.value,
                                                      className:
                                                        "bg-verde text-marfil",
                                                      children: f.label,
                                                    },
                                                    f.value
                                                  )
                                                ),
                                              ],
                                            }),
                                          ],
                                        }),
                                        _.jsxs("div", {
                                          children: [
                                            _.jsx("label", {
                                              htmlFor: "teamName",
                                              className:
                                                "block mb-2 text-sm font-medium text-marfil",
                                              children:
                                                "Nombre del Equipo (Opcional)",
                                            }),
                                            _.jsx("input", {
                                              type: "text",
                                              id: "teamName",
                                              name: "teamName",
                                              value: t.teamName,
                                              onChange: h,
                                              className:
                                                "w-full p-4 bg-verde/20 border border-verde/40 rounded-lg text-marfil placeholder-marfil/60 focus:border-verde focus:ring-2 focus:ring-verde/50",
                                              placeholder:
                                                "Nombre de tu equipo (opcional)",
                                            }),
                                          ],
                                        }),
                                      ],
                                    }),
                                  ],
                                }),
                              ],
                            }),
                            _.jsx("button", {
                              type: "submit",
                              disabled: u,
                              className: `w-full p-4 mt-6 text-lg font-semibold bg-beige text-marfil rounded-lg hover:bg-verde transition-colors duration-300 ${
                                u ? "opacity-50 cursor-not-allowed" : ""
                              }`,
                              children: u
                                ? "Enviando..."
                                : "Enviar Inscripcin",
                            }),
                            l &&
                              _.jsxs("div", {
                                className:
                                  "mt-6 p-4 bg-red-900/20 border border-red-500/30 rounded-lg flex items-start gap-3",
                                children: [
                                  _.jsx(t_, {
                                    className: "text-red-400 flex-shrink-0",
                                    size: 20,
                                  }),
                                  _.jsx("p", {
                                    className: "text-red-200",
                                    children: l,
                                  }),
                                ],
                              }),
                          ],
                        }),
                  }),
                }),
              ],
            }),
          ],
        }),
        _.jsx(OR, {
          children:
            r &&
            _.jsx(Me.div, {
              initial: {
                opacity: 0,
              },
              animate: {
                opacity: 1,
              },
              exit: {
                opacity: 0,
              },
              className:
                "fixed inset-0 bg-medianoche/90 backdrop-blur-sm z-50 flex items-center justify-center p-4",
              children: _.jsxs(Me.div, {
                initial: {
                  scale: 0.9,
                  opacity: 0,
                },
                animate: {
                  scale: 1,
                  opacity: 1,
                },
                exit: {
                  scale: 0.9,
                  opacity: 0,
                },
                className:
                  "bg-marfil rounded-xl shadow-2xl max-w-4xl w-full max-h-[90vh] overflow-hidden relative",
                children: [
                  _.jsxs("div", {
                    className: "p-6 border-b border-medianoche/10",
                    children: [
                      _.jsxs("div", {
                        className: "flex items-center justify-between",
                        children: [
                          _.jsx("h3", {
                            className: "text-2xl font-semibold text-verde",
                            children: "TRMINOS Y CONDICIONES",
                          }),
                          _.jsxs("button", {
                            onClick: () => s(!1),
                            className:
                              "text-medianoche/60 hover:text-medianoche transition-colors",
                            children: [
                              _.jsx("span", {
                                className: "sr-only",
                                children: "Cerrar",
                              }),
                              _.jsx(WE, {
                                size: 24,
                              }),
                            ],
                          }),
                        ],
                      }),
                      _.jsx("p", {
                        className: "text-sm text-medianoche/70 mt-2",
                        children: "Padeln 2025  I Edicin",
                      }),
                    ],
                  }),
                  _.jsxs("div", {
                    className: "p-6 overflow-y-auto max-h-[60vh]",
                    children: [
                      l &&
                        _.jsxs("div", {
                          className:
                            "mb-6 p-4 bg-red-100 border border-red-300 rounded-lg flex items-start gap-3",
                          children: [
                            _.jsx(t_, {
                              className: "text-red-600 flex-shrink-0\\",
                              size: 20,
                            }),
                            _.jsx("p", {
                              className: "text-red-700",
                              children: l,
                            }),
                          ],
                        }),
                      _.jsxs("div", {
                        className: "prose prose-sm max-w-none",
                        children: [
                          _.jsx("p", {
                            className: "text-medianoche/80 italic mb-6",
                            children:
                              "Al completar su inscripcin, los jugadores aceptan los siguientes trminos y condiciones establecidos por el comit organizador de Padeln 2025. El desconocimiento de este reglamento no exime de su cumplimiento.",
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "1. INSCRIPCIN",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "La inscripcin se realiza exclusivamente a travs del formulario oficial del torneo.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Completar el formulario y realizar el pago no garantiza participacin automtica.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Todas las inscripciones sern revisadas y validadas por el comit organizador.",
                              }),
                              _.jsx("li", {
                                children:
                                  "El comit se reserva el derecho de aceptar, rechazar o reasignar parejas a una categora diferente a la solicitada, si considera que no corresponde al nivel competitivo real.",
                              }),
                              _.jsx("li", {
                                children:
                                  "La inscripcin se considera confirmada nicamente al recibir el folio de aceptacin oficial.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Los pagos no son reembolsables, salvo cancelacin oficial del evento por parte de la organizacin.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "2. FORMATO Y REGLAMENTO DE JUEGO",
                          }),
                          _.jsx("p", {
                            className: "font-semibold mb-2",
                            children: "Fase de grupos",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-4 space-y-2",
                            children: [
                              _.jsx("li", {
                                children: "Partidos a 2 de 3 sets",
                              }),
                              _.jsx("li", {
                                children: "Sin ventajas (punto de oro)",
                              }),
                              _.jsx("li", {
                                children:
                                  "En caso de empate 1-1 en sets, se define con super tie-break a 10 puntos",
                              }),
                              _.jsx("li", {
                                children: "Duracin mxima: 1 hora por partido",
                              }),
                            ],
                          }),
                          _.jsx("p", {
                            className: "font-semibold mb-2",
                            children: "Fase final (eliminacin directa)",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-4 space-y-2",
                            children: [
                              _.jsx("li", {
                                children: "Partidos a 2 de 3 sets completos",
                              }),
                              _.jsx("li", {
                                children: "Sin ventajas (punto de oro)",
                              }),
                              _.jsx("li", {
                                children:
                                  "En caso de empate 1-1, se juega un tercer set completo",
                              }),
                              _.jsx("li", {
                                children:
                                  "Duracin mxima: 1 hora y 30 minutos por partido",
                              }),
                            ],
                          }),
                          _.jsx("p", {
                            className: "text-sm text-medianoche/80 mb-6",
                            children:
                              "Todos los partidos se rigen por el reglamento oficial de la International Padel Federation (FIP) y el circuito Premier Padel, salvo las adaptaciones mencionadas anteriormente.",
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "3. PUNTUALIDAD Y ASISTENCIA",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Las parejas debern presentarse mnimo 15 minutos antes del horario asignado para cada partido.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Se otorgar una tolerancia mxima de 10 minutos. En caso de inasistencia o retraso, se aplicar walkover (prdida automtica del partido).",
                              }),
                              _.jsx("li", {
                                children:
                                  "Una vez iniciado el torneo, no se permiten cambios de pareja ni reprogramaciones por causas personales.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "4. CONDUCTA Y DEPORTIVIDAD",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Todos los participantes deben mantener un comportamiento respetuoso y deportivo durante todo el evento.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Est prohibido el uso de lenguaje ofensivo, actitudes antideportivas o cualquier tipo de agresin verbal o fsica.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Cualquier jugador que incurra en una conducta inapropiada, dentro o fuera de la cancha, podr ser sancionado o expulsado del torneo sin derecho a reembolso.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "5. USO DE INSTALACIONES",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "El torneo se llevar a cabo en un club privado que presta sus instalaciones para el evento.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Se espera de todos los asistentes un comportamiento respetuoso hacia el lugar, el personal y las normas del club.",
                              }),
                              _.jsx("li", {
                                children:
                                  "No est permitido el ingreso con alimentos o bebidas externos al evento.",
                              }),
                              _.jsx("li", {
                                children:
                                  "El uso indebido de las instalaciones o comportamientos inapropiados ser causa de expulsin inmediata sin reembolso.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "6. CDIGO DE VESTIMENTA",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Todos los jugadores debern usar la camiseta y gorra oficiales de Padeln durante ambos das del torneo.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Estas prendas sern entregadas por la organizacin como parte del kit de bienvenida, y su uso es obligatorio en todos los partidos.",
                              }),
                              _.jsx("li", {
                                children:
                                  "No est permitido competir con uniformes distintos al oficial. Las parejas que no porten la camiseta y gorra proporcionadas no podrn disputar su partido bajo ninguna circunstancia.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "7. CLIMA Y CONTINGENCIAS",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Todas las canchas del evento son techadas, por lo que el torneo continuar en caso de lluvia.",
                              }),
                              _.jsx("li", {
                                children:
                                  "En caso de cualquier situacin extraordinaria o de fuerza mayor (fallas elctricas, eventos de seguridad, problemas estructurales, etc.), la organizacin podr reprogramar partidos, ajustar el formato o modificar la sede si es necesario.",
                              }),
                              _.jsx("li", {
                                children:
                                  "En dichos casos no aplicar ningn reembolso.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "8. RESPONSABILIDAD",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Todos los jugadores participan bajo su propio riesgo.",
                              }),
                              _.jsx("li", {
                                children:
                                  "El torneo no se hace responsable por lesiones, accidentes, robos o prdidas ocurridas durante el evento.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Se recomienda contar con seguro mdico personal vigente.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "9. DERECHOS DE IMAGEN",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Al inscribirse, los jugadores autorizan el uso de su imagen en fotografas, videos y materiales audiovisuales generados durante el torneo, con fines promocionales del evento o futuras ediciones.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Este contenido podr ser utilizado en redes sociales, sitio web, medios impresos y digitales vinculados a Padeln.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "10. PROTOCOLO DE QUEJAS Y ACLARACIONES",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Cualquier queja, reclamo o aclaracin deber realizarse por escrito directamente al comit organizador, dentro de las 12 horas posteriores al partido correspondiente.",
                              }),
                              _.jsx("li", {
                                children:
                                  "No se aceptarn quejas por redes sociales ni medios no oficiales.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Las decisiones del comit son definitivas e inapelables.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "11. MODIFICACIONES Y CAMBIOS",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "El comit organizador se reserva el derecho de modificar horarios, categoras, sistema de competencia o condiciones generales si las circunstancias lo exigen.",
                              }),
                              _.jsx("li", {
                                children:
                                  "Todo cambio ser comunicado oportunamente por los canales oficiales.",
                              }),
                            ],
                          }),
                          _.jsx("h4", {
                            className: "text-lg font-semibold mb-4",
                            children: "12. COMUNICACIN OFICIAL",
                          }),
                          _.jsxs("ul", {
                            className: "list-disc pl-5 mb-6 space-y-2",
                            children: [
                              _.jsx("li", {
                                children:
                                  "Toda la informacin del torneo ser enviada nicamente al capitn de cada pareja.",
                              }),
                              _.jsx("li", {
                                children: "Canales oficiales de contacto:",
                              }),
                              _.jsxs("ul", {
                                className: "list-none pl-5 space-y-1",
                                children: [
                                  _.jsx("li", {
                                    children:
                                      "Instagram: @grandslampadelofficial",
                                  }),
                                  _.jsx("li", {
                                    children: "WhatsApp: 33 1942 6363",
                                  }),
                                ],
                              }),
                            ],
                          }),
                        ],
                      }),
                    ],
                  }),
                  _.jsx("div", {
                    className:
                      "p-6 border-t border-medianoche/10 bg-marfil sticky bottom-0",
                    children: _.jsxs("div", {
                      className: "flex items-center justify-between",
                      children: [
                        _.jsxs("label", {
                          className:
                            "flex items-center space-x-2 cursor-pointer",
                          children: [
                            _.jsx("input", {
                              type: "checkbox",
                              checked: a,
                              onChange: (f) => o(f.target.checked),
                              className:
                                "w-4 h-4 rounded border-verde text-verde focus:ring-verde",
                            }),
                            _.jsx("span", {
                              className: "text-sm text-medianoche",
                              children:
                                "He ledo y acepto los trminos y condiciones",
                            }),
                          ],
                        }),
                        _.jsx("button", {
                          onClick: v,
                          disabled: !a || u,
                          className: `px-6 py-3 rounded-lg text-marfil transition-colors ${
                            a && !u
                              ? "bg-verde hover:bg-beige"
                              : "bg-medianoche/20 cursor-not-allowed"
                          }`,
                          children: u ? "Procesando..." : "Aceptar y Continuar",
                        }),
                      ],
                    }),
                  }),
                ],
              }),
            }),
        }),
      ],
    });
  },
  xU = () =>
    _.jsx("main", {
      className: "min-h-screen",
      children: _.jsx(yU, {}),
    }),
  SU = [
    {
      name: "Smash Padel",
      image: "https://imgur.com/auC8wCD.jpg",
      link: "https://www.instagram.com/smashpadelballs/",
    },
    {
      name: "Salsa del Impostor",
      image: "https://imgur.com/4d1GxAS.jpg",
      link: "https://www.instagram.com/salsadelimpostor/",
    },
    {
      name: "Mare Co",
      image: "https://imgur.com/Qg7NvBZ.jpg",
      link: "https://www.instagram.com/mare__co/",
    },
    {
      name: "Medusa Solar",
      image: "https://imgur.com/lfCE3Um.jpg",
      link: "https://www.medusasolar.com/",
    },
    {
      name: "El Informador",
      image: "https://imgur.com/s0w4ZJe.jpg",
      link: "https://www.informador.mx/",
    },
    {
      name: "Sangrita del Cuado",
      image: "https://imgur.com/vAl1KTL.jpg",
      link: "https://www.instagram.com/sangrita.del.cunado/",
    },
    {
      name: "Mural",
      image: "https://imgur.com/oY5DYSn.jpg",
      link: "https://www.mural.com.mx/",
    },
    {
      name: "Smirnoff",
      image: "https://imgur.com/fIBClNR.jpg",
      link: "https://www.instagram.com/smirnoffmx/",
    },
    {
      name: "Come Verde",
      image: "https://imgur.com/yLDFa4k.jpg",
      link: "https://www.comeverde.mx/",
    },
    {
      name: "Premier Nuts",
      image: "https://imgur.com/KwFWu98.jpg",
      link: "https://www.instagram.com/premier.nuts/",
    },
    {
      name: "Mint Dreams",
      image: "https://imgur.com/paY1HOI.jpg",
      link: "https://www.instagram.com/mintdreamsmx/",
    },
    {
      name: "Six GDL",
      image: "https://imgur.com/TJDIcf7.jpg",
      link: "https://www.instagram.com/sixgdl/",
    },
    {
      name: "Things Studio",
      image: "https://imgur.com/zP7f9m4.jpg",
      link: "https://www.instagram.com/thingsstudio_/",
    },
    {
      name: "Das Avena",
      image: "https://imgur.com/KTzgBs1.jpg",
      link: "https://dasavena.com/",
    },
    {
      name: "La Mar Restaurante",
      image: "https://imgur.com/p4qhEhc.jpg",
      link: "https://www.instagram.com/lamarrestaurante/",
    },
    {
      name: "Birkenstock",
      image: "https://imgur.com/vx6TqhD.jpg",
      link: "https://www.instagram.com/birkenstockmexico/",
    },
    {
      name: "Station 24 Fitness",
      image: "https://imgur.com/Y7Yoc1o.jpg",
      link: "https://www.instagram.com/station24fitness/",
    },
    {
      name: "Betterware",
      image: "https://imgur.com/ZFHJVOJ.jpg",
      link: "https://www.instagram.com/betterwaremexico/",
    },
    {
      name: "Jgermeister",
      image: "https://imgur.com/VjqZkUP.jpg",
      link: "https://www.instagram.com/jagermeistermx/",
    },
    {
      name: "Biokinesic",
      image: "https://imgur.com/OSSuOdU.jpg",
      link: "https://www.instagram.com/biokinesic/",
    },
    {
      name: "La Historica Jersey Club",
      image: "https://imgur.com/m5kwHpx.jpg",
      link: "https://www.instagram.com/lahistoricajerseyclub/?hl=es-la",
    },
    {
      name: "Present Adaptgenos",
      image: "https://imgur.com/nZzJyYy.jpg",
      link: "https://www.instagram.com/present.adaptogenos/",
    },
    {
      name: "Skarch",
      image: "https://imgur.com/lvxHkHB.jpg",
      link: "https://www.instagram.com/skarchmexico/",
    },
    {
      name: "Seagram's Selzer",
      image: "https://imgur.com/YfnIPSJ.jpg",
      link: "https://seagramshardseltzer.mx/inicio/",
    },
    {
      name: "Red Cola",
      image: "https://imgur.com/MPA3x5d.jpg",
      link: "https://www.instagram.com/redcolamx/",
    },
    {
      name: "Fornino",
      image: "https://imgur.com/Nuaalnf.jpg",
      link: "https://www.instagram.com/fornino_gdl/",
    },
    {
      name: "Cabotina",
      image: "https://imgur.com/bpIm7zq.jpg",
      link: "https://www.instagram.com/cabotina_gdl/",
    },
    {
      name: "Casa San Matas",
      image: "https://imgur.com/nmJEwEv.jpg",
      link: "https://www.instagram.com/casasanmatiasoficial/",
    },
    {
      name: "Electrolit",
      image: "https://imgur.com/w9Iy2Ju.jpg",
      link: "https://www.instagram.com/electrolit/",
    },
    {
      name: "Aleta Azul",
      image: "https://imgur.com/xtmSY1t.jpg",
      link: "https://www.instagram.com/aletazulcompany/",
    },
    {
      name: "Palmar Spritz",
      image: "https://imgur.com/SY2GplZ.jpg",
      link: "https://www.instagram.com/palmar_spritz/",
    },
    {
      name: "Wu Nutrition",
      image: "https://imgur.com/lGviTeM.jpg",
      link: "https://wunutrition.com/",
    },
    {
      name: "Atajo Outdoors",
      image: "https://imgur.com/rCo7Vxe.jpg",
      link: "https://www.instagram.com/atajooutdoors/",
    },
    {
      name: "The Fulen Club",
      image: "https://imgur.com/8BGKSkR.jpg",
      link: "https://www.instagram.com/thefulenclub/",
    },
    {
      name: "Deyun Pharma",
      image: "https://imgur.com/6rm2xR7.jpg",
      link: "https://www.instagram.com/deyunpharmamx/",
    },
    {
      name: "Caf La Flor De Crdoba",
      image: "https://imgur.com/BZxt0nT.jpg",
      link: "https://www.instagram.com/laflordecordoba/",
    },
    {
      name: "Omigoto",
      image: "https://imgur.com/yjSCL5S.jpg",
      link: "https://www.instagram.com/omigotomx/",
    },
    {
      name: "Grupo Ocurrente",
      image: "https://imgur.com/7MOX4rF.jpg",
      link: "https://www.instagram.com/grupoocurrente/",
    },
    {
      name: "ACA",
      image: "https://imgur.com/lQq2KIs.jpg",
      link: "https://www.instagram.com/acapadelmx/",
    },
    {
      name: "Luar",
      image: "https://imgur.com/3G2tM4f.jpg",
      link: "https://www.instagram.com/luar_chocolates/",
    },
    {
      name: "Eloise",
      image: "https://imgur.com/qnY8dXJ.jpg",
      link: "https://www.instagram.com/eloisebakedgoods/",
    },
    {
      name: "Vida Flora",
      image: "https://imgur.com/dmNHxYX.jpg",
      link: "https://www.instagram.com/vidafloramx/",
    },
    {
      name: "Habits",
      image: "https://imgur.com/Sy57tjf.jpg",
      link: "https://www.instagram.com/habitsproteins/",
    },
    {
      name: "Acai Wowl",
      image: "https://imgur.com/dRswIyC.jpg",
      link: "https://www.instagram.com/wowlacai/",
    },
    {
      name: "Los Charros",
      image: "https://imgur.com/CBEt2gn.jpg",
      link: "https://www.instagram.com/charrosbeisbol/",
    },
    {
      name: "Refuse",
      image: "https://imgur.com/R2AJnbV.jpg",
      link: "https://www.instagram.com/refuse.mx/",
    },
    {
      name: "AO Sports",
      image: "https://imgur.com/WqWIvBo.jpg",
      link: "https://www.instagram.com/ao.sport.mx/",
    },
    {
      name: "Gleytor",
      image: "https://imgur.com/EW4nfMD.jpg",
      link: "https://www.instagram.com/gleytormx/",
    },
    {
      name: "WTMH",
      image: "https://imgur.com/ToNJwhX.jpg",
      link: "https://www.instagram.com/wtmh___/",
    },
  ],
  wU = () => {
    const t = {
        hidden: {
          opacity: 0,
        },
        show: {
          opacity: 1,
          transition: {
            staggerChildren: 0.1,
          },
        },
      },
      e = {
        hidden: {
          opacity: 0,
          y: 20,
        },
        show: {
          opacity: 1,
          y: 0,
        },
      };
    return _.jsx("main", {
      className: "min-h-screen bg-marfil",
      children: _.jsxs("div", {
        className: "container py-24",
        children: [
          _.jsxs(Me.div, {
            initial: {
              opacity: 0,
              y: -20,
            },
            animate: {
              opacity: 1,
              y: 0,
            },
            transition: {
              duration: 0.6,
            },
            className: "text-center mb-16",
            children: [
              _.jsx("h1", {
                className: "text-4xl md:text-5xl font-bold text-verde mb-4",
                children: "Nuestros Patrocinadores",
              }),
              _.jsx("p", {
                className: "text-xl text-medianoche/80 max-w-3xl mx-auto",
                children:
                  "Nos honra contar con el respaldo de marcas lderes que hacen posible esta edicin de Padeln.",
              }),
            ],
          }),
          _.jsx(Me.div, {
            variants: t,
            initial: "hidden",
            animate: "show",
            className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-8",
            children: SU.map((n, i) =>
              _.jsx(
                Me.div,
                {
                  variants: e,
                  className:
                    "bg-white rounded-lg shadow-lg overflow-hidden transform-gpu hover:scale-105 transition-transform duration-300",
                  children: _.jsxs("a", {
                    href: n.link,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "block p-8",
                    "aria-label": `Visitar sitio web de ${n.name}`,
                    children: [
                      _.jsx("div", {
                        className: "aspect-[3/2] relative mb-4",
                        children: _.jsx(Me.img, {
                          src: n.image,
                          alt: n.name,
                          className: "w-full h-full object-contain",
                          loading: "lazy",
                          whileHover: {
                            scale: 1.05,
                          },
                          transition: {
                            duration: 0.2,
                          },
                        }),
                      }),
                      _.jsx("h3", {
                        className:
                          "text-xl font-semibold text-verde text-center",
                        children: n.name,
                      }),
                    ],
                  }),
                },
                i
              )
            ),
          }),
        ],
      }),
    });
  };
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */

const Cv = "162",
  EU = 0,
  Xy = 1,
  TU = 2,
  sM = 1,
  MU = 2,
  Ki = 3,
  as = 0,
  Dn = 1,
  nr = 2,
  Zr = 0,
  ro = 1,
  Nm = 2,
  qy = 3,
  Yy = 4,
  bU = 5,
  Ns = 100,
  AU = 101,
  CU = 102,
  Zy = 103,
  Ky = 104,
  RU = 200,
  PU = 201,
  LU = 202,
  NU = 203,
  Dm = 204,
  km = 205,
  DU = 206,
  kU = 207,
  IU = 208,
  UU = 209,
  OU = 210,
  FU = 211,
  BU = 212,
  zU = 213,
  jU = 214,
  VU = 0,
  HU = 1,
  GU = 2,
  Od = 3,
  WU = 4,
  $U = 5,
  XU = 6,
  qU = 7,
  aM = 0,
  YU = 1,
  ZU = 2,
  Kr = 0,
  KU = 1,
  JU = 2,
  QU = 3,
  eO = 4,
  tO = 5,
  nO = 6,
  iO = 7,
  oM = 300,
  So = 301,
  wo = 302,
  Im = 303,
  Um = 304,
  wh = 306,
  Om = 1e3,
  vi = 1001,
  Fm = 1002,
  vn = 1003,
  Jy = 1004,
  qo = 1005,
  Mn = 1006,
  Af = 1007,
  Fs = 1008,
  Jr = 1009,
  rO = 1010,
  sO = 1011,
  Rv = 1012,
  lM = 1013,
  zr = 1014,
  ir = 1015,
  hc = 1016,
  cM = 1017,
  uM = 1018,
  Hs = 1020,
  aO = 1021,
  _i = 1023,
  oO = 1024,
  lO = 1025,
  Gs = 1026,
  Eo = 1027,
  cO = 1028,
  dM = 1029,
  uO = 1030,
  hM = 1031,
  fM = 1033,
  Cf = 33776,
  Rf = 33777,
  Pf = 33778,
  Lf = 33779,
  Qy = 35840,
  ex = 35841,
  tx = 35842,
  nx = 35843,
  pM = 36196,
  ix = 37492,
  rx = 37496,
  sx = 37808,
  ax = 37809,
  ox = 37810,
  lx = 37811,
  cx = 37812,
  ux = 37813,
  dx = 37814,
  hx = 37815,
  fx = 37816,
  px = 37817,
  mx = 37818,
  gx = 37819,
  vx = 37820,
  _x = 37821,
  Nf = 36492,
  yx = 36494,
  xx = 36495,
  dO = 36283,
  Sx = 36284,
  wx = 36285,
  Ex = 36286,
  hO = 3200,
  fO = 3201,
  pO = 0,
  mO = 1,
  Ur = "",
  Li = "srgb",
  fs = "srgb-linear",
  Pv = "display-p3",
  Eh = "display-p3-linear",
  Fd = "linear",
  vt = "srgb",
  Bd = "rec709",
  zd = "p3",
  ha = 7680,
  Tx = 519,
  gO = 512,
  vO = 513,
  _O = 514,
  mM = 515,
  yO = 516,
  xO = 517,
  SO = 518,
  wO = 519,
  Mx = 35044,
  bx = "300 es",
  Bm = 1035,
  ar = 2e3,
  jd = 2001;
class ko {
  addEventListener(e, n) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(n) === -1 && i[e].push(n);
  }
  hasEventListener(e, n) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(n) !== -1;
  }
  removeEventListener(e, n) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(n);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, a = r.length; s < a; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const an = [
    "00",
    "01",
    "02",
    "03",
    "04",
    "05",
    "06",
    "07",
    "08",
    "09",
    "0a",
    "0b",
    "0c",
    "0d",
    "0e",
    "0f",
    "10",
    "11",
    "12",
    "13",
    "14",
    "15",
    "16",
    "17",
    "18",
    "19",
    "1a",
    "1b",
    "1c",
    "1d",
    "1e",
    "1f",
    "20",
    "21",
    "22",
    "23",
    "24",
    "25",
    "26",
    "27",
    "28",
    "29",
    "2a",
    "2b",
    "2c",
    "2d",
    "2e",
    "2f",
    "30",
    "31",
    "32",
    "33",
    "34",
    "35",
    "36",
    "37",
    "38",
    "39",
    "3a",
    "3b",
    "3c",
    "3d",
    "3e",
    "3f",
    "40",
    "41",
    "42",
    "43",
    "44",
    "45",
    "46",
    "47",
    "48",
    "49",
    "4a",
    "4b",
    "4c",
    "4d",
    "4e",
    "4f",
    "50",
    "51",
    "52",
    "53",
    "54",
    "55",
    "56",
    "57",
    "58",
    "59",
    "5a",
    "5b",
    "5c",
    "5d",
    "5e",
    "5f",
    "60",
    "61",
    "62",
    "63",
    "64",
    "65",
    "66",
    "67",
    "68",
    "69",
    "6a",
    "6b",
    "6c",
    "6d",
    "6e",
    "6f",
    "70",
    "71",
    "72",
    "73",
    "74",
    "75",
    "76",
    "77",
    "78",
    "79",
    "7a",
    "7b",
    "7c",
    "7d",
    "7e",
    "7f",
    "80",
    "81",
    "82",
    "83",
    "84",
    "85",
    "86",
    "87",
    "88",
    "89",
    "8a",
    "8b",
    "8c",
    "8d",
    "8e",
    "8f",
    "90",
    "91",
    "92",
    "93",
    "94",
    "95",
    "96",
    "97",
    "98",
    "99",
    "9a",
    "9b",
    "9c",
    "9d",
    "9e",
    "9f",
    "a0",
    "a1",
    "a2",
    "a3",
    "a4",
    "a5",
    "a6",
    "a7",
    "a8",
    "a9",
    "aa",
    "ab",
    "ac",
    "ad",
    "ae",
    "af",
    "b0",
    "b1",
    "b2",
    "b3",
    "b4",
    "b5",
    "b6",
    "b7",
    "b8",
    "b9",
    "ba",
    "bb",
    "bc",
    "bd",
    "be",
    "bf",
    "c0",
    "c1",
    "c2",
    "c3",
    "c4",
    "c5",
    "c6",
    "c7",
    "c8",
    "c9",
    "ca",
    "cb",
    "cc",
    "cd",
    "ce",
    "cf",
    "d0",
    "d1",
    "d2",
    "d3",
    "d4",
    "d5",
    "d6",
    "d7",
    "d8",
    "d9",
    "da",
    "db",
    "dc",
    "dd",
    "de",
    "df",
    "e0",
    "e1",
    "e2",
    "e3",
    "e4",
    "e5",
    "e6",
    "e7",
    "e8",
    "e9",
    "ea",
    "eb",
    "ec",
    "ed",
    "ee",
    "ef",
    "f0",
    "f1",
    "f2",
    "f3",
    "f4",
    "f5",
    "f6",
    "f7",
    "f8",
    "f9",
    "fa",
    "fb",
    "fc",
    "fd",
    "fe",
    "ff",
  ],
  Df = Math.PI / 180,
  zm = 180 / Math.PI;
function Ac() {
  const t = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    an[t & 255] +
    an[(t >> 8) & 255] +
    an[(t >> 16) & 255] +
    an[(t >> 24) & 255] +
    "-" +
    an[e & 255] +
    an[(e >> 8) & 255] +
    "-" +
    an[((e >> 16) & 15) | 64] +
    an[(e >> 24) & 255] +
    "-" +
    an[(n & 63) | 128] +
    an[(n >> 8) & 255] +
    "-" +
    an[(n >> 16) & 255] +
    an[(n >> 24) & 255] +
    an[i & 255] +
    an[(i >> 8) & 255] +
    an[(i >> 16) & 255] +
    an[(i >> 24) & 255]
  ).toLowerCase();
}
function Cn(t, e, n) {
  return Math.max(e, Math.min(n, t));
}
function EO(t, e) {
  return ((t % e) + e) % e;
}
function kf(t, e, n) {
  return (1 - n) * t + n * e;
}
function Ax(t) {
  return (t & (t - 1)) === 0 && t !== 0;
}
function jm(t) {
  return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
}
function Yo(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return t / 4294967295;
    case Uint16Array:
      return t / 65535;
    case Uint8Array:
      return t / 255;
    case Int32Array:
      return Math.max(t / 2147483647, -1);
    case Int16Array:
      return Math.max(t / 32767, -1);
    case Int8Array:
      return Math.max(t / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function Tn(t, e) {
  switch (e.constructor) {
    case Float32Array:
      return t;
    case Uint32Array:
      return Math.round(t * 4294967295);
    case Uint16Array:
      return Math.round(t * 65535);
    case Uint8Array:
      return Math.round(t * 255);
    case Int32Array:
      return Math.round(t * 2147483647);
    case Int16Array:
      return Math.round(t * 32767);
    case Int8Array:
      return Math.round(t * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
class ot {
  constructor(e = 0, n = 0) {
    (ot.prototype.isVector2 = !0), (this.x = e), (this.y = n);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, n) {
    return (this.x = e), (this.y = n), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, n) {
    return (this.x = e.x + n.x), (this.y = e.y + n.y), this;
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, n) {
    return (this.x = e.x - n.x), (this.y = e.y - n.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const n = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * n + r[3] * i + r[6]),
      (this.y = r[1] * n + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Cn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      i = this.y - e.y;
    return n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (this.x += (e.x - this.x) * n), (this.y += (e.y - this.y) * n), this;
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i), (this.y = e.y + (n.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), e;
  }
  fromBufferAttribute(e, n) {
    return (this.x = e.getX(n)), (this.y = e.getY(n)), this;
  }
  rotateAround(e, n) {
    const i = Math.cos(n),
      r = Math.sin(n),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * i - a * r + e.x), (this.y = s * r + a * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class $e {
  constructor(e, n, i, r, s, a, o, l, c) {
    ($e.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, i, r, s, a, o, l, c);
  }
  set(e, n, i, r, s, a, o, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = r),
      (u[2] = o),
      (u[3] = n),
      (u[4] = s),
      (u[5] = l),
      (u[6] = i),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const n = this.elements,
      i = e.elements;
    return (
      (n[0] = i[0]),
      (n[1] = i[1]),
      (n[2] = i[2]),
      (n[3] = i[3]),
      (n[4] = i[4]),
      (n[5] = i[5]),
      (n[6] = i[6]),
      (n[7] = i[7]),
      (n[8] = i[8]),
      this
    );
  }
  extractBasis(e, n, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      n.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const n = e.elements;
    return (
      this.set(n[0], n[4], n[8], n[1], n[5], n[9], n[2], n[6], n[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements,
      r = n.elements,
      s = this.elements,
      a = i[0],
      o = i[3],
      l = i[6],
      c = i[1],
      u = i[4],
      d = i[7],
      h = i[2],
      p = i[5],
      v = i[8],
      x = r[0],
      m = r[3],
      f = r[6],
      y = r[1],
      g = r[4],
      S = r[7],
      T = r[2],
      A = r[5],
      b = r[8];
    return (
      (s[0] = a * x + o * y + l * T),
      (s[3] = a * m + o * g + l * A),
      (s[6] = a * f + o * S + l * b),
      (s[1] = c * x + u * y + d * T),
      (s[4] = c * m + u * g + d * A),
      (s[7] = c * f + u * S + d * b),
      (s[2] = h * x + p * y + v * T),
      (s[5] = h * m + p * g + v * A),
      (s[8] = h * f + p * S + v * b),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[3] *= e),
      (n[6] *= e),
      (n[1] *= e),
      (n[4] *= e),
      (n[7] *= e),
      (n[2] *= e),
      (n[5] *= e),
      (n[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      n * a * u - n * o * c - i * s * u + i * o * l + r * s * c - r * a * l
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = u * a - o * c,
      h = o * l - u * s,
      p = c * s - a * l,
      v = n * d + i * h + r * p;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const x = 1 / v;
    return (
      (e[0] = d * x),
      (e[1] = (r * c - u * i) * x),
      (e[2] = (o * i - r * a) * x),
      (e[3] = h * x),
      (e[4] = (u * n - r * l) * x),
      (e[5] = (r * s - o * n) * x),
      (e[6] = p * x),
      (e[7] = (i * l - c * n) * x),
      (e[8] = (a * n - i * s) * x),
      this
    );
  }
  transpose() {
    let e;
    const n = this.elements;
    return (
      (e = n[1]),
      (n[1] = n[3]),
      (n[3] = e),
      (e = n[2]),
      (n[2] = n[6]),
      (n[6] = e),
      (e = n[5]),
      (n[5] = n[7]),
      (n[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const n = this.elements;
    return (
      (e[0] = n[0]),
      (e[1] = n[3]),
      (e[2] = n[6]),
      (e[3] = n[1]),
      (e[4] = n[4]),
      (e[5] = n[7]),
      (e[6] = n[2]),
      (e[7] = n[5]),
      (e[8] = n[8]),
      this
    );
  }
  setUvTransform(e, n, i, r, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * a + c * o) + a + e,
        -r * c,
        r * l,
        -r * (-c * a + l * o) + o + n,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, n) {
    return this.premultiply(If.makeScale(e, n)), this;
  }
  rotate(e) {
    return this.premultiply(If.makeRotation(-e)), this;
  }
  translate(e, n) {
    return this.premultiply(If.makeTranslation(e, n)), this;
  }
  makeTranslation(e, n) {
    return (
      e.isVector2
        ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
        : this.set(1, 0, e, 0, 1, n, 0, 0, 1),
      this
    );
  }
  makeRotation(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, -i, 0, i, n, 0, 0, 0, 1), this;
  }
  makeScale(e, n) {
    return this.set(e, 0, 0, 0, n, 0, 0, 0, 1), this;
  }
  equals(e) {
    const n = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return (
      (e[n] = i[0]),
      (e[n + 1] = i[1]),
      (e[n + 2] = i[2]),
      (e[n + 3] = i[3]),
      (e[n + 4] = i[4]),
      (e[n + 5] = i[5]),
      (e[n + 6] = i[6]),
      (e[n + 7] = i[7]),
      (e[n + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const If = new $e();
function gM(t) {
  for (let e = t.length - 1; e >= 0; --e) if (t[e] >= 65535) return !0;
  return !1;
}
function Vd(t) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", t);
}
function TO() {
  const t = Vd("canvas");
  return (t.style.display = "block"), t;
}
const Cx = {};
function MO(t) {
  t in Cx || ((Cx[t] = !0), console.warn(t));
}
const Rx = new $e().set(
    0.8224621,
    0.177538,
    0,
    0.0331941,
    0.9668058,
    0,
    0.0170827,
    0.0723974,
    0.9105199
  ),
  Px = new $e().set(
    1.2249401,
    -0.2249404,
    0,
    -0.0420569,
    1.0420571,
    0,
    -0.0196376,
    -0.0786361,
    1.0982735
  ),
  au = {
    [fs]: {
      transfer: Fd,
      primaries: Bd,
      toReference: (t) => t,
      fromReference: (t) => t,
    },
    [Li]: {
      transfer: vt,
      primaries: Bd,
      toReference: (t) => t.convertSRGBToLinear(),
      fromReference: (t) => t.convertLinearToSRGB(),
    },
    [Eh]: {
      transfer: Fd,
      primaries: zd,
      toReference: (t) => t.applyMatrix3(Px),
      fromReference: (t) => t.applyMatrix3(Rx),
    },
    [Pv]: {
      transfer: vt,
      primaries: zd,
      toReference: (t) => t.convertSRGBToLinear().applyMatrix3(Px),
      fromReference: (t) => t.applyMatrix3(Rx).convertLinearToSRGB(),
    },
  },
  bO = new Set([fs, Eh]),
  dt = {
    enabled: !0,
    _workingColorSpace: fs,
    get workingColorSpace() {
      return this._workingColorSpace;
    },
    set workingColorSpace(t) {
      if (!bO.has(t))
        throw new Error(`Unsupported working color space, "${t}".`);
      this._workingColorSpace = t;
    },
    convert: function (t, e, n) {
      if (this.enabled === !1 || e === n || !e || !n) return t;
      const i = au[e].toReference,
        r = au[n].fromReference;
      return r(i(t));
    },
    fromWorkingColorSpace: function (t, e) {
      return this.convert(t, this._workingColorSpace, e);
    },
    toWorkingColorSpace: function (t, e) {
      return this.convert(t, e, this._workingColorSpace);
    },
    getPrimaries: function (t) {
      return au[t].primaries;
    },
    getTransfer: function (t) {
      return t === Ur ? Fd : au[t].transfer;
    },
  };
function so(t) {
  return t < 0.04045
    ? t * 0.0773993808
    : Math.pow(t * 0.9478672986 + 0.0521327014, 2.4);
}
function Uf(t) {
  return t < 0.0031308 ? t * 12.92 : 1.055 * Math.pow(t, 0.41666) - 0.055;
}
let fa;
class vM {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let n;
    if (e instanceof HTMLCanvasElement) n = e;
    else {
      fa === void 0 && (fa = Vd("canvas")),
        (fa.width = e.width),
        (fa.height = e.height);
      const i = fa.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (n = fa);
    }
    return n.width > 2048 || n.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        n.toDataURL("image/jpeg", 0.6))
      : n.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const n = Vd("canvas");
      (n.width = e.width), (n.height = e.height);
      const i = n.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let a = 0; a < s.length; a++) s[a] = so(s[a] / 255) * 255;
      return i.putImageData(r, 0, 0), n;
    } else if (e.data) {
      const n = e.data.slice(0);
      for (let i = 0; i < n.length; i++)
        n instanceof Uint8Array || n instanceof Uint8ClampedArray
          ? (n[i] = Math.floor(so(n[i] / 255) * 255))
          : (n[i] = so(n[i]));
      return {
        data: n,
        width: e.width,
        height: e.height,
      };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
let AO = 0;
class _M {
  constructor(e = null) {
    (this.isSource = !0),
      Object.defineProperty(this, "id", {
        value: AO++,
      }),
      (this.uuid = Ac()),
      (this.data = e),
      (this.dataReady = !0),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = {
        uuid: this.uuid,
        url: "",
      },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let a = 0, o = r.length; a < o; a++)
          r[a].isDataTexture ? s.push(Of(r[a].image)) : s.push(Of(r[a]));
      } else s = Of(r);
      i.url = s;
    }
    return n || (e.images[this.uuid] = i), i;
  }
}
function Of(t) {
  return (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && t instanceof ImageBitmap)
    ? vM.getDataURL(t)
    : t.data
    ? {
        data: Array.from(t.data),
        width: t.width,
        height: t.height,
        type: t.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let CO = 0;
class kn extends ko {
  constructor(
    e = kn.DEFAULT_IMAGE,
    n = kn.DEFAULT_MAPPING,
    i = vi,
    r = vi,
    s = Mn,
    a = Fs,
    o = _i,
    l = Jr,
    c = kn.DEFAULT_ANISOTROPY,
    u = Ur
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", {
        value: CO++,
      }),
      (this.uuid = Ac()),
      (this.name = ""),
      (this.source = new _M(e)),
      (this.mipmaps = []),
      (this.mapping = n),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ot(0, 0)),
      (this.repeat = new ot(1, 1)),
      (this.center = new ot(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new $e()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.colorSpace = u),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    if (!n && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON",
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      n || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  transformUv(e) {
    if (this.mapping !== oM) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Om:
          e.x = e.x - Math.floor(e.x);
          break;
        case vi:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Om:
          e.y = e.y - Math.floor(e.y);
          break;
        case vi:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Fm:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
kn.DEFAULT_IMAGE = null;
kn.DEFAULT_MAPPING = oM;
kn.DEFAULT_ANISOTROPY = 1;
class Qt {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    (Qt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = n),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, n, i, r) {
    return (this.x = e), (this.y = n), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      case 3:
        this.w = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x),
      (this.y = e.y + n.y),
      (this.z = e.z + n.z),
      (this.w = e.w + n.w),
      this
    );
  }
  addScaledVector(e, n) {
    return (
      (this.x += e.x * n),
      (this.y += e.y * n),
      (this.z += e.z * n),
      (this.w += e.w * n),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x),
      (this.y = e.y - n.y),
      (this.z = e.z - n.z),
      (this.w = e.w - n.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * n + a[4] * i + a[8] * r + a[12] * s),
      (this.y = a[1] * n + a[5] * i + a[9] * r + a[13] * s),
      (this.z = a[2] * n + a[6] * i + a[10] * r + a[14] * s),
      (this.w = a[3] * n + a[7] * i + a[11] * r + a[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const n = Math.sqrt(1 - e.w * e.w);
    return (
      n < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / n), (this.y = e.y / n), (this.z = e.z / n)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let n, i, r, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      d = l[8],
      h = l[1],
      p = l[5],
      v = l[9],
      x = l[2],
      m = l[6],
      f = l[10];
    if (
      Math.abs(u - h) < 0.01 &&
      Math.abs(d - x) < 0.01 &&
      Math.abs(v - m) < 0.01
    ) {
      if (
        Math.abs(u + h) < 0.1 &&
        Math.abs(d + x) < 0.1 &&
        Math.abs(v + m) < 0.1 &&
        Math.abs(c + p + f - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      n = Math.PI;
      const g = (c + 1) / 2,
        S = (p + 1) / 2,
        T = (f + 1) / 2,
        A = (u + h) / 4,
        b = (d + x) / 4,
        P = (v + m) / 4;
      return (
        g > S && g > T
          ? g < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(g)), (r = A / i), (s = b / i))
          : S > T
          ? S < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(S)), (i = A / r), (s = P / r))
          : T < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(T)), (i = b / s), (r = P / s)),
        this.set(i, r, s, n),
        this
      );
    }
    let y = Math.sqrt(
      (m - v) * (m - v) + (d - x) * (d - x) + (h - u) * (h - u)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (m - v) / y),
      (this.y = (d - x) / y),
      (this.z = (h - u) / y),
      (this.w = Math.acos((c + p + f - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      (this.w = Math.max(e.w, Math.min(n.w, this.w))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      (this.w = Math.max(e, Math.min(n, this.w))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      (this.w = Math.trunc(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      (this.w += (e.w - this.w) * n),
      this
    );
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i),
      (this.y = e.y + (n.y - e.y) * i),
      (this.z = e.z + (n.z - e.z) * i),
      (this.w = e.w + (n.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, n = 0) {
    return (
      (this.x = e[n]),
      (this.y = e[n + 1]),
      (this.z = e[n + 2]),
      (this.w = e[n + 3]),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this.x),
      (e[n + 1] = this.y),
      (e[n + 2] = this.z),
      (e[n + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)),
      (this.y = e.getY(n)),
      (this.z = e.getZ(n)),
      (this.w = e.getW(n)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class RO extends ko {
  constructor(e = 1, n = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = n),
      (this.depth = 1),
      (this.scissor = new Qt(0, 0, e, n)),
      (this.scissorTest = !1),
      (this.viewport = new Qt(0, 0, e, n));
    const r = {
      width: e,
      height: n,
      depth: 1,
    };
    i = Object.assign(
      {
        generateMipmaps: !1,
        internalFormat: null,
        minFilter: Mn,
        depthBuffer: !0,
        stencilBuffer: !1,
        depthTexture: null,
        samples: 0,
        count: 1,
      },
      i
    );
    const s = new kn(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.colorSpace
    );
    (s.flipY = !1),
      (s.generateMipmaps = i.generateMipmaps),
      (s.internalFormat = i.internalFormat),
      (this.textures = []);
    const a = i.count;
    for (let o = 0; o < a; o++)
      (this.textures[o] = s.clone()),
        (this.textures[o].isRenderTargetTexture = !0);
    (this.depthBuffer = i.depthBuffer),
      (this.stencilBuffer = i.stencilBuffer),
      (this.depthTexture = i.depthTexture),
      (this.samples = i.samples);
  }
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  setSize(e, n, i = 1) {
    if (this.width !== e || this.height !== n || this.depth !== i) {
      (this.width = e), (this.height = n), (this.depth = i);
      for (let r = 0, s = this.textures.length; r < s; r++)
        (this.textures[r].image.width = e),
          (this.textures[r].image.height = n),
          (this.textures[r].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, n), this.scissor.set(0, 0, e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.textures.length = 0);
    for (let i = 0, r = e.textures.length; i < r; i++)
      (this.textures[i] = e.textures[i].clone()),
        (this.textures[i].isRenderTargetTexture = !0);
    const n = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new _M(n)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
class ta extends RO {
  constructor(e = 1, n = 1, i = {}) {
    super(e, n, i), (this.isWebGLRenderTarget = !0);
  }
}
class yM extends kn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = {
        data: e,
        width: n,
        height: i,
        depth: r,
      }),
      (this.magFilter = vn),
      (this.minFilter = vn),
      (this.wrapR = vi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class PO extends kn {
  constructor(e = null, n = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = {
        data: e,
        width: n,
        height: i,
        depth: r,
      }),
      (this.magFilter = vn),
      (this.minFilter = vn),
      (this.wrapR = vi),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Cc {
  constructor(e = 0, n = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, n, i, r, s, a, o) {
    let l = i[r + 0],
      c = i[r + 1],
      u = i[r + 2],
      d = i[r + 3];
    const h = s[a + 0],
      p = s[a + 1],
      v = s[a + 2],
      x = s[a + 3];
    if (o === 0) {
      (e[n + 0] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
      return;
    }
    if (o === 1) {
      (e[n + 0] = h), (e[n + 1] = p), (e[n + 2] = v), (e[n + 3] = x);
      return;
    }
    if (d !== x || l !== h || c !== p || u !== v) {
      let m = 1 - o;
      const f = l * h + c * p + u * v + d * x,
        y = f >= 0 ? 1 : -1,
        g = 1 - f * f;
      if (g > Number.EPSILON) {
        const T = Math.sqrt(g),
          A = Math.atan2(T, f * y);
        (m = Math.sin(m * A) / T), (o = Math.sin(o * A) / T);
      }
      const S = o * y;
      if (
        ((l = l * m + h * S),
        (c = c * m + p * S),
        (u = u * m + v * S),
        (d = d * m + x * S),
        m === 1 - o)
      ) {
        const T = 1 / Math.sqrt(l * l + c * c + u * u + d * d);
        (l *= T), (c *= T), (u *= T), (d *= T);
      }
    }
    (e[n] = l), (e[n + 1] = c), (e[n + 2] = u), (e[n + 3] = d);
  }
  static multiplyQuaternionsFlat(e, n, i, r, s, a) {
    const o = i[r],
      l = i[r + 1],
      c = i[r + 2],
      u = i[r + 3],
      d = s[a],
      h = s[a + 1],
      p = s[a + 2],
      v = s[a + 3];
    return (
      (e[n] = o * v + u * d + l * p - c * h),
      (e[n + 1] = l * v + u * h + c * d - o * p),
      (e[n + 2] = c * v + u * p + o * h - l * d),
      (e[n + 3] = u * v - o * d - l * h - c * p),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, n, i, r) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, n = !0) {
    const i = e._x,
      r = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(i / 2),
      u = o(r / 2),
      d = o(s / 2),
      h = l(i / 2),
      p = l(r / 2),
      v = l(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = h * u * d + c * p * v),
          (this._y = c * p * d - h * u * v),
          (this._z = c * u * v + h * p * d),
          (this._w = c * u * d - h * p * v);
        break;
      case "YXZ":
        (this._x = h * u * d + c * p * v),
          (this._y = c * p * d - h * u * v),
          (this._z = c * u * v - h * p * d),
          (this._w = c * u * d + h * p * v);
        break;
      case "ZXY":
        (this._x = h * u * d - c * p * v),
          (this._y = c * p * d + h * u * v),
          (this._z = c * u * v + h * p * d),
          (this._w = c * u * d - h * p * v);
        break;
      case "ZYX":
        (this._x = h * u * d - c * p * v),
          (this._y = c * p * d + h * u * v),
          (this._z = c * u * v - h * p * d),
          (this._w = c * u * d + h * p * v);
        break;
      case "YZX":
        (this._x = h * u * d + c * p * v),
          (this._y = c * p * d + h * u * v),
          (this._z = c * u * v - h * p * d),
          (this._w = c * u * d - h * p * v);
        break;
      case "XZY":
        (this._x = h * u * d - c * p * v),
          (this._y = c * p * d - h * u * v),
          (this._z = c * u * v + h * p * d),
          (this._w = c * u * d + h * p * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return n === !0 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, n) {
    const i = n / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const n = e.elements,
      i = n[0],
      r = n[4],
      s = n[8],
      a = n[1],
      o = n[5],
      l = n[9],
      c = n[2],
      u = n[6],
      d = n[10],
      h = i + o + d;
    if (h > 0) {
      const p = 0.5 / Math.sqrt(h + 1);
      (this._w = 0.25 / p),
        (this._x = (u - l) * p),
        (this._y = (s - c) * p),
        (this._z = (a - r) * p);
    } else if (i > o && i > d) {
      const p = 2 * Math.sqrt(1 + i - o - d);
      (this._w = (u - l) / p),
        (this._x = 0.25 * p),
        (this._y = (r + a) / p),
        (this._z = (s + c) / p);
    } else if (o > d) {
      const p = 2 * Math.sqrt(1 + o - i - d);
      (this._w = (s - c) / p),
        (this._x = (r + a) / p),
        (this._y = 0.25 * p),
        (this._z = (l + u) / p);
    } else {
      const p = 2 * Math.sqrt(1 + d - i - o);
      (this._w = (a - r) / p),
        (this._x = (s + c) / p),
        (this._y = (l + u) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, n) {
    let i = e.dot(n) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * n.z - e.z * n.y),
          (this._y = e.z * n.x - e.x * n.z),
          (this._z = e.x * n.y - e.y * n.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Cn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, n) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, n / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, n) {
    const i = e._x,
      r = e._y,
      s = e._z,
      a = e._w,
      o = n._x,
      l = n._y,
      c = n._z,
      u = n._w;
    return (
      (this._x = i * u + a * o + r * c - s * l),
      (this._y = r * u + a * l + s * o - i * c),
      (this._z = s * u + a * c + i * l - r * o),
      (this._w = a * u - i * o - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, n) {
    if (n === 0) return this;
    if (n === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - n;
      return (
        (this._w = p * a + n * this._w),
        (this._x = p * i + n * this._x),
        (this._y = p * r + n * this._y),
        (this._z = p * s + n * this._z),
        this.normalize(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, o),
      d = Math.sin((1 - n) * u) / c,
      h = Math.sin(n * u) / c;
    return (
      (this._w = a * d + this._w * h),
      (this._x = i * d + this._x * h),
      (this._y = r * d + this._y * h),
      (this._z = s * d + this._z * h),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, n, i) {
    return this.copy(e).slerp(n, i);
  }
  random() {
    const e = 2 * Math.PI * Math.random(),
      n = 2 * Math.PI * Math.random(),
      i = Math.random(),
      r = Math.sqrt(1 - i),
      s = Math.sqrt(i);
    return this.set(
      r * Math.sin(e),
      r * Math.cos(e),
      s * Math.sin(n),
      s * Math.cos(n)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, n = 0) {
    return (
      (this._x = e[n]),
      (this._y = e[n + 1]),
      (this._z = e[n + 2]),
      (this._w = e[n + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, n) {
    return (
      (this._x = e.getX(n)),
      (this._y = e.getY(n)),
      (this._z = e.getZ(n)),
      (this._w = e.getW(n)),
      this._onChangeCallback(),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class z {
  constructor(e = 0, n = 0, i = 0) {
    (z.prototype.isVector3 = !0), (this.x = e), (this.y = n), (this.z = i);
  }
  set(e, n, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = n),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, n) {
    switch (e) {
      case 0:
        this.x = n;
        break;
      case 1:
        this.y = n;
        break;
      case 2:
        this.z = n;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, n) {
    return (
      (this.x = e.x + n.x), (this.y = e.y + n.y), (this.z = e.z + n.z), this
    );
  }
  addScaledVector(e, n) {
    return (this.x += e.x * n), (this.y += e.y * n), (this.z += e.z * n), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, n) {
    return (
      (this.x = e.x - n.x), (this.y = e.y - n.y), (this.z = e.z - n.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, n) {
    return (
      (this.x = e.x * n.x), (this.y = e.y * n.y), (this.z = e.z * n.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(Lx.setFromEuler(e));
  }
  applyAxisAngle(e, n) {
    return this.applyQuaternion(Lx.setFromAxisAngle(e, n));
  }
  applyMatrix3(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[3] * i + s[6] * r),
      (this.y = s[1] * n + s[4] * i + s[7] * r),
      (this.z = s[2] * n + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      a = 1 / (s[3] * n + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * n + s[4] * i + s[8] * r + s[12]) * a),
      (this.y = (s[1] * n + s[5] * i + s[9] * r + s[13]) * a),
      (this.z = (s[2] * n + s[6] * i + s[10] * r + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = 2 * (a * r - o * i),
      u = 2 * (o * n - s * r),
      d = 2 * (s * i - a * n);
    return (
      (this.x = n + l * c + a * d - o * u),
      (this.y = i + l * u + o * c - s * d),
      (this.z = r + l * d + s * u - a * c),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const n = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * n + s[4] * i + s[8] * r),
      (this.y = s[1] * n + s[5] * i + s[9] * r),
      (this.z = s[2] * n + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, n) {
    return (
      (this.x = Math.max(e.x, Math.min(n.x, this.x))),
      (this.y = Math.max(e.y, Math.min(n.y, this.y))),
      (this.z = Math.max(e.z, Math.min(n.z, this.z))),
      this
    );
  }
  clampScalar(e, n) {
    return (
      (this.x = Math.max(e, Math.min(n, this.x))),
      (this.y = Math.max(e, Math.min(n, this.y))),
      (this.z = Math.max(e, Math.min(n, this.z))),
      this
    );
  }
  clampLength(e, n) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(n, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, n) {
    return (
      (this.x += (e.x - this.x) * n),
      (this.y += (e.y - this.y) * n),
      (this.z += (e.z - this.z) * n),
      this
    );
  }
  lerpVectors(e, n, i) {
    return (
      (this.x = e.x + (n.x - e.x) * i),
      (this.y = e.y + (n.y - e.y) * i),
      (this.z = e.z + (n.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, n) {
    const i = e.x,
      r = e.y,
      s = e.z,
      a = n.x,
      o = n.y,
      l = n.z;
    return (
      (this.x = r * l - s * o),
      (this.y = s * a - i * l),
      (this.z = i * o - r * a),
      this
    );
  }
  projectOnVector(e) {
    const n = e.lengthSq();
    if (n === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / n;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return Ff.copy(this).projectOnVector(e), this.sub(Ff);
  }
  reflect(e) {
    return this.sub(Ff.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const n = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (n === 0) return Math.PI / 2;
    const i = this.dot(e) / n;
    return Math.acos(Cn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const n = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return n * n + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, n, i) {
    const r = Math.sin(n) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(n) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, n, i) {
    return (
      (this.x = e * Math.sin(n)), (this.y = i), (this.z = e * Math.cos(n)), this
    );
  }
  setFromMatrixPosition(e) {
    const n = e.elements;
    return (this.x = n[12]), (this.y = n[13]), (this.z = n[14]), this;
  }
  setFromMatrixScale(e) {
    const n = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = n), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, n) {
    return this.fromArray(e.elements, n * 4);
  }
  setFromMatrix3Column(e, n) {
    return this.fromArray(e.elements, n * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, n = 0) {
    return (this.x = e[n]), (this.y = e[n + 1]), (this.z = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.x), (e[n + 1] = this.y), (e[n + 2] = this.z), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.x = e.getX(n)), (this.y = e.getY(n)), (this.z = e.getZ(n)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = Math.random() * Math.PI * 2,
      n = Math.random() * 2 - 1,
      i = Math.sqrt(1 - n * n);
    return (
      (this.x = i * Math.cos(e)), (this.y = n), (this.z = i * Math.sin(e)), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Ff = new z(),
  Lx = new Cc();
class Rc {
  constructor(
    e = new z(1 / 0, 1 / 0, 1 / 0),
    n = new z(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = n);
  }
  set(e, n) {
    return this.min.copy(e), this.max.copy(n), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n += 3)
      this.expandByPoint(li.fromArray(e, n));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let n = 0, i = e.count; n < i; n++)
      this.expandByPoint(li.fromBufferAttribute(e, n));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let n = 0, i = e.length; n < i; n++) this.expandByPoint(e[n]);
    return this;
  }
  setFromCenterAndSize(e, n) {
    const i = li.copy(n).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, n = !1) {
    return this.makeEmpty(), this.expandByObject(e, n);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, n = !1) {
    e.updateWorldMatrix(!1, !1);
    const i = e.geometry;
    if (i !== void 0) {
      const s = i.getAttribute("position");
      if (n === !0 && s !== void 0 && e.isInstancedMesh !== !0)
        for (let a = 0, o = s.count; a < o; a++)
          e.isMesh === !0
            ? e.getVertexPosition(a, li)
            : li.fromBufferAttribute(s, a),
            li.applyMatrix4(e.matrixWorld),
            this.expandByPoint(li);
      else
        e.boundingBox !== void 0
          ? (e.boundingBox === null && e.computeBoundingBox(),
            ou.copy(e.boundingBox))
          : (i.boundingBox === null && i.computeBoundingBox(),
            ou.copy(i.boundingBox)),
          ou.applyMatrix4(e.matrixWorld),
          this.union(ou);
    }
    const r = e.children;
    for (let s = 0, a = r.length; s < a; s++) this.expandByObject(r[s], n);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, n) {
    return n.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, li),
      li.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let n, i;
    return (
      e.normal.x > 0
        ? ((n = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((n = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((n += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((n += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((n += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((n += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      n <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Zo),
      lu.subVectors(this.max, Zo),
      pa.subVectors(e.a, Zo),
      ma.subVectors(e.b, Zo),
      ga.subVectors(e.c, Zo),
      xr.subVectors(ma, pa),
      Sr.subVectors(ga, ma),
      _s.subVectors(pa, ga);
    let n = [
      0,
      -xr.z,
      xr.y,
      0,
      -Sr.z,
      Sr.y,
      0,
      -_s.z,
      _s.y,
      xr.z,
      0,
      -xr.x,
      Sr.z,
      0,
      -Sr.x,
      _s.z,
      0,
      -_s.x,
      -xr.y,
      xr.x,
      0,
      -Sr.y,
      Sr.x,
      0,
      -_s.y,
      _s.x,
      0,
    ];
    return !Bf(n, pa, ma, ga, lu) ||
      ((n = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Bf(n, pa, ma, ga, lu))
      ? !1
      : (cu.crossVectors(xr, Sr),
        (n = [cu.x, cu.y, cu.z]),
        Bf(n, pa, ma, ga, lu));
  }
  clampPoint(e, n) {
    return n.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, li).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(li).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Wi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Wi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Wi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Wi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Wi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Wi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Wi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Wi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Wi),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Wi = [
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
    new z(),
  ],
  li = new z(),
  ou = new Rc(),
  pa = new z(),
  ma = new z(),
  ga = new z(),
  xr = new z(),
  Sr = new z(),
  _s = new z(),
  Zo = new z(),
  lu = new z(),
  cu = new z(),
  ys = new z();
function Bf(t, e, n, i, r) {
  for (let s = 0, a = t.length - 3; s <= a; s += 3) {
    ys.fromArray(t, s);
    const o =
        r.x * Math.abs(ys.x) + r.y * Math.abs(ys.y) + r.z * Math.abs(ys.z),
      l = e.dot(ys),
      c = n.dot(ys),
      u = i.dot(ys);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
  }
  return !0;
}
const LO = new Rc(),
  Ko = new z(),
  zf = new z();
class Th {
  constructor(e = new z(), n = -1) {
    (this.isSphere = !0), (this.center = e), (this.radius = n);
  }
  set(e, n) {
    return this.center.copy(e), (this.radius = n), this;
  }
  setFromPoints(e, n) {
    const i = this.center;
    n !== void 0 ? i.copy(n) : LO.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, a = e.length; s < a; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const n = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= n * n;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, n) {
    const i = this.center.distanceToSquared(e);
    return (
      n.copy(e),
      i > this.radius * this.radius &&
        (n.sub(this.center).normalize(),
        n.multiplyScalar(this.radius).add(this.center)),
      n
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Ko.subVectors(e, this.center);
    const n = Ko.lengthSq();
    if (n > this.radius * this.radius) {
      const i = Math.sqrt(n),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(Ko, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (zf.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Ko.copy(e.center).add(zf)),
            this.expandByPoint(Ko.copy(e.center).sub(zf))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const $i = new z(),
  jf = new z(),
  uu = new z(),
  wr = new z(),
  Vf = new z(),
  du = new z(),
  Hf = new z();
class xM {
  constructor(e = new z(), n = new z(0, 0, -1)) {
    (this.origin = e), (this.direction = n);
  }
  set(e, n) {
    return this.origin.copy(e), this.direction.copy(n), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, n) {
    return n.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, $i)), this;
  }
  closestPointToPoint(e, n) {
    n.subVectors(e, this.origin);
    const i = n.dot(this.direction);
    return i < 0
      ? n.copy(this.origin)
      : n.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const n = $i.subVectors(e, this.origin).dot(this.direction);
    return n < 0
      ? this.origin.distanceToSquared(e)
      : ($i.copy(this.origin).addScaledVector(this.direction, n),
        $i.distanceToSquared(e));
  }
  distanceSqToSegment(e, n, i, r) {
    jf.copy(e).add(n).multiplyScalar(0.5),
      uu.copy(n).sub(e).normalize(),
      wr.copy(this.origin).sub(jf);
    const s = e.distanceTo(n) * 0.5,
      a = -this.direction.dot(uu),
      o = wr.dot(this.direction),
      l = -wr.dot(uu),
      c = wr.lengthSq(),
      u = Math.abs(1 - a * a);
    let d, h, p, v;
    if (u > 0)
      if (((d = a * l - o), (h = a * o - l), (v = s * u), d >= 0))
        if (h >= -v)
          if (h <= v) {
            const x = 1 / u;
            (d *= x),
              (h *= x),
              (p = d * (d + a * h + 2 * o) + h * (a * d + h + 2 * l) + c);
          } else
            (h = s),
              (d = Math.max(0, -(a * h + o))),
              (p = -d * d + h * (h + 2 * l) + c);
        else
          (h = -s),
            (d = Math.max(0, -(a * h + o))),
            (p = -d * d + h * (h + 2 * l) + c);
      else
        h <= -v
          ? ((d = Math.max(0, -(-a * s + o))),
            (h = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (p = -d * d + h * (h + 2 * l) + c))
          : h <= v
          ? ((d = 0),
            (h = Math.min(Math.max(-s, -l), s)),
            (p = h * (h + 2 * l) + c))
          : ((d = Math.max(0, -(a * s + o))),
            (h = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (p = -d * d + h * (h + 2 * l) + c));
    else
      (h = a > 0 ? -s : s),
        (d = Math.max(0, -(a * h + o))),
        (p = -d * d + h * (h + 2 * l) + c);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(jf).addScaledVector(uu, h),
      p
    );
  }
  intersectSphere(e, n) {
    $i.subVectors(e.center, this.origin);
    const i = $i.dot(this.direction),
      r = $i.dot($i) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const a = Math.sqrt(s - r),
      o = i - a,
      l = i + a;
    return l < 0 ? null : o < 0 ? this.at(l, n) : this.at(o, n);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const n = e.normal.dot(this.direction);
    if (n === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / n;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, n) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, n);
  }
  intersectsPlane(e) {
    const n = e.distanceToPoint(this.origin);
    return n === 0 || e.normal.dot(this.direction) * n < 0;
  }
  intersectBox(e, n) {
    let i, r, s, a, o, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      d = 1 / this.direction.z,
      h = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - h.x) * c), (r = (e.max.x - h.x) * c))
        : ((i = (e.max.x - h.x) * c), (r = (e.min.x - h.x) * c)),
      u >= 0
        ? ((s = (e.min.y - h.y) * u), (a = (e.max.y - h.y) * u))
        : ((s = (e.max.y - h.y) * u), (a = (e.min.y - h.y) * u)),
      i > a ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (a < r || isNaN(r)) && (r = a),
      d >= 0
        ? ((o = (e.min.z - h.z) * d), (l = (e.max.z - h.z) * d))
        : ((o = (e.max.z - h.z) * d), (l = (e.min.z - h.z) * d)),
      i > l || o > r) ||
      ((o > i || i !== i) && (i = o), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, n)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, $i) !== null;
  }
  intersectTriangle(e, n, i, r, s) {
    Vf.subVectors(n, e), du.subVectors(i, e), Hf.crossVectors(Vf, du);
    let a = this.direction.dot(Hf),
      o;
    if (a > 0) {
      if (r) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    wr.subVectors(this.origin, e);
    const l = o * this.direction.dot(du.crossVectors(wr, du));
    if (l < 0) return null;
    const c = o * this.direction.dot(Vf.cross(wr));
    if (c < 0 || l + c > a) return null;
    const u = -o * wr.dot(Hf);
    return u < 0 ? null : this.at(u / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Ft {
  constructor(e, n, i, r, s, a, o, l, c, u, d, h, p, v, x, m) {
    (Ft.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      e !== void 0 && this.set(e, n, i, r, s, a, o, l, c, u, d, h, p, v, x, m);
  }
  set(e, n, i, r, s, a, o, l, c, u, d, h, p, v, x, m) {
    const f = this.elements;
    return (
      (f[0] = e),
      (f[4] = n),
      (f[8] = i),
      (f[12] = r),
      (f[1] = s),
      (f[5] = a),
      (f[9] = o),
      (f[13] = l),
      (f[2] = c),
      (f[6] = u),
      (f[10] = d),
      (f[14] = h),
      (f[3] = p),
      (f[7] = v),
      (f[11] = x),
      (f[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Ft().fromArray(this.elements);
  }
  copy(e) {
    const n = this.elements,
      i = e.elements;
    return (
      (n[0] = i[0]),
      (n[1] = i[1]),
      (n[2] = i[2]),
      (n[3] = i[3]),
      (n[4] = i[4]),
      (n[5] = i[5]),
      (n[6] = i[6]),
      (n[7] = i[7]),
      (n[8] = i[8]),
      (n[9] = i[9]),
      (n[10] = i[10]),
      (n[11] = i[11]),
      (n[12] = i[12]),
      (n[13] = i[13]),
      (n[14] = i[14]),
      (n[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const n = this.elements,
      i = e.elements;
    return (n[12] = i[12]), (n[13] = i[13]), (n[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const n = e.elements;
    return (
      this.set(
        n[0],
        n[3],
        n[6],
        0,
        n[1],
        n[4],
        n[7],
        0,
        n[2],
        n[5],
        n[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, n, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      n.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, n, i) {
    return (
      this.set(
        e.x,
        n.x,
        i.x,
        0,
        e.y,
        n.y,
        i.y,
        0,
        e.z,
        n.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const n = this.elements,
      i = e.elements,
      r = 1 / va.setFromMatrixColumn(e, 0).length(),
      s = 1 / va.setFromMatrixColumn(e, 1).length(),
      a = 1 / va.setFromMatrixColumn(e, 2).length();
    return (
      (n[0] = i[0] * r),
      (n[1] = i[1] * r),
      (n[2] = i[2] * r),
      (n[3] = 0),
      (n[4] = i[4] * s),
      (n[5] = i[5] * s),
      (n[6] = i[6] * s),
      (n[7] = 0),
      (n[8] = i[8] * a),
      (n[9] = i[9] * a),
      (n[10] = i[10] * a),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const n = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      a = Math.cos(i),
      o = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      u = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const h = a * u,
        p = a * d,
        v = o * u,
        x = o * d;
      (n[0] = l * u),
        (n[4] = -l * d),
        (n[8] = c),
        (n[1] = p + v * c),
        (n[5] = h - x * c),
        (n[9] = -o * l),
        (n[2] = x - h * c),
        (n[6] = v + p * c),
        (n[10] = a * l);
    } else if (e.order === "YXZ") {
      const h = l * u,
        p = l * d,
        v = c * u,
        x = c * d;
      (n[0] = h + x * o),
        (n[4] = v * o - p),
        (n[8] = a * c),
        (n[1] = a * d),
        (n[5] = a * u),
        (n[9] = -o),
        (n[2] = p * o - v),
        (n[6] = x + h * o),
        (n[10] = a * l);
    } else if (e.order === "ZXY") {
      const h = l * u,
        p = l * d,
        v = c * u,
        x = c * d;
      (n[0] = h - x * o),
        (n[4] = -a * d),
        (n[8] = v + p * o),
        (n[1] = p + v * o),
        (n[5] = a * u),
        (n[9] = x - h * o),
        (n[2] = -a * c),
        (n[6] = o),
        (n[10] = a * l);
    } else if (e.order === "ZYX") {
      const h = a * u,
        p = a * d,
        v = o * u,
        x = o * d;
      (n[0] = l * u),
        (n[4] = v * c - p),
        (n[8] = h * c + x),
        (n[1] = l * d),
        (n[5] = x * c + h),
        (n[9] = p * c - v),
        (n[2] = -c),
        (n[6] = o * l),
        (n[10] = a * l);
    } else if (e.order === "YZX") {
      const h = a * l,
        p = a * c,
        v = o * l,
        x = o * c;
      (n[0] = l * u),
        (n[4] = x - h * d),
        (n[8] = v * d + p),
        (n[1] = d),
        (n[5] = a * u),
        (n[9] = -o * u),
        (n[2] = -c * u),
        (n[6] = p * d + v),
        (n[10] = h - x * d);
    } else if (e.order === "XZY") {
      const h = a * l,
        p = a * c,
        v = o * l,
        x = o * c;
      (n[0] = l * u),
        (n[4] = -d),
        (n[8] = c * u),
        (n[1] = h * d + x),
        (n[5] = a * u),
        (n[9] = p * d - v),
        (n[2] = v * d - p),
        (n[6] = o * u),
        (n[10] = x * d + h);
    }
    return (
      (n[3] = 0),
      (n[7] = 0),
      (n[11] = 0),
      (n[12] = 0),
      (n[13] = 0),
      (n[14] = 0),
      (n[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(NO, e, DO);
  }
  lookAt(e, n, i) {
    const r = this.elements;
    return (
      On.subVectors(e, n),
      On.lengthSq() === 0 && (On.z = 1),
      On.normalize(),
      Er.crossVectors(i, On),
      Er.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (On.x += 1e-4) : (On.z += 1e-4),
        On.normalize(),
        Er.crossVectors(i, On)),
      Er.normalize(),
      hu.crossVectors(On, Er),
      (r[0] = Er.x),
      (r[4] = hu.x),
      (r[8] = On.x),
      (r[1] = Er.y),
      (r[5] = hu.y),
      (r[9] = On.y),
      (r[2] = Er.z),
      (r[6] = hu.z),
      (r[10] = On.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, n) {
    const i = e.elements,
      r = n.elements,
      s = this.elements,
      a = i[0],
      o = i[4],
      l = i[8],
      c = i[12],
      u = i[1],
      d = i[5],
      h = i[9],
      p = i[13],
      v = i[2],
      x = i[6],
      m = i[10],
      f = i[14],
      y = i[3],
      g = i[7],
      S = i[11],
      T = i[15],
      A = r[0],
      b = r[4],
      P = r[8],
      G = r[12],
      w = r[1],
      R = r[5],
      ie = r[9],
      J = r[13],
      D = r[2],
      Y = r[6],
      q = r[10],
      W = r[14],
      L = r[3],
      U = r[7],
      X = r[11],
      K = r[15];
    return (
      (s[0] = a * A + o * w + l * D + c * L),
      (s[4] = a * b + o * R + l * Y + c * U),
      (s[8] = a * P + o * ie + l * q + c * X),
      (s[12] = a * G + o * J + l * W + c * K),
      (s[1] = u * A + d * w + h * D + p * L),
      (s[5] = u * b + d * R + h * Y + p * U),
      (s[9] = u * P + d * ie + h * q + p * X),
      (s[13] = u * G + d * J + h * W + p * K),
      (s[2] = v * A + x * w + m * D + f * L),
      (s[6] = v * b + x * R + m * Y + f * U),
      (s[10] = v * P + x * ie + m * q + f * X),
      (s[14] = v * G + x * J + m * W + f * K),
      (s[3] = y * A + g * w + S * D + T * L),
      (s[7] = y * b + g * R + S * Y + T * U),
      (s[11] = y * P + g * ie + S * q + T * X),
      (s[15] = y * G + g * J + S * W + T * K),
      this
    );
  }
  multiplyScalar(e) {
    const n = this.elements;
    return (
      (n[0] *= e),
      (n[4] *= e),
      (n[8] *= e),
      (n[12] *= e),
      (n[1] *= e),
      (n[5] *= e),
      (n[9] *= e),
      (n[13] *= e),
      (n[2] *= e),
      (n[6] *= e),
      (n[10] *= e),
      (n[14] *= e),
      (n[3] *= e),
      (n[7] *= e),
      (n[11] *= e),
      (n[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      n = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      d = e[6],
      h = e[10],
      p = e[14],
      v = e[3],
      x = e[7],
      m = e[11],
      f = e[15];
    return (
      v *
        (+s * l * d -
          r * c * d -
          s * o * h +
          i * c * h +
          r * o * p -
          i * l * p) +
      x *
        (+n * l * p -
          n * c * h +
          s * a * h -
          r * a * p +
          r * c * u -
          s * l * u) +
      m *
        (+n * c * d -
          n * o * p -
          s * a * d +
          i * a * p +
          s * o * u -
          i * c * u) +
      f *
        (-r * o * u - n * l * d + n * o * h + r * a * d - i * a * h + i * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let n;
    return (
      (n = e[1]),
      (e[1] = e[4]),
      (e[4] = n),
      (n = e[2]),
      (e[2] = e[8]),
      (e[8] = n),
      (n = e[6]),
      (e[6] = e[9]),
      (e[9] = n),
      (n = e[3]),
      (e[3] = e[12]),
      (e[12] = n),
      (n = e[7]),
      (e[7] = e[13]),
      (e[13] = n),
      (n = e[11]),
      (e[11] = e[14]),
      (e[14] = n),
      this
    );
  }
  setPosition(e, n, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = n), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      n = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      d = e[9],
      h = e[10],
      p = e[11],
      v = e[12],
      x = e[13],
      m = e[14],
      f = e[15],
      y = d * m * c - x * h * c + x * l * p - o * m * p - d * l * f + o * h * f,
      g = v * h * c - u * m * c - v * l * p + a * m * p + u * l * f - a * h * f,
      S = u * x * c - v * d * c + v * o * p - a * x * p - u * o * f + a * d * f,
      T = v * d * l - u * x * l - v * o * h + a * x * h + u * o * m - a * d * m,
      A = n * y + i * g + r * S + s * T;
    if (A === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const b = 1 / A;
    return (
      (e[0] = y * b),
      (e[1] =
        (x * h * s -
          d * m * s -
          x * r * p +
          i * m * p +
          d * r * f -
          i * h * f) *
        b),
      (e[2] =
        (o * m * s -
          x * l * s +
          x * r * c -
          i * m * c -
          o * r * f +
          i * l * f) *
        b),
      (e[3] =
        (d * l * s -
          o * h * s -
          d * r * c +
          i * h * c +
          o * r * p -
          i * l * p) *
        b),
      (e[4] = g * b),
      (e[5] =
        (u * m * s -
          v * h * s +
          v * r * p -
          n * m * p -
          u * r * f +
          n * h * f) *
        b),
      (e[6] =
        (v * l * s -
          a * m * s -
          v * r * c +
          n * m * c +
          a * r * f -
          n * l * f) *
        b),
      (e[7] =
        (a * h * s -
          u * l * s +
          u * r * c -
          n * h * c -
          a * r * p +
          n * l * p) *
        b),
      (e[8] = S * b),
      (e[9] =
        (v * d * s -
          u * x * s -
          v * i * p +
          n * x * p +
          u * i * f -
          n * d * f) *
        b),
      (e[10] =
        (a * x * s -
          v * o * s +
          v * i * c -
          n * x * c -
          a * i * f +
          n * o * f) *
        b),
      (e[11] =
        (u * o * s -
          a * d * s -
          u * i * c +
          n * d * c +
          a * i * p -
          n * o * p) *
        b),
      (e[12] = T * b),
      (e[13] =
        (u * x * r -
          v * d * r +
          v * i * h -
          n * x * h -
          u * i * m +
          n * d * m) *
        b),
      (e[14] =
        (v * o * r -
          a * x * r -
          v * i * l +
          n * x * l +
          a * i * m -
          n * o * m) *
        b),
      (e[15] =
        (a * d * r -
          u * o * r +
          u * i * l -
          n * d * l -
          a * i * h +
          n * o * h) *
        b),
      this
    );
  }
  scale(e) {
    const n = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (n[0] *= i),
      (n[4] *= r),
      (n[8] *= s),
      (n[1] *= i),
      (n[5] *= r),
      (n[9] *= s),
      (n[2] *= i),
      (n[6] *= r),
      (n[10] *= s),
      (n[3] *= i),
      (n[7] *= r),
      (n[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      n = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(n, i, r));
  }
  makeTranslation(e, n, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, n, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, n, -i, 0, 0, i, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, 0, i, 0, 0, 1, 0, 0, -i, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const n = Math.cos(e),
      i = Math.sin(e);
    return this.set(n, -i, 0, 0, i, n, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, n) {
    const i = Math.cos(n),
      r = Math.sin(n),
      s = 1 - i,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      u = s * o;
    return (
      this.set(
        c * a + i,
        c * o - r * l,
        c * l + r * o,
        0,
        c * o + r * l,
        u * o + i,
        u * l - r * a,
        0,
        c * l - r * o,
        u * l + r * a,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, n, i) {
    return this.set(e, 0, 0, 0, 0, n, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, n, i, r, s, a) {
    return this.set(1, i, s, 0, e, 1, a, 0, n, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, n, i) {
    const r = this.elements,
      s = n._x,
      a = n._y,
      o = n._z,
      l = n._w,
      c = s + s,
      u = a + a,
      d = o + o,
      h = s * c,
      p = s * u,
      v = s * d,
      x = a * u,
      m = a * d,
      f = o * d,
      y = l * c,
      g = l * u,
      S = l * d,
      T = i.x,
      A = i.y,
      b = i.z;
    return (
      (r[0] = (1 - (x + f)) * T),
      (r[1] = (p + S) * T),
      (r[2] = (v - g) * T),
      (r[3] = 0),
      (r[4] = (p - S) * A),
      (r[5] = (1 - (h + f)) * A),
      (r[6] = (m + y) * A),
      (r[7] = 0),
      (r[8] = (v + g) * b),
      (r[9] = (m - y) * b),
      (r[10] = (1 - (h + x)) * b),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, n, i) {
    const r = this.elements;
    let s = va.set(r[0], r[1], r[2]).length();
    const a = va.set(r[4], r[5], r[6]).length(),
      o = va.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      ci.copy(this);
    const c = 1 / s,
      u = 1 / a,
      d = 1 / o;
    return (
      (ci.elements[0] *= c),
      (ci.elements[1] *= c),
      (ci.elements[2] *= c),
      (ci.elements[4] *= u),
      (ci.elements[5] *= u),
      (ci.elements[6] *= u),
      (ci.elements[8] *= d),
      (ci.elements[9] *= d),
      (ci.elements[10] *= d),
      n.setFromRotationMatrix(ci),
      (i.x = s),
      (i.y = a),
      (i.z = o),
      this
    );
  }
  makePerspective(e, n, i, r, s, a, o = ar) {
    const l = this.elements,
      c = (2 * s) / (n - e),
      u = (2 * s) / (i - r),
      d = (n + e) / (n - e),
      h = (i + r) / (i - r);
    let p, v;
    if (o === ar) (p = -(a + s) / (a - s)), (v = (-2 * a * s) / (a - s));
    else if (o === jd) (p = -a / (a - s)), (v = (-a * s) / (a - s));
    else
      throw new Error(
        "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = c),
      (l[4] = 0),
      (l[8] = d),
      (l[12] = 0),
      (l[1] = 0),
      (l[5] = u),
      (l[9] = h),
      (l[13] = 0),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = p),
      (l[14] = v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = -1),
      (l[15] = 0),
      this
    );
  }
  makeOrthographic(e, n, i, r, s, a, o = ar) {
    const l = this.elements,
      c = 1 / (n - e),
      u = 1 / (i - r),
      d = 1 / (a - s),
      h = (n + e) * c,
      p = (i + r) * u;
    let v, x;
    if (o === ar) (v = (a + s) * d), (x = -2 * d);
    else if (o === jd) (v = s * d), (x = -1 * d);
    else
      throw new Error(
        "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + o
      );
    return (
      (l[0] = 2 * c),
      (l[4] = 0),
      (l[8] = 0),
      (l[12] = -h),
      (l[1] = 0),
      (l[5] = 2 * u),
      (l[9] = 0),
      (l[13] = -p),
      (l[2] = 0),
      (l[6] = 0),
      (l[10] = x),
      (l[14] = -v),
      (l[3] = 0),
      (l[7] = 0),
      (l[11] = 0),
      (l[15] = 1),
      this
    );
  }
  equals(e) {
    const n = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (n[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, n = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + n];
    return this;
  }
  toArray(e = [], n = 0) {
    const i = this.elements;
    return (
      (e[n] = i[0]),
      (e[n + 1] = i[1]),
      (e[n + 2] = i[2]),
      (e[n + 3] = i[3]),
      (e[n + 4] = i[4]),
      (e[n + 5] = i[5]),
      (e[n + 6] = i[6]),
      (e[n + 7] = i[7]),
      (e[n + 8] = i[8]),
      (e[n + 9] = i[9]),
      (e[n + 10] = i[10]),
      (e[n + 11] = i[11]),
      (e[n + 12] = i[12]),
      (e[n + 13] = i[13]),
      (e[n + 14] = i[14]),
      (e[n + 15] = i[15]),
      e
    );
  }
}
const va = new z(),
  ci = new Ft(),
  NO = new z(0, 0, 0),
  DO = new z(1, 1, 1),
  Er = new z(),
  hu = new z(),
  On = new z(),
  Nx = new Ft(),
  Dx = new Cc();
class gr {
  constructor(e = 0, n = 0, i = 0, r = gr.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, n, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = n),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, n = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      a = r[4],
      o = r[8],
      l = r[1],
      c = r[5],
      u = r[9],
      d = r[2],
      h = r[6],
      p = r[10];
    switch (n) {
      case "XYZ":
        (this._y = Math.asin(Cn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(h, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-Cn(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(o, p)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(Cn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(-d, p)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-Cn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(h, p)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin(Cn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-Cn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(h, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-u, p)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            n
        );
    }
    return (this._order = n), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, n, i) {
    return (
      Nx.makeRotationFromQuaternion(e), this.setFromRotationMatrix(Nx, n, i)
    );
  }
  setFromVector3(e, n = this._order) {
    return this.set(e.x, e.y, e.z, n);
  }
  reorder(e) {
    return Dx.setFromEuler(this), this.setFromQuaternion(Dx, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], n = 0) {
    return (
      (e[n] = this._x),
      (e[n + 1] = this._y),
      (e[n + 2] = this._z),
      (e[n + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
gr.DEFAULT_ORDER = "XYZ";
class SM {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let kO = 0;
const kx = new z(),
  _a = new Cc(),
  Xi = new Ft(),
  fu = new z(),
  Jo = new z(),
  IO = new z(),
  UO = new Cc(),
  Ix = new z(1, 0, 0),
  Ux = new z(0, 1, 0),
  Ox = new z(0, 0, 1),
  OO = {
    type: "added",
  },
  FO = {
    type: "removed",
  },
  Gf = {
    type: "childadded",
    child: null,
  },
  Wf = {
    type: "childremoved",
    child: null,
  };
class In extends ko {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", {
        value: kO++,
      }),
      (this.uuid = Ac()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = In.DEFAULT_UP.clone());
    const e = new z(),
      n = new gr(),
      i = new Cc(),
      r = new z(1, 1, 1);
    function s() {
      i.setFromEuler(n, !1);
    }
    function a() {
      n.setFromQuaternion(i, void 0, !1);
    }
    n._onChange(s),
      i._onChange(a),
      Object.defineProperties(this, {
        position: {
          configurable: !0,
          enumerable: !0,
          value: e,
        },
        rotation: {
          configurable: !0,
          enumerable: !0,
          value: n,
        },
        quaternion: {
          configurable: !0,
          enumerable: !0,
          value: i,
        },
        scale: {
          configurable: !0,
          enumerable: !0,
          value: r,
        },
        modelViewMatrix: {
          value: new Ft(),
        },
        normalMatrix: {
          value: new $e(),
        },
      }),
      (this.matrix = new Ft()),
      (this.matrixWorld = new Ft()),
      (this.matrixAutoUpdate = In.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldAutoUpdate = In.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new SM()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeShadow() {}
  onAfterShadow() {}
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, n) {
    this.quaternion.setFromAxisAngle(e, n);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, n) {
    return _a.setFromAxisAngle(e, n), this.quaternion.multiply(_a), this;
  }
  rotateOnWorldAxis(e, n) {
    return _a.setFromAxisAngle(e, n), this.quaternion.premultiply(_a), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(Ix, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(Ux, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(Ox, e);
  }
  translateOnAxis(e, n) {
    return (
      kx.copy(e).applyQuaternion(this.quaternion),
      this.position.add(kx.multiplyScalar(n)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(Ix, e);
  }
  translateY(e) {
    return this.translateOnAxis(Ux, e);
  }
  translateZ(e) {
    return this.translateOnAxis(Ox, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Xi.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, n, i) {
    e.isVector3 ? fu.copy(e) : fu.set(e, n, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Jo.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Xi.lookAt(Jo, fu, this.up)
        : Xi.lookAt(fu, Jo, this.up),
      this.quaternion.setFromRotationMatrix(Xi),
      r &&
        (Xi.extractRotation(r.matrixWorld),
        _a.setFromRotationMatrix(Xi),
        this.quaternion.premultiply(_a.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.add(arguments[n]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(OO),
            (Gf.child = e),
            this.dispatchEvent(Gf),
            (Gf.child = null))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const n = this.children.indexOf(e);
    return (
      n !== -1 &&
        ((e.parent = null),
        this.children.splice(n, 1),
        e.dispatchEvent(FO),
        (Wf.child = e),
        this.dispatchEvent(Wf),
        (Wf.child = null)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Xi.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Xi.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Xi),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, n) {
    if (this[e] === n) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const a = this.children[i].getObjectByProperty(e, n);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, n, i = []) {
    this[e] === n && i.push(this);
    const r = this.children;
    for (let s = 0, a = r.length; s < a; s++)
      r[s].getObjectsByProperty(e, n, i);
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jo, e, IO), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Jo, UO, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const n = this.matrixWorld.elements;
    return e.set(n[8], n[9], n[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) n[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) n[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const n = this.parent;
    n !== null && (e(n), n.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const n = this.children;
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, n) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      n === !0)
    ) {
      const r = this.children;
      for (let s = 0, a = r.length; s < a; s++) {
        const o = r[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string",
      i = {};
    n &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON())),
      this.isBatchedMesh &&
        ((r.type = "BatchedMesh"),
        (r.perObjectFrustumCulled = this.perObjectFrustumCulled),
        (r.sortObjects = this.sortObjects),
        (r.drawRanges = this._drawRanges),
        (r.reservedRanges = this._reservedRanges),
        (r.visibility = this._visibility),
        (r.active = this._active),
        (r.bounds = this._bounds.map((o) => ({
          boxInitialized: o.boxInitialized,
          boxMin: o.box.min.toArray(),
          boxMax: o.box.max.toArray(),
          sphereInitialized: o.sphereInitialized,
          sphereRadius: o.sphere.radius,
          sphereCenter: o.sphere.center.toArray(),
        }))),
        (r.maxGeometryCount = this._maxGeometryCount),
        (r.maxVertexCount = this._maxVertexCount),
        (r.maxIndexCount = this._maxIndexCount),
        (r.geometryInitialized = this._geometryInitialized),
        (r.geometryCount = this._geometryCount),
        (r.matricesTexture = this._matricesTexture.toJSON(e)),
        this.boundingSphere !== null &&
          (r.boundingSphere = {
            center: r.boundingSphere.center.toArray(),
            radius: r.boundingSphere.radius,
          }),
        this.boundingBox !== null &&
          (r.boundingBox = {
            min: r.boundingBox.min.toArray(),
            max: r.boundingBox.max.toArray(),
          }));
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const d = l[c];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        r.material = o;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let o = 0; o < this.children.length; o++)
        r.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        r.animations.push(s(e.animations, l));
      }
    }
    if (n) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        d = a(e.shapes),
        h = a(e.skeletons),
        p = a(e.animations),
        v = a(e.nodes);
      o.length > 0 && (i.geometries = o),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        u.length > 0 && (i.images = u),
        d.length > 0 && (i.shapes = d),
        h.length > 0 && (i.skeletons = h),
        p.length > 0 && (i.animations = p),
        v.length > 0 && (i.nodes = v);
    }
    return (i.object = r), i;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, n = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      n === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
In.DEFAULT_UP = new z(0, 1, 0);
In.DEFAULT_MATRIX_AUTO_UPDATE = !0;
In.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ui = new z(),
  qi = new z(),
  $f = new z(),
  Yi = new z(),
  ya = new z(),
  xa = new z(),
  Fx = new z(),
  Xf = new z(),
  qf = new z(),
  Yf = new z();
class ki {
  constructor(e = new z(), n = new z(), i = new z()) {
    (this.a = e), (this.b = n), (this.c = i);
  }
  static getNormal(e, n, i, r) {
    r.subVectors(i, n), ui.subVectors(e, n), r.cross(ui);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, n, i, r, s) {
    ui.subVectors(r, n), qi.subVectors(i, n), $f.subVectors(e, n);
    const a = ui.dot(ui),
      o = ui.dot(qi),
      l = ui.dot($f),
      c = qi.dot(qi),
      u = qi.dot($f),
      d = a * c - o * o;
    if (d === 0) return s.set(0, 0, 0), null;
    const h = 1 / d,
      p = (c * l - o * u) * h,
      v = (a * u - o * l) * h;
    return s.set(1 - p - v, v, p);
  }
  static containsPoint(e, n, i, r) {
    return this.getBarycoord(e, n, i, r, Yi) === null
      ? !1
      : Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1;
  }
  static getInterpolation(e, n, i, r, s, a, o, l) {
    return this.getBarycoord(e, n, i, r, Yi) === null
      ? ((l.x = 0),
        (l.y = 0),
        "z" in l && (l.z = 0),
        "w" in l && (l.w = 0),
        null)
      : (l.setScalar(0),
        l.addScaledVector(s, Yi.x),
        l.addScaledVector(a, Yi.y),
        l.addScaledVector(o, Yi.z),
        l);
  }
  static isFrontFacing(e, n, i, r) {
    return ui.subVectors(i, n), qi.subVectors(e, n), ui.cross(qi).dot(r) < 0;
  }
  set(e, n, i) {
    return this.a.copy(e), this.b.copy(n), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, n, i, r) {
    return this.a.copy(e[n]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, n, i, r) {
    return (
      this.a.fromBufferAttribute(e, n),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      ui.subVectors(this.c, this.b),
      qi.subVectors(this.a, this.b),
      ui.cross(qi).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return ki.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, n) {
    return ki.getBarycoord(e, this.a, this.b, this.c, n);
  }
  getInterpolation(e, n, i, r, s) {
    return ki.getInterpolation(e, this.a, this.b, this.c, n, i, r, s);
  }
  containsPoint(e) {
    return ki.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return ki.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, n) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let a, o;
    ya.subVectors(r, i), xa.subVectors(s, i), Xf.subVectors(e, i);
    const l = ya.dot(Xf),
      c = xa.dot(Xf);
    if (l <= 0 && c <= 0) return n.copy(i);
    qf.subVectors(e, r);
    const u = ya.dot(qf),
      d = xa.dot(qf);
    if (u >= 0 && d <= u) return n.copy(r);
    const h = l * d - u * c;
    if (h <= 0 && l >= 0 && u <= 0)
      return (a = l / (l - u)), n.copy(i).addScaledVector(ya, a);
    Yf.subVectors(e, s);
    const p = ya.dot(Yf),
      v = xa.dot(Yf);
    if (v >= 0 && p <= v) return n.copy(s);
    const x = p * c - l * v;
    if (x <= 0 && c >= 0 && v <= 0)
      return (o = c / (c - v)), n.copy(i).addScaledVector(xa, o);
    const m = u * v - p * d;
    if (m <= 0 && d - u >= 0 && p - v >= 0)
      return (
        Fx.subVectors(s, r),
        (o = (d - u) / (d - u + (p - v))),
        n.copy(r).addScaledVector(Fx, o)
      );
    const f = 1 / (m + x + h);
    return (
      (a = x * f),
      (o = h * f),
      n.copy(i).addScaledVector(ya, a).addScaledVector(xa, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
const wM = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Tr = {
    h: 0,
    s: 0,
    l: 0,
  },
  pu = {
    h: 0,
    s: 0,
    l: 0,
  };
function Zf(t, e, n) {
  return (
    n < 0 && (n += 1),
    n > 1 && (n -= 1),
    n < 1 / 6
      ? t + (e - t) * 6 * n
      : n < 1 / 2
      ? e
      : n < 2 / 3
      ? t + (e - t) * 6 * (2 / 3 - n)
      : t
  );
}
class ct {
  constructor(e, n, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, n, i)
    );
  }
  set(e, n, i) {
    if (n === void 0 && i === void 0) {
      const r = e;
      r && r.isColor
        ? this.copy(r)
        : typeof r == "number"
        ? this.setHex(r)
        : typeof r == "string" && this.setStyle(r);
    } else this.setRGB(e, n, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, n = Li) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      dt.toWorkingColorSpace(this, n),
      this
    );
  }
  setRGB(e, n, i, r = dt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = n),
      (this.b = i),
      dt.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, n, i, r = dt.workingColorSpace) {
    if (((e = EO(e, 1)), (n = Cn(n, 0, 1)), (i = Cn(i, 0, 1)), n === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + n) : i + n - i * n,
        a = 2 * i - s;
      (this.r = Zf(a, s, e + 1 / 3)),
        (this.g = Zf(a, s, e)),
        (this.b = Zf(a, s, e - 1 / 3));
    }
    return dt.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, n = Li) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = r[1],
        o = r[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                n
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                n
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                n
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          n
        );
      if (a === 6) return this.setHex(parseInt(s, 16), n);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, n);
    return this;
  }
  setColorName(e, n = Li) {
    const i = wM[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, n)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = so(e.r)), (this.g = so(e.g)), (this.b = so(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Uf(e.r)), (this.g = Uf(e.g)), (this.b = Uf(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Li) {
    return (
      dt.fromWorkingColorSpace(on.copy(this), e),
      Math.round(Cn(on.r * 255, 0, 255)) * 65536 +
        Math.round(Cn(on.g * 255, 0, 255)) * 256 +
        Math.round(Cn(on.b * 255, 0, 255))
    );
  }
  getHexString(e = Li) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, n = dt.workingColorSpace) {
    dt.fromWorkingColorSpace(on.copy(this), n);
    const i = on.r,
      r = on.g,
      s = on.b,
      a = Math.max(i, r, s),
      o = Math.min(i, r, s);
    let l, c;
    const u = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const d = a - o;
      switch (((c = u <= 0.5 ? d / (a + o) : d / (2 - a - o)), a)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, n = dt.workingColorSpace) {
    return (
      dt.fromWorkingColorSpace(on.copy(this), n),
      (e.r = on.r),
      (e.g = on.g),
      (e.b = on.b),
      e
    );
  }
  getStyle(e = Li) {
    dt.fromWorkingColorSpace(on.copy(this), e);
    const n = on.r,
      i = on.g,
      r = on.b;
    return e !== Li
      ? `color(${e} ${n.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${Math.round(n * 255)},${Math.round(i * 255)},${Math.round(
          r * 255
        )})`;
  }
  offsetHSL(e, n, i) {
    return this.getHSL(Tr), this.setHSL(Tr.h + e, Tr.s + n, Tr.l + i);
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, n) {
    return (
      (this.r = e.r + n.r), (this.g = e.g + n.g), (this.b = e.b + n.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, n) {
    return (
      (this.r += (e.r - this.r) * n),
      (this.g += (e.g - this.g) * n),
      (this.b += (e.b - this.b) * n),
      this
    );
  }
  lerpColors(e, n, i) {
    return (
      (this.r = e.r + (n.r - e.r) * i),
      (this.g = e.g + (n.g - e.g) * i),
      (this.b = e.b + (n.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, n) {
    this.getHSL(Tr), e.getHSL(pu);
    const i = kf(Tr.h, pu.h, n),
      r = kf(Tr.s, pu.s, n),
      s = kf(Tr.l, pu.l, n);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const n = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * n + s[3] * i + s[6] * r),
      (this.g = s[1] * n + s[4] * i + s[7] * r),
      (this.b = s[2] * n + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, n = 0) {
    return (this.r = e[n]), (this.g = e[n + 1]), (this.b = e[n + 2]), this;
  }
  toArray(e = [], n = 0) {
    return (e[n] = this.r), (e[n + 1] = this.g), (e[n + 2] = this.b), e;
  }
  fromBufferAttribute(e, n) {
    return (
      (this.r = e.getX(n)), (this.g = e.getY(n)), (this.b = e.getZ(n)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const on = new ct();
ct.NAMES = wM;
let BO = 0;
class Pc extends ko {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", {
        value: BO++,
      }),
      (this.uuid = Ac()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = ro),
      (this.side = as),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.alphaHash = !1),
      (this.blendSrc = Dm),
      (this.blendDst = km),
      (this.blendEquation = Ns),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.blendColor = new ct(0, 0, 0)),
      (this.blendAlpha = 0),
      (this.depthFunc = Od),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Tx),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = ha),
      (this.stencilZFail = ha),
      (this.stencilZPass = ha),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const n in e) {
        const i = e[n];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${n}' has value of undefined.`
          );
          continue;
        }
        const r = this[n];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${n}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[n] = i);
      }
  }
  toJSON(e) {
    const n = e === void 0 || typeof e == "string";
    n &&
      (e = {
        textures: {},
        images: {},
      });
    const i = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity !== void 0 &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy),
      this.anisotropyRotation !== void 0 &&
        (i.anisotropyRotation = this.anisotropyRotation),
      this.anisotropyMap &&
        this.anisotropyMap.isTexture &&
        (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapRotation !== void 0 &&
        (i.envMapRotation = this.envMapRotation.toArray()),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== ro && (i.blending = this.blending),
      this.side !== as && (i.side = this.side),
      this.vertexColors === !0 && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = !0),
      this.blendSrc !== Dm && (i.blendSrc = this.blendSrc),
      this.blendDst !== km && (i.blendDst = this.blendDst),
      this.blendEquation !== Ns && (i.blendEquation = this.blendEquation),
      this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha),
      this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha),
      this.blendEquationAlpha !== null &&
        (i.blendEquationAlpha = this.blendEquationAlpha),
      this.blendColor &&
        this.blendColor.isColor &&
        (i.blendColor = this.blendColor.getHex()),
      this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha),
      this.depthFunc !== Od && (i.depthFunc = this.depthFunc),
      this.depthTest === !1 && (i.depthTest = this.depthTest),
      this.depthWrite === !1 && (i.depthWrite = this.depthWrite),
      this.colorWrite === !1 && (i.colorWrite = this.colorWrite),
      this.stencilWriteMask !== 255 &&
        (i.stencilWriteMask = this.stencilWriteMask),
      this.stencilFunc !== Tx && (i.stencilFunc = this.stencilFunc),
      this.stencilRef !== 0 && (i.stencilRef = this.stencilRef),
      this.stencilFuncMask !== 255 &&
        (i.stencilFuncMask = this.stencilFuncMask),
      this.stencilFail !== ha && (i.stencilFail = this.stencilFail),
      this.stencilZFail !== ha && (i.stencilZFail = this.stencilZFail),
      this.stencilZPass !== ha && (i.stencilZPass = this.stencilZPass),
      this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaHash === !0 && (i.alphaHash = !0),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = !0),
      this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0),
      this.forceSinglePass === !0 && (i.forceSinglePass = !0),
      this.wireframe === !0 && (i.wireframe = !0),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = !0),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (n) {
      const s = r(e.textures),
        a = r(e.images);
      s.length > 0 && (i.textures = s), a.length > 0 && (i.images = a);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      this.blendColor.copy(e.blendColor),
      (this.blendAlpha = e.blendAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const n = e.clippingPlanes;
    let i = null;
    if (n !== null) {
      const r = n.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = n[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaHash = e.alphaHash),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
class EM extends Pc {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new ct(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapRotation = new gr()),
      (this.combine = aM),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      this.envMapRotation.copy(e.envMapRotation),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const It = new z(),
  mu = new ot();
class Ei {
  constructor(e, n, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = n),
      (this.count = e !== void 0 ? e.length / n : 0),
      (this.normalized = i),
      (this.usage = Mx),
      (this._updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.updateRanges = []),
      (this.gpuType = ir),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  get updateRange() {
    return (
      MO(
        "THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."
      ),
      this._updateRange
    );
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  addUpdateRange(e, n) {
    this.updateRanges.push({
      start: e,
      count: n,
    });
  }
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, n, i) {
    (e *= this.itemSize), (i *= n.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = n.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let n = 0, i = this.count; n < i; n++)
        mu.fromBufferAttribute(this, n),
          mu.applyMatrix3(e),
          this.setXY(n, mu.x, mu.y);
    else if (this.itemSize === 3)
      for (let n = 0, i = this.count; n < i; n++)
        It.fromBufferAttribute(this, n),
          It.applyMatrix3(e),
          this.setXYZ(n, It.x, It.y, It.z);
    return this;
  }
  applyMatrix4(e) {
    for (let n = 0, i = this.count; n < i; n++)
      It.fromBufferAttribute(this, n),
        It.applyMatrix4(e),
        this.setXYZ(n, It.x, It.y, It.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let n = 0, i = this.count; n < i; n++)
      It.fromBufferAttribute(this, n),
        It.applyNormalMatrix(e),
        this.setXYZ(n, It.x, It.y, It.z);
    return this;
  }
  transformDirection(e) {
    for (let n = 0, i = this.count; n < i; n++)
      It.fromBufferAttribute(this, n),
        It.transformDirection(e),
        this.setXYZ(n, It.x, It.y, It.z);
    return this;
  }
  set(e, n = 0) {
    return this.array.set(e, n), this;
  }
  getComponent(e, n) {
    let i = this.array[e * this.itemSize + n];
    return this.normalized && (i = Yo(i, this.array)), i;
  }
  setComponent(e, n, i) {
    return (
      this.normalized && (i = Tn(i, this.array)),
      (this.array[e * this.itemSize + n] = i),
      this
    );
  }
  getX(e) {
    let n = this.array[e * this.itemSize];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setX(e, n) {
    return (
      this.normalized && (n = Tn(n, this.array)),
      (this.array[e * this.itemSize] = n),
      this
    );
  }
  getY(e) {
    let n = this.array[e * this.itemSize + 1];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setY(e, n) {
    return (
      this.normalized && (n = Tn(n, this.array)),
      (this.array[e * this.itemSize + 1] = n),
      this
    );
  }
  getZ(e) {
    let n = this.array[e * this.itemSize + 2];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setZ(e, n) {
    return (
      this.normalized && (n = Tn(n, this.array)),
      (this.array[e * this.itemSize + 2] = n),
      this
    );
  }
  getW(e) {
    let n = this.array[e * this.itemSize + 3];
    return this.normalized && (n = Yo(n, this.array)), n;
  }
  setW(e, n) {
    return (
      this.normalized && (n = Tn(n, this.array)),
      (this.array[e * this.itemSize + 3] = n),
      this
    );
  }
  setXY(e, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((n = Tn(n, this.array)), (i = Tn(i, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, n, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Tn(n, this.array)),
        (i = Tn(i, this.array)),
        (r = Tn(r, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, n, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((n = Tn(n, this.array)),
        (i = Tn(i, this.array)),
        (r = Tn(r, this.array)),
        (s = Tn(s, this.array))),
      (this.array[e + 0] = n),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Mx && (e.usage = this.usage),
      e
    );
  }
}
class TM extends Ei {
  constructor(e, n, i) {
    super(new Uint16Array(e), n, i);
  }
}
class MM extends Ei {
  constructor(e, n, i) {
    super(new Uint32Array(e), n, i);
  }
}
class Ws extends Ei {
  constructor(e, n, i) {
    super(new Float32Array(e), n, i);
  }
}
let zO = 0;
const Kn = new Ft(),
  Kf = new In(),
  Sa = new z(),
  Fn = new Rc(),
  Qo = new Rc(),
  Wt = new z();
class _r extends ko {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", {
        value: zO++,
      }),
      (this.uuid = Ac()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = {
        start: 0,
        count: 1 / 0,
      }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (gM(e) ? MM : TM)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, n) {
    return (this.attributes[e] = n), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, n, i = 0) {
    this.groups.push({
      start: e,
      count: n,
      materialIndex: i,
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, n) {
    (this.drawRange.start = e), (this.drawRange.count = n);
  }
  applyMatrix4(e) {
    const n = this.attributes.position;
    n !== void 0 && (n.applyMatrix4(e), (n.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new $e().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Kn.makeRotationFromQuaternion(e), this.applyMatrix4(Kn), this;
  }
  rotateX(e) {
    return Kn.makeRotationX(e), this.applyMatrix4(Kn), this;
  }
  rotateY(e) {
    return Kn.makeRotationY(e), this.applyMatrix4(Kn), this;
  }
  rotateZ(e) {
    return Kn.makeRotationZ(e), this.applyMatrix4(Kn), this;
  }
  translate(e, n, i) {
    return Kn.makeTranslation(e, n, i), this.applyMatrix4(Kn), this;
  }
  scale(e, n, i) {
    return Kn.makeScale(e, n, i), this.applyMatrix4(Kn), this;
  }
  lookAt(e) {
    return Kf.lookAt(e), Kf.updateMatrix(), this.applyMatrix4(Kf.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Sa).negate(),
      this.translate(Sa.x, Sa.y, Sa.z),
      this
    );
  }
  setFromPoints(e) {
    const n = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      n.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ws(n, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Rc());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
        this
      ),
        this.boundingBox.set(
          new z(-1 / 0, -1 / 0, -1 / 0),
          new z(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), n))
        for (let i = 0, r = n.length; i < r; i++) {
          const s = n[i];
          Fn.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Wt.addVectors(this.boundingBox.min, Fn.min),
                this.boundingBox.expandByPoint(Wt),
                Wt.addVectors(this.boundingBox.max, Fn.max),
                this.boundingBox.expandByPoint(Wt))
              : (this.boundingBox.expandByPoint(Fn.min),
                this.boundingBox.expandByPoint(Fn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Th());
    const e = this.attributes.position,
      n = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
        this
      ),
        this.boundingSphere.set(new z(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Fn.setFromBufferAttribute(e), n))
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s];
          Qo.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Wt.addVectors(Fn.min, Qo.min),
                Fn.expandByPoint(Wt),
                Wt.addVectors(Fn.max, Qo.max),
                Fn.expandByPoint(Wt))
              : (Fn.expandByPoint(Qo.min), Fn.expandByPoint(Qo.max));
        }
      Fn.getCenter(i);
      let r = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Wt.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Wt)));
      if (n)
        for (let s = 0, a = n.length; s < a; s++) {
          const o = n[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            Wt.fromBufferAttribute(o, c),
              l && (Sa.fromBufferAttribute(e, c), Wt.add(Sa)),
              (r = Math.max(r, i.distanceToSquared(Wt)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      n = this.attributes;
    if (
      e === null ||
      n.position === void 0 ||
      n.normal === void 0 ||
      n.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = n.position,
      r = n.normal,
      s = n.uv;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Ei(new Float32Array(4 * i.count), 4));
    const a = this.getAttribute("tangent"),
      o = [],
      l = [];
    for (let P = 0; P < i.count; P++) (o[P] = new z()), (l[P] = new z());
    const c = new z(),
      u = new z(),
      d = new z(),
      h = new ot(),
      p = new ot(),
      v = new ot(),
      x = new z(),
      m = new z();
    function f(P, G, w) {
      c.fromBufferAttribute(i, P),
        u.fromBufferAttribute(i, G),
        d.fromBufferAttribute(i, w),
        h.fromBufferAttribute(s, P),
        p.fromBufferAttribute(s, G),
        v.fromBufferAttribute(s, w),
        u.sub(c),
        d.sub(c),
        p.sub(h),
        v.sub(h);
      const R = 1 / (p.x * v.y - v.x * p.y);
      isFinite(R) &&
        (x
          .copy(u)
          .multiplyScalar(v.y)
          .addScaledVector(d, -p.y)
          .multiplyScalar(R),
        m
          .copy(d)
          .multiplyScalar(p.x)
          .addScaledVector(u, -v.x)
          .multiplyScalar(R),
        o[P].add(x),
        o[G].add(x),
        o[w].add(x),
        l[P].add(m),
        l[G].add(m),
        l[w].add(m));
    }
    let y = this.groups;
    y.length === 0 &&
      (y = [
        {
          start: 0,
          count: e.count,
        },
      ]);
    for (let P = 0, G = y.length; P < G; ++P) {
      const w = y[P],
        R = w.start,
        ie = w.count;
      for (let J = R, D = R + ie; J < D; J += 3)
        f(e.getX(J + 0), e.getX(J + 1), e.getX(J + 2));
    }
    const g = new z(),
      S = new z(),
      T = new z(),
      A = new z();
    function b(P) {
      T.fromBufferAttribute(r, P), A.copy(T);
      const G = o[P];
      g.copy(G),
        g.sub(T.multiplyScalar(T.dot(G))).normalize(),
        S.crossVectors(A, G);
      const R = S.dot(l[P]) < 0 ? -1 : 1;
      a.setXYZW(P, g.x, g.y, g.z, R);
    }
    for (let P = 0, G = y.length; P < G; ++P) {
      const w = y[P],
        R = w.start,
        ie = w.count;
      for (let J = R, D = R + ie; J < D; J += 3)
        b(e.getX(J + 0)), b(e.getX(J + 1)), b(e.getX(J + 2));
    }
  }
  computeVertexNormals() {
    const e = this.index,
      n = this.getAttribute("position");
    if (n !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Ei(new Float32Array(n.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let h = 0, p = i.count; h < p; h++) i.setXYZ(h, 0, 0, 0);
      const r = new z(),
        s = new z(),
        a = new z(),
        o = new z(),
        l = new z(),
        c = new z(),
        u = new z(),
        d = new z();
      if (e)
        for (let h = 0, p = e.count; h < p; h += 3) {
          const v = e.getX(h + 0),
            x = e.getX(h + 1),
            m = e.getX(h + 2);
          r.fromBufferAttribute(n, v),
            s.fromBufferAttribute(n, x),
            a.fromBufferAttribute(n, m),
            u.subVectors(a, s),
            d.subVectors(r, s),
            u.cross(d),
            o.fromBufferAttribute(i, v),
            l.fromBufferAttribute(i, x),
            c.fromBufferAttribute(i, m),
            o.add(u),
            l.add(u),
            c.add(u),
            i.setXYZ(v, o.x, o.y, o.z),
            i.setXYZ(x, l.x, l.y, l.z),
            i.setXYZ(m, c.x, c.y, c.z);
        }
      else
        for (let h = 0, p = n.count; h < p; h += 3)
          r.fromBufferAttribute(n, h + 0),
            s.fromBufferAttribute(n, h + 1),
            a.fromBufferAttribute(n, h + 2),
            u.subVectors(a, s),
            d.subVectors(r, s),
            u.cross(d),
            i.setXYZ(h + 0, u.x, u.y, u.z),
            i.setXYZ(h + 1, u.x, u.y, u.z),
            i.setXYZ(h + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let n = 0, i = e.count; n < i; n++)
      Wt.fromBufferAttribute(e, n),
        Wt.normalize(),
        e.setXYZ(n, Wt.x, Wt.y, Wt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        u = o.itemSize,
        d = o.normalized,
        h = new c.constructor(l.length * u);
      let p = 0,
        v = 0;
      for (let x = 0, m = l.length; x < m; x++) {
        o.isInterleavedBufferAttribute
          ? (p = l[x] * o.data.stride + o.offset)
          : (p = l[x] * u);
        for (let f = 0; f < u; f++) h[v++] = c[p++];
      }
      return new Ei(h, u, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const n = new _r(),
      i = this.index.array,
      r = this.attributes;
    for (const o in r) {
      const l = r[o],
        c = e(l, i);
      n.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let u = 0, d = c.length; u < d; u++) {
        const h = c[u],
          p = e(h, i);
        l.push(p);
      }
      n.morphAttributes[o] = l;
    }
    n.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      n.addGroup(c.start, c.count, c.materialIndex);
    }
    return n;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = {
      attributes: {},
    };
    const n = this.index;
    n !== null &&
      (e.data.index = {
        type: n.array.constructor.name,
        array: Array.prototype.slice.call(n.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let d = 0, h = c.length; d < h; d++) {
        const p = c[d];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && ((r[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const n = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(n));
    const r = e.attributes;
    for (const c in r) {
      const u = r[c];
      this.setAttribute(c, u.clone(n));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        d = s[c];
      for (let h = 0, p = d.length; h < p; h++) u.push(d[h].clone(n));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const d = a[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({
      type: "dispose",
    });
  }
}
const Bx = new Ft(),
  xs = new xM(),
  gu = new Th(),
  zx = new z(),
  wa = new z(),
  Ea = new z(),
  Ta = new z(),
  Jf = new z(),
  vu = new z(),
  _u = new ot(),
  yu = new ot(),
  xu = new ot(),
  jx = new z(),
  Vx = new z(),
  Hx = new z(),
  Su = new z(),
  wu = new z();
class or extends In {
  constructor(e = new _r(), n = new EM()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, n) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      a = i.morphTargetsRelative;
    n.fromBufferAttribute(r, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      vu.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = o[l],
          d = s[l];
        u !== 0 &&
          (Jf.fromBufferAttribute(d, e),
          a ? vu.addScaledVector(Jf, u) : vu.addScaledVector(Jf.sub(n), u));
      }
      n.add(vu);
    }
    return n;
  }
  raycast(e, n) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    r !== void 0 &&
      (i.boundingSphere === null && i.computeBoundingSphere(),
      gu.copy(i.boundingSphere),
      gu.applyMatrix4(s),
      xs.copy(e.ray).recast(e.near),
      !(
        gu.containsPoint(xs.origin) === !1 &&
        (xs.intersectSphere(gu, zx) === null ||
          xs.origin.distanceToSquared(zx) > (e.far - e.near) ** 2)
      ) &&
        (Bx.copy(s).invert(),
        xs.copy(e.ray).applyMatrix4(Bx),
        !(i.boundingBox !== null && xs.intersectsBox(i.boundingBox) === !1) &&
          this._computeIntersections(e, n, xs)));
  }
  _computeIntersections(e, n, i) {
    let r;
    const s = this.geometry,
      a = this.material,
      o = s.index,
      l = s.attributes.position,
      c = s.attributes.uv,
      u = s.attributes.uv1,
      d = s.attributes.normal,
      h = s.groups,
      p = s.drawRange;
    if (o !== null)
      if (Array.isArray(a))
        for (let v = 0, x = h.length; v < x; v++) {
          const m = h[v],
            f = a[m.materialIndex],
            y = Math.max(m.start, p.start),
            g = Math.min(
              o.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let S = y, T = g; S < T; S += 3) {
            const A = o.getX(S),
              b = o.getX(S + 1),
              P = o.getX(S + 2);
            (r = Eu(this, f, e, i, c, u, d, A, b, P)),
              r &&
                ((r.faceIndex = Math.floor(S / 3)),
                (r.face.materialIndex = m.materialIndex),
                n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start),
          x = Math.min(o.count, p.start + p.count);
        for (let m = v, f = x; m < f; m += 3) {
          const y = o.getX(m),
            g = o.getX(m + 1),
            S = o.getX(m + 2);
          (r = Eu(this, a, e, i, c, u, d, y, g, S)),
            r && ((r.faceIndex = Math.floor(m / 3)), n.push(r));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(a))
        for (let v = 0, x = h.length; v < x; v++) {
          const m = h[v],
            f = a[m.materialIndex],
            y = Math.max(m.start, p.start),
            g = Math.min(
              l.count,
              Math.min(m.start + m.count, p.start + p.count)
            );
          for (let S = y, T = g; S < T; S += 3) {
            const A = S,
              b = S + 1,
              P = S + 2;
            (r = Eu(this, f, e, i, c, u, d, A, b, P)),
              r &&
                ((r.faceIndex = Math.floor(S / 3)),
                (r.face.materialIndex = m.materialIndex),
                n.push(r));
          }
        }
      else {
        const v = Math.max(0, p.start),
          x = Math.min(l.count, p.start + p.count);
        for (let m = v, f = x; m < f; m += 3) {
          const y = m,
            g = m + 1,
            S = m + 2;
          (r = Eu(this, a, e, i, c, u, d, y, g, S)),
            r && ((r.faceIndex = Math.floor(m / 3)), n.push(r));
        }
      }
  }
}
function jO(t, e, n, i, r, s, a, o) {
  let l;
  if (
    (e.side === Dn
      ? (l = i.intersectTriangle(a, s, r, !0, o))
      : (l = i.intersectTriangle(r, s, a, e.side === as, o)),
    l === null)
  )
    return null;
  wu.copy(o), wu.applyMatrix4(t.matrixWorld);
  const c = n.ray.origin.distanceTo(wu);
  return c < n.near || c > n.far
    ? null
    : {
        distance: c,
        point: wu.clone(),
        object: t,
      };
}
function Eu(t, e, n, i, r, s, a, o, l, c) {
  t.getVertexPosition(o, wa),
    t.getVertexPosition(l, Ea),
    t.getVertexPosition(c, Ta);
  const u = jO(t, e, n, i, wa, Ea, Ta, Su);
  if (u) {
    r &&
      (_u.fromBufferAttribute(r, o),
      yu.fromBufferAttribute(r, l),
      xu.fromBufferAttribute(r, c),
      (u.uv = ki.getInterpolation(Su, wa, Ea, Ta, _u, yu, xu, new ot()))),
      s &&
        (_u.fromBufferAttribute(s, o),
        yu.fromBufferAttribute(s, l),
        xu.fromBufferAttribute(s, c),
        (u.uv1 = ki.getInterpolation(Su, wa, Ea, Ta, _u, yu, xu, new ot()))),
      a &&
        (jx.fromBufferAttribute(a, o),
        Vx.fromBufferAttribute(a, l),
        Hx.fromBufferAttribute(a, c),
        (u.normal = ki.getInterpolation(Su, wa, Ea, Ta, jx, Vx, Hx, new z())),
        u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1));
    const d = {
      a: o,
      b: l,
      c,
      normal: new z(),
      materialIndex: 0,
    };
    ki.getNormal(wa, Ea, Ta, d.normal), (u.face = d);
  }
  return u;
}
class Lc extends _r {
  constructor(e = 1, n = 1, i = 1, r = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (a = Math.floor(a));
    const l = [],
      c = [],
      u = [],
      d = [];
    let h = 0,
      p = 0;
    v("z", "y", "x", -1, -1, i, n, e, a, s, 0),
      v("z", "y", "x", 1, -1, i, n, -e, a, s, 1),
      v("x", "z", "y", 1, 1, e, i, n, r, a, 2),
      v("x", "z", "y", 1, -1, e, i, -n, r, a, 3),
      v("x", "y", "z", 1, -1, e, n, i, r, s, 4),
      v("x", "y", "z", -1, -1, e, n, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Ws(c, 3)),
      this.setAttribute("normal", new Ws(u, 3)),
      this.setAttribute("uv", new Ws(d, 2));
    function v(x, m, f, y, g, S, T, A, b, P, G) {
      const w = S / b,
        R = T / P,
        ie = S / 2,
        J = T / 2,
        D = A / 2,
        Y = b + 1,
        q = P + 1;
      let W = 0,
        L = 0;
      const U = new z();
      for (let X = 0; X < q; X++) {
        const K = X * R - J;
        for (let oe = 0; oe < Y; oe++) {
          const ke = oe * w - ie;
          (U[x] = ke * y),
            (U[m] = K * g),
            (U[f] = D),
            c.push(U.x, U.y, U.z),
            (U[x] = 0),
            (U[m] = 0),
            (U[f] = A > 0 ? 1 : -1),
            u.push(U.x, U.y, U.z),
            d.push(oe / b),
            d.push(1 - X / P),
            (W += 1);
        }
      }
      for (let X = 0; X < P; X++)
        for (let K = 0; K < b; K++) {
          const oe = h + K + Y * X,
            ke = h + K + Y * (X + 1),
            V = h + (K + 1) + Y * (X + 1),
            Q = h + (K + 1) + Y * X;
          l.push(oe, ke, Q), l.push(ke, V, Q), (L += 6);
        }
      o.addGroup(p, L, G), (p += L), (h += W);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Lc(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function To(t) {
  const e = {};
  for (const n in t) {
    e[n] = {};
    for (const i in t[n]) {
      const r = t[n][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[n][i] = null))
          : (e[n][i] = r.clone())
        : Array.isArray(r)
        ? (e[n][i] = r.slice())
        : (e[n][i] = r);
    }
  }
  return e;
}
function mn(t) {
  const e = {};
  for (let n = 0; n < t.length; n++) {
    const i = To(t[n]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function VO(t) {
  const e = [];
  for (let n = 0; n < t.length; n++) e.push(t[n].clone());
  return e;
}
function bM(t) {
  return t.getRenderTarget() === null
    ? t.outputColorSpace
    : dt.workingColorSpace;
}
const HO = {
  clone: To,
  merge: mn,
};
var GO = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  WO = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;

class os extends Pc {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = GO),
      (this.fragmentShader = WO),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
        clipCullDistance: !1,
        multiDraw: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = To(e.uniforms)),
      (this.uniformsGroups = VO(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    (n.glslVersion = this.glslVersion), (n.uniforms = {});
    for (const r in this.uniforms) {
      const a = this.uniforms[r].value;
      a && a.isTexture
        ? (n.uniforms[r] = {
            type: "t",
            value: a.toJSON(e).uuid,
          })
        : a && a.isColor
        ? (n.uniforms[r] = {
            type: "c",
            value: a.getHex(),
          })
        : a && a.isVector2
        ? (n.uniforms[r] = {
            type: "v2",
            value: a.toArray(),
          })
        : a && a.isVector3
        ? (n.uniforms[r] = {
            type: "v3",
            value: a.toArray(),
          })
        : a && a.isVector4
        ? (n.uniforms[r] = {
            type: "v4",
            value: a.toArray(),
          })
        : a && a.isMatrix3
        ? (n.uniforms[r] = {
            type: "m3",
            value: a.toArray(),
          })
        : a && a.isMatrix4
        ? (n.uniforms[r] = {
            type: "m4",
            value: a.toArray(),
          })
        : (n.uniforms[r] = {
            value: a,
          });
    }
    Object.keys(this.defines).length > 0 && (n.defines = this.defines),
      (n.vertexShader = this.vertexShader),
      (n.fragmentShader = this.fragmentShader),
      (n.lights = this.lights),
      (n.clipping = this.clipping);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (n.extensions = i), n;
  }
}
class AM extends In {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Ft()),
      (this.projectionMatrix = new Ft()),
      (this.projectionMatrixInverse = new Ft()),
      (this.coordinateSystem = ar);
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, n) {
    super.updateWorldMatrix(e, n),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Mr = new z(),
  Gx = new ot(),
  Wx = new ot();
class ti extends AM {
  constructor(e = 50, n = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = n),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const n = (0.5 * this.getFilmHeight()) / e;
    (this.fov = zm * 2 * Math.atan(n)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Df * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return zm * 2 * Math.atan(Math.tan(Df * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  getViewBounds(e, n, i) {
    Mr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      n.set(Mr.x, Mr.y).multiplyScalar(-e / Mr.z),
      Mr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
      i.set(Mr.x, Mr.y).multiplyScalar(-e / Mr.z);
  }
  getViewSize(e, n) {
    return this.getViewBounds(e, Gx, Wx), n.subVectors(Wx, Gx);
  }
  setViewOffset(e, n, i, r, s, a) {
    (this.aspect = e / n),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let n = (e * Math.tan(Df * 0.5 * this.fov)) / this.zoom,
      i = 2 * n,
      r = this.aspect * i,
      s = -0.5 * r;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (s += (a.offsetX * r) / l),
        (n -= (a.offsetY * i) / c),
        (r *= a.width / l),
        (i *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + r,
        n,
        n - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.fov = this.fov),
      (n.object.zoom = this.zoom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      (n.object.focus = this.focus),
      (n.object.aspect = this.aspect),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      (n.object.filmGauge = this.filmGauge),
      (n.object.filmOffset = this.filmOffset),
      n
    );
  }
}
const Ma = -90,
  ba = 1;
class $O extends In {
  constructor(e, n, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null),
      (this.activeMipmapLevel = 0);
    const r = new ti(Ma, ba, e, n);
    (r.layers = this.layers), this.add(r);
    const s = new ti(Ma, ba, e, n);
    (s.layers = this.layers), this.add(s);
    const a = new ti(Ma, ba, e, n);
    (a.layers = this.layers), this.add(a);
    const o = new ti(Ma, ba, e, n);
    (o.layers = this.layers), this.add(o);
    const l = new ti(Ma, ba, e, n);
    (l.layers = this.layers), this.add(l);
    const c = new ti(Ma, ba, e, n);
    (c.layers = this.layers), this.add(c);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      n = this.children.concat(),
      [i, r, s, a, o, l] = n;
    for (const c of n) this.remove(c);
    if (e === ar)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        r.up.set(0, 1, 0),
        r.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, 1),
        a.lookAt(0, -1, 0),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, 1, 0),
        l.lookAt(0, 0, -1);
    else if (e === jd)
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        r.up.set(0, -1, 0),
        r.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        a.up.set(0, 0, -1),
        a.lookAt(0, -1, 0),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, 1),
        l.up.set(0, -1, 0),
        l.lookAt(0, 0, -1);
    else
      throw new Error(
        "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
          e
      );
    for (const c of n) this.add(c), c.updateMatrixWorld();
  }
  update(e, n) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: i, activeMipmapLevel: r } = this;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [s, a, o, l, c, u] = this.children,
      d = e.getRenderTarget(),
      h = e.getActiveCubeFace(),
      p = e.getActiveMipmapLevel(),
      v = e.xr.enabled;
    e.xr.enabled = !1;
    const x = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0, r),
      e.render(n, s),
      e.setRenderTarget(i, 1, r),
      e.render(n, a),
      e.setRenderTarget(i, 2, r),
      e.render(n, o),
      e.setRenderTarget(i, 3, r),
      e.render(n, l),
      e.setRenderTarget(i, 4, r),
      e.render(n, c),
      (i.texture.generateMipmaps = x),
      e.setRenderTarget(i, 5, r),
      e.render(n, u),
      e.setRenderTarget(d, h, p),
      (e.xr.enabled = v),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class CM extends kn {
  constructor(e, n, i, r, s, a, o, l, c, u) {
    (e = e !== void 0 ? e : []),
      (n = n !== void 0 ? n : So),
      super(e, n, i, r, s, a, o, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class XO extends ta {
  constructor(e = 1, n = {}) {
    super(e, e, n), (this.isWebGLCubeRenderTarget = !0);
    const i = {
        width: e,
        height: e,
        depth: 1,
      },
      r = [i, i, i, i, i, i];
    (this.texture = new CM(
      r,
      n.mapping,
      n.wrapS,
      n.wrapT,
      n.magFilter,
      n.minFilter,
      n.format,
      n.type,
      n.anisotropy,
      n.colorSpace
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Mn);
  }
  fromEquirectangularTexture(e, n) {
    (this.texture.type = n.type),
      (this.texture.colorSpace = n.colorSpace),
      (this.texture.generateMipmaps = n.generateMipmaps),
      (this.texture.minFilter = n.minFilter),
      (this.texture.magFilter = n.magFilter);
    const i = {
        uniforms: {
          tEquirect: {
            value: null,
          },
        },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new Lc(5, 5, 5),
      s = new os({
        name: "CubemapFromEquirect",
        uniforms: To(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: Dn,
        blending: Zr,
      });
    s.uniforms.tEquirect.value = n;
    const a = new or(r, s),
      o = n.minFilter;
    return (
      n.minFilter === Fs && (n.minFilter = Mn),
      new $O(1, 10, this).update(e, a),
      (n.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, n, i, r) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(n, i, r);
    e.setRenderTarget(s);
  }
}
const Qf = new z(),
  qO = new z(),
  YO = new $e();
class Rs {
  constructor(e = new z(1, 0, 0), n = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = n);
  }
  set(e, n) {
    return this.normal.copy(e), (this.constant = n), this;
  }
  setComponents(e, n, i, r) {
    return this.normal.set(e, n, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, n) {
    return this.normal.copy(e), (this.constant = -n.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, n, i) {
    const r = Qf.subVectors(i, n).cross(qO.subVectors(e, n)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, n) {
    return n.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, n) {
    const i = e.delta(Qf),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? n.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : n.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const n = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (n < 0 && i > 0) || (i < 0 && n > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, n) {
    const i = n || YO.getNormalMatrix(e),
      r = this.coplanarPoint(Qf).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ss = new Th(),
  Tu = new z();
class RM {
  constructor(
    e = new Rs(),
    n = new Rs(),
    i = new Rs(),
    r = new Rs(),
    s = new Rs(),
    a = new Rs()
  ) {
    this.planes = [e, n, i, r, s, a];
  }
  set(e, n, i, r, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(n),
      o[2].copy(i),
      o[3].copy(r),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) n[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, n = ar) {
    const i = this.planes,
      r = e.elements,
      s = r[0],
      a = r[1],
      o = r[2],
      l = r[3],
      c = r[4],
      u = r[5],
      d = r[6],
      h = r[7],
      p = r[8],
      v = r[9],
      x = r[10],
      m = r[11],
      f = r[12],
      y = r[13],
      g = r[14],
      S = r[15];
    if (
      (i[0].setComponents(l - s, h - c, m - p, S - f).normalize(),
      i[1].setComponents(l + s, h + c, m + p, S + f).normalize(),
      i[2].setComponents(l + a, h + u, m + v, S + y).normalize(),
      i[3].setComponents(l - a, h - u, m - v, S - y).normalize(),
      i[4].setComponents(l - o, h - d, m - x, S - g).normalize(),
      n === ar)
    )
      i[5].setComponents(l + o, h + d, m + x, S + g).normalize();
    else if (n === jd) i[5].setComponents(o, d, x, g).normalize();
    else
      throw new Error(
        "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
          n
      );
    return this;
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Ss.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const n = e.geometry;
      n.boundingSphere === null && n.computeBoundingSphere(),
        Ss.copy(n.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Ss);
  }
  intersectsSprite(e) {
    return (
      Ss.center.set(0, 0, 0),
      (Ss.radius = 0.7071067811865476),
      Ss.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Ss)
    );
  }
  intersectsSphere(e) {
    const n = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (n[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = n[i];
      if (
        ((Tu.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Tu.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Tu.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Tu) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const n = this.planes;
    for (let i = 0; i < 6; i++) if (n[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function PM() {
  let t = null,
    e = !1,
    n = null,
    i = null;
  function r(s, a) {
    n(s, a), (i = t.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && n !== null && ((i = t.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      t.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      n = s;
    },
    setContext: function (s) {
      t = s;
    },
  };
}
function ZO(t, e) {
  const n = e.isWebGL2,
    i = new WeakMap();
  function r(c, u) {
    const d = c.array,
      h = c.usage,
      p = d.byteLength,
      v = t.createBuffer();
    t.bindBuffer(u, v), t.bufferData(u, d, h), c.onUploadCallback();
    let x;
    if (d instanceof Float32Array) x = t.FLOAT;
    else if (d instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (n) x = t.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else x = t.UNSIGNED_SHORT;
    else if (d instanceof Int16Array) x = t.SHORT;
    else if (d instanceof Uint32Array) x = t.UNSIGNED_INT;
    else if (d instanceof Int32Array) x = t.INT;
    else if (d instanceof Int8Array) x = t.BYTE;
    else if (d instanceof Uint8Array) x = t.UNSIGNED_BYTE;
    else if (d instanceof Uint8ClampedArray) x = t.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: v,
      type: x,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: c.version,
      size: p,
    };
  }
  function s(c, u, d) {
    const h = u.array,
      p = u._updateRange,
      v = u.updateRanges;
    if (
      (t.bindBuffer(d, c),
      p.count === -1 && v.length === 0 && t.bufferSubData(d, 0, h),
      v.length !== 0)
    ) {
      for (let x = 0, m = v.length; x < m; x++) {
        const f = v[x];
        n
          ? t.bufferSubData(
              d,
              f.start * h.BYTES_PER_ELEMENT,
              h,
              f.start,
              f.count
            )
          : t.bufferSubData(
              d,
              f.start * h.BYTES_PER_ELEMENT,
              h.subarray(f.start, f.start + f.count)
            );
      }
      u.clearUpdateRanges();
    }
    p.count !== -1 &&
      (n
        ? t.bufferSubData(
            d,
            p.offset * h.BYTES_PER_ELEMENT,
            h,
            p.offset,
            p.count
          )
        : t.bufferSubData(
            d,
            p.offset * h.BYTES_PER_ELEMENT,
            h.subarray(p.offset, p.offset + p.count)
          ),
      (p.count = -1)),
      u.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = i.get(c);
    u && (t.deleteBuffer(u.buffer), i.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const h = i.get(c);
      (!h || h.version < c.version) &&
        i.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = i.get(c);
    if (d === void 0) i.set(c, r(c, u));
    else if (d.version < c.version) {
      if (d.size !== c.array.byteLength)
        throw new Error(
          "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
        );
      s(d.buffer, c, u), (d.version = c.version);
    }
  }
  return {
    get: a,
    remove: o,
    update: l,
  };
}
class Mh extends _r {
  constructor(e = 1, n = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: n,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      a = n / 2,
      o = Math.floor(i),
      l = Math.floor(r),
      c = o + 1,
      u = l + 1,
      d = e / o,
      h = n / l,
      p = [],
      v = [],
      x = [],
      m = [];
    for (let f = 0; f < u; f++) {
      const y = f * h - a;
      for (let g = 0; g < c; g++) {
        const S = g * d - s;
        v.push(S, -y, 0), x.push(0, 0, 1), m.push(g / o), m.push(1 - f / l);
      }
    }
    for (let f = 0; f < l; f++)
      for (let y = 0; y < o; y++) {
        const g = y + c * f,
          S = y + c * (f + 1),
          T = y + 1 + c * (f + 1),
          A = y + 1 + c * f;
        p.push(g, S, A), p.push(S, T, A);
      }
    this.setIndex(p),
      this.setAttribute("position", new Ws(v, 3)),
      this.setAttribute("normal", new Ws(x, 3)),
      this.setAttribute("uv", new Ws(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Mh(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var KO = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
  JO = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
  QO = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  eF = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  tF = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
  nF = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  iF = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  rF = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  sF = `#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  aF = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,
  oF = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
  lF = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  cF = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  uF = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  dF = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  hF = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
  fF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  pF = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  mF = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  gF = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  vF = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  _F = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  yF = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  xF = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  SF = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  wF = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  EF = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  TF = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  MF = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  bF = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  AF = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  CF = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,
  RF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  PF = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  LF = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  NF = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  DF = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  kF = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  IF = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  UF = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  OF = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  FF = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  BF = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  zF = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  jF = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  VF = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  HF = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  GF = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
  WF = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  $F = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  XF = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  qF = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  YF = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
  ZF = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  KF = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  JF = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  QF = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
  e4 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  t4 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  n4 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  i4 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  r4 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  s4 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  a4 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  o4 = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  l4 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  c4 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  u4 = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
  d4 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  h4 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  f4 = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  p4 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  m4 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
  g4 = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  v4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  _4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  y4 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  x4 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  S4 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
  w4 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  E4 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  T4 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  M4 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  b4 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  A4 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  C4 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  R4 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  P4 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  L4 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  N4 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  D4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  k4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  I4 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  U4 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  O4 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  F4 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
  B4 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  z4 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  j4 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  V4 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  H4 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  G4 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  W4 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
  $4 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
  X4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  q4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  Y4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  Z4 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;

const K4 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  J4 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  Q4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  eB = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  tB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  nB = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  iB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  rB = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  sB = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  aB = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  oB = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  lB = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
  cB = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  uB = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  dB = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  hB = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  fB = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  pB = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  mB = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  gB = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  vB = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  _B = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  yB = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  xB = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  SB = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  wB = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  EB = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  TB = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  MB = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  bB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  AB = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  CB = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  RB = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  PB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
  We = {
    alphahash_fragment: KO,
    alphahash_pars_fragment: JO,
    alphamap_fragment: QO,
    alphamap_pars_fragment: eF,
    alphatest_fragment: tF,
    alphatest_pars_fragment: nF,
    aomap_fragment: iF,
    aomap_pars_fragment: rF,
    batching_pars_vertex: sF,
    batching_vertex: aF,
    begin_vertex: oF,
    beginnormal_vertex: lF,
    bsdfs: cF,
    iridescence_fragment: uF,
    bumpmap_pars_fragment: dF,
    clipping_planes_fragment: hF,
    clipping_planes_pars_fragment: fF,
    clipping_planes_pars_vertex: pF,
    clipping_planes_vertex: mF,
    color_fragment: gF,
    color_pars_fragment: vF,
    color_pars_vertex: _F,
    color_vertex: yF,
    common: xF,
    cube_uv_reflection_fragment: SF,
    defaultnormal_vertex: wF,
    displacementmap_pars_vertex: EF,
    displacementmap_vertex: TF,
    emissivemap_fragment: MF,
    emissivemap_pars_fragment: bF,
    colorspace_fragment: AF,
    colorspace_pars_fragment: CF,
    envmap_fragment: RF,
    envmap_common_pars_fragment: PF,
    envmap_pars_fragment: LF,
    envmap_pars_vertex: NF,
    envmap_physical_pars_fragment: GF,
    envmap_vertex: DF,
    fog_vertex: kF,
    fog_pars_vertex: IF,
    fog_fragment: UF,
    fog_pars_fragment: OF,
    gradientmap_pars_fragment: FF,
    lightmap_fragment: BF,
    lightmap_pars_fragment: zF,
    lights_lambert_fragment: jF,
    lights_lambert_pars_fragment: VF,
    lights_pars_begin: HF,
    lights_toon_fragment: WF,
    lights_toon_pars_fragment: $F,
    lights_phong_fragment: XF,
    lights_phong_pars_fragment: qF,
    lights_physical_fragment: YF,
    lights_physical_pars_fragment: ZF,
    lights_fragment_begin: KF,
    lights_fragment_maps: JF,
    lights_fragment_end: QF,
    logdepthbuf_fragment: e4,
    logdepthbuf_pars_fragment: t4,
    logdepthbuf_pars_vertex: n4,
    logdepthbuf_vertex: i4,
    map_fragment: r4,
    map_pars_fragment: s4,
    map_particle_fragment: a4,
    map_particle_pars_fragment: o4,
    metalnessmap_fragment: l4,
    metalnessmap_pars_fragment: c4,
    morphinstance_vertex: u4,
    morphcolor_vertex: d4,
    morphnormal_vertex: h4,
    morphtarget_pars_vertex: f4,
    morphtarget_vertex: p4,
    normal_fragment_begin: m4,
    normal_fragment_maps: g4,
    normal_pars_fragment: v4,
    normal_pars_vertex: _4,
    normal_vertex: y4,
    normalmap_pars_fragment: x4,
    clearcoat_normal_fragment_begin: S4,
    clearcoat_normal_fragment_maps: w4,
    clearcoat_pars_fragment: E4,
    iridescence_pars_fragment: T4,
    opaque_fragment: M4,
    packing: b4,
    premultiplied_alpha_fragment: A4,
    project_vertex: C4,
    dithering_fragment: R4,
    dithering_pars_fragment: P4,
    roughnessmap_fragment: L4,
    roughnessmap_pars_fragment: N4,
    shadowmap_pars_fragment: D4,
    shadowmap_pars_vertex: k4,
    shadowmap_vertex: I4,
    shadowmask_pars_fragment: U4,
    skinbase_vertex: O4,
    skinning_pars_vertex: F4,
    skinning_vertex: B4,
    skinnormal_vertex: z4,
    specularmap_fragment: j4,
    specularmap_pars_fragment: V4,
    tonemapping_fragment: H4,
    tonemapping_pars_fragment: G4,
    transmission_fragment: W4,
    transmission_pars_fragment: $4,
    uv_pars_fragment: X4,
    uv_pars_vertex: q4,
    uv_vertex: Y4,
    worldpos_vertex: Z4,
    background_vert: K4,
    background_frag: J4,
    backgroundCube_vert: Q4,
    backgroundCube_frag: eB,
    cube_vert: tB,
    cube_frag: nB,
    depth_vert: iB,
    depth_frag: rB,
    distanceRGBA_vert: sB,
    distanceRGBA_frag: aB,
    equirect_vert: oB,
    equirect_frag: lB,
    linedashed_vert: cB,
    linedashed_frag: uB,
    meshbasic_vert: dB,
    meshbasic_frag: hB,
    meshlambert_vert: fB,
    meshlambert_frag: pB,
    meshmatcap_vert: mB,
    meshmatcap_frag: gB,
    meshnormal_vert: vB,
    meshnormal_frag: _B,
    meshphong_vert: yB,
    meshphong_frag: xB,
    meshphysical_vert: SB,
    meshphysical_frag: wB,
    meshtoon_vert: EB,
    meshtoon_frag: TB,
    points_vert: MB,
    points_frag: bB,
    shadow_vert: AB,
    shadow_frag: CB,
    sprite_vert: RB,
    sprite_frag: PB,
  },
  le = {
    common: {
      diffuse: {
        value: new ct(16777215),
      },
      opacity: {
        value: 1,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new $e(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new $e(),
      },
      alphaTest: {
        value: 0,
      },
    },
    specularmap: {
      specularMap: {
        value: null,
      },
      specularMapTransform: {
        value: new $e(),
      },
    },
    envmap: {
      envMap: {
        value: null,
      },
      envMapRotation: {
        value: new $e(),
      },
      flipEnvMap: {
        value: -1,
      },
      reflectivity: {
        value: 1,
      },
      ior: {
        value: 1.5,
      },
      refractionRatio: {
        value: 0.98,
      },
    },
    aomap: {
      aoMap: {
        value: null,
      },
      aoMapIntensity: {
        value: 1,
      },
      aoMapTransform: {
        value: new $e(),
      },
    },
    lightmap: {
      lightMap: {
        value: null,
      },
      lightMapIntensity: {
        value: 1,
      },
      lightMapTransform: {
        value: new $e(),
      },
    },
    bumpmap: {
      bumpMap: {
        value: null,
      },
      bumpMapTransform: {
        value: new $e(),
      },
      bumpScale: {
        value: 1,
      },
    },
    normalmap: {
      normalMap: {
        value: null,
      },
      normalMapTransform: {
        value: new $e(),
      },
      normalScale: {
        value: new ot(1, 1),
      },
    },
    displacementmap: {
      displacementMap: {
        value: null,
      },
      displacementMapTransform: {
        value: new $e(),
      },
      displacementScale: {
        value: 1,
      },
      displacementBias: {
        value: 0,
      },
    },
    emissivemap: {
      emissiveMap: {
        value: null,
      },
      emissiveMapTransform: {
        value: new $e(),
      },
    },
    metalnessmap: {
      metalnessMap: {
        value: null,
      },
      metalnessMapTransform: {
        value: new $e(),
      },
    },
    roughnessmap: {
      roughnessMap: {
        value: null,
      },
      roughnessMapTransform: {
        value: new $e(),
      },
    },
    gradientmap: {
      gradientMap: {
        value: null,
      },
    },
    fog: {
      fogDensity: {
        value: 25e-5,
      },
      fogNear: {
        value: 1,
      },
      fogFar: {
        value: 2e3,
      },
      fogColor: {
        value: new ct(16777215),
      },
    },
    lights: {
      ambientLightColor: {
        value: [],
      },
      lightProbe: {
        value: [],
      },
      directionalLights: {
        value: [],
        properties: {
          direction: {},
          color: {},
        },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: {
        value: [],
      },
      directionalShadowMatrix: {
        value: [],
      },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: {
        value: [],
      },
      spotShadowMap: {
        value: [],
      },
      spotLightMatrix: {
        value: [],
      },
      pointLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          decay: {},
          distance: {},
        },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: {
        value: [],
      },
      pointShadowMatrix: {
        value: [],
      },
      hemisphereLights: {
        value: [],
        properties: {
          direction: {},
          skyColor: {},
          groundColor: {},
        },
      },
      rectAreaLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          width: {},
          height: {},
        },
      },
      ltc_1: {
        value: null,
      },
      ltc_2: {
        value: null,
      },
    },
    points: {
      diffuse: {
        value: new ct(16777215),
      },
      opacity: {
        value: 1,
      },
      size: {
        value: 1,
      },
      scale: {
        value: 1,
      },
      map: {
        value: null,
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new $e(),
      },
      alphaTest: {
        value: 0,
      },
      uvTransform: {
        value: new $e(),
      },
    },
    sprite: {
      diffuse: {
        value: new ct(16777215),
      },
      opacity: {
        value: 1,
      },
      center: {
        value: new ot(0.5, 0.5),
      },
      rotation: {
        value: 0,
      },
      map: {
        value: null,
      },
      mapTransform: {
        value: new $e(),
      },
      alphaMap: {
        value: null,
      },
      alphaMapTransform: {
        value: new $e(),
      },
      alphaTest: {
        value: 0,
      },
    },
  },
  Ni = {
    basic: {
      uniforms: mn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.fog,
      ]),
      vertexShader: We.meshbasic_vert,
      fragmentShader: We.meshbasic_frag,
    },
    lambert: {
      uniforms: mn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        le.lights,
        {
          emissive: {
            value: new ct(0),
          },
        },
      ]),
      vertexShader: We.meshlambert_vert,
      fragmentShader: We.meshlambert_frag,
    },
    phong: {
      uniforms: mn([
        le.common,
        le.specularmap,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        le.lights,
        {
          emissive: {
            value: new ct(0),
          },
          specular: {
            value: new ct(1118481),
          },
          shininess: {
            value: 30,
          },
        },
      ]),
      vertexShader: We.meshphong_vert,
      fragmentShader: We.meshphong_frag,
    },
    standard: {
      uniforms: mn([
        le.common,
        le.envmap,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.roughnessmap,
        le.metalnessmap,
        le.fog,
        le.lights,
        {
          emissive: {
            value: new ct(0),
          },
          roughness: {
            value: 1,
          },
          metalness: {
            value: 0,
          },
          envMapIntensity: {
            value: 1,
          },
        },
      ]),
      vertexShader: We.meshphysical_vert,
      fragmentShader: We.meshphysical_frag,
    },
    toon: {
      uniforms: mn([
        le.common,
        le.aomap,
        le.lightmap,
        le.emissivemap,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.gradientmap,
        le.fog,
        le.lights,
        {
          emissive: {
            value: new ct(0),
          },
        },
      ]),
      vertexShader: We.meshtoon_vert,
      fragmentShader: We.meshtoon_frag,
    },
    matcap: {
      uniforms: mn([
        le.common,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        le.fog,
        {
          matcap: {
            value: null,
          },
        },
      ]),
      vertexShader: We.meshmatcap_vert,
      fragmentShader: We.meshmatcap_frag,
    },
    points: {
      uniforms: mn([le.points, le.fog]),
      vertexShader: We.points_vert,
      fragmentShader: We.points_frag,
    },
    dashed: {
      uniforms: mn([
        le.common,
        le.fog,
        {
          scale: {
            value: 1,
          },
          dashSize: {
            value: 1,
          },
          totalSize: {
            value: 2,
          },
        },
      ]),
      vertexShader: We.linedashed_vert,
      fragmentShader: We.linedashed_frag,
    },
    depth: {
      uniforms: mn([le.common, le.displacementmap]),
      vertexShader: We.depth_vert,
      fragmentShader: We.depth_frag,
    },
    normal: {
      uniforms: mn([
        le.common,
        le.bumpmap,
        le.normalmap,
        le.displacementmap,
        {
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: We.meshnormal_vert,
      fragmentShader: We.meshnormal_frag,
    },
    sprite: {
      uniforms: mn([le.sprite, le.fog]),
      vertexShader: We.sprite_vert,
      fragmentShader: We.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: {
          value: new $e(),
        },
        t2D: {
          value: null,
        },
        backgroundIntensity: {
          value: 1,
        },
      },
      vertexShader: We.background_vert,
      fragmentShader: We.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: {
          value: null,
        },
        flipEnvMap: {
          value: -1,
        },
        backgroundBlurriness: {
          value: 0,
        },
        backgroundIntensity: {
          value: 1,
        },
        backgroundRotation: {
          value: new $e(),
        },
      },
      vertexShader: We.backgroundCube_vert,
      fragmentShader: We.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: {
          value: null,
        },
        tFlip: {
          value: -1,
        },
        opacity: {
          value: 1,
        },
      },
      vertexShader: We.cube_vert,
      fragmentShader: We.cube_frag,
    },
    equirect: {
      uniforms: {
        tEquirect: {
          value: null,
        },
      },
      vertexShader: We.equirect_vert,
      fragmentShader: We.equirect_frag,
    },
    distanceRGBA: {
      uniforms: mn([
        le.common,
        le.displacementmap,
        {
          referencePosition: {
            value: new z(),
          },
          nearDistance: {
            value: 1,
          },
          farDistance: {
            value: 1e3,
          },
        },
      ]),
      vertexShader: We.distanceRGBA_vert,
      fragmentShader: We.distanceRGBA_frag,
    },
    shadow: {
      uniforms: mn([
        le.lights,
        le.fog,
        {
          color: {
            value: new ct(0),
          },
          opacity: {
            value: 1,
          },
        },
      ]),
      vertexShader: We.shadow_vert,
      fragmentShader: We.shadow_frag,
    },
  };
Ni.physical = {
  uniforms: mn([
    Ni.standard.uniforms,
    {
      clearcoat: {
        value: 0,
      },
      clearcoatMap: {
        value: null,
      },
      clearcoatMapTransform: {
        value: new $e(),
      },
      clearcoatNormalMap: {
        value: null,
      },
      clearcoatNormalMapTransform: {
        value: new $e(),
      },
      clearcoatNormalScale: {
        value: new ot(1, 1),
      },
      clearcoatRoughness: {
        value: 0,
      },
      clearcoatRoughnessMap: {
        value: null,
      },
      clearcoatRoughnessMapTransform: {
        value: new $e(),
      },
      iridescence: {
        value: 0,
      },
      iridescenceMap: {
        value: null,
      },
      iridescenceMapTransform: {
        value: new $e(),
      },
      iridescenceIOR: {
        value: 1.3,
      },
      iridescenceThicknessMinimum: {
        value: 100,
      },
      iridescenceThicknessMaximum: {
        value: 400,
      },
      iridescenceThicknessMap: {
        value: null,
      },
      iridescenceThicknessMapTransform: {
        value: new $e(),
      },
      sheen: {
        value: 0,
      },
      sheenColor: {
        value: new ct(0),
      },
      sheenColorMap: {
        value: null,
      },
      sheenColorMapTransform: {
        value: new $e(),
      },
      sheenRoughness: {
        value: 1,
      },
      sheenRoughnessMap: {
        value: null,
      },
      sheenRoughnessMapTransform: {
        value: new $e(),
      },
      transmission: {
        value: 0,
      },
      transmissionMap: {
        value: null,
      },
      transmissionMapTransform: {
        value: new $e(),
      },
      transmissionSamplerSize: {
        value: new ot(),
      },
      transmissionSamplerMap: {
        value: null,
      },
      thickness: {
        value: 0,
      },
      thicknessMap: {
        value: null,
      },
      thicknessMapTransform: {
        value: new $e(),
      },
      attenuationDistance: {
        value: 0,
      },
      attenuationColor: {
        value: new ct(0),
      },
      specularColor: {
        value: new ct(1, 1, 1),
      },
      specularColorMap: {
        value: null,
      },
      specularColorMapTransform: {
        value: new $e(),
      },
      specularIntensity: {
        value: 1,
      },
      specularIntensityMap: {
        value: null,
      },
      specularIntensityMapTransform: {
        value: new $e(),
      },
      anisotropyVector: {
        value: new ot(),
      },
      anisotropyMap: {
        value: null,
      },
      anisotropyMapTransform: {
        value: new $e(),
      },
    },
  ]),
  vertexShader: We.meshphysical_vert,
  fragmentShader: We.meshphysical_frag,
};
const Mu = {
    r: 0,
    b: 0,
    g: 0,
  },
  ws = new gr(),
  LB = new Ft();
function NB(t, e, n, i, r, s, a) {
  const o = new ct(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    d = null,
    h = 0,
    p = null;
  function v(m, f) {
    let y = !1,
      g = f.isScene === !0 ? f.background : null;
    g && g.isTexture && (g = (f.backgroundBlurriness > 0 ? n : e).get(g)),
      g === null ? x(o, l) : g && g.isColor && (x(g, 1), (y = !0));
    const S = t.xr.getEnvironmentBlendMode();
    S === "additive"
      ? i.buffers.color.setClear(0, 0, 0, 1, a)
      : S === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a),
      (t.autoClear || y) &&
        t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil),
      g && (g.isCubeTexture || g.mapping === wh)
        ? (u === void 0 &&
            ((u = new or(
              new Lc(1, 1, 1),
              new os({
                name: "BackgroundCubeMaterial",
                uniforms: To(Ni.backgroundCube.uniforms),
                vertexShader: Ni.backgroundCube.vertexShader,
                fragmentShader: Ni.backgroundCube.fragmentShader,
                side: Dn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (T, A, b) {
              this.matrixWorld.copyPosition(b.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(u)),
          ws.copy(f.backgroundRotation),
          (ws.x *= -1),
          (ws.y *= -1),
          (ws.z *= -1),
          g.isCubeTexture &&
            g.isRenderTargetTexture === !1 &&
            ((ws.y *= -1), (ws.z *= -1)),
          (u.material.uniforms.envMap.value = g),
          (u.material.uniforms.flipEnvMap.value =
            g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            f.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            f.backgroundIntensity),
          u.material.uniforms.backgroundRotation.value.setFromMatrix4(
            LB.makeRotationFromEuler(ws)
          ),
          (u.material.toneMapped = dt.getTransfer(g.colorSpace) !== vt),
          (d !== g || h !== g.version || p !== t.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (d = g),
            (h = g.version),
            (p = t.toneMapping)),
          u.layers.enableAll(),
          m.unshift(u, u.geometry, u.material, 0, 0, null))
        : g &&
          g.isTexture &&
          (c === void 0 &&
            ((c = new or(
              new Mh(2, 2),
              new os({
                name: "BackgroundMaterial",
                uniforms: To(Ni.background.uniforms),
                vertexShader: Ni.background.vertexShader,
                fragmentShader: Ni.background.fragmentShader,
                side: as,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(c)),
          (c.material.uniforms.t2D.value = g),
          (c.material.uniforms.backgroundIntensity.value =
            f.backgroundIntensity),
          (c.material.toneMapped = dt.getTransfer(g.colorSpace) !== vt),
          g.matrixAutoUpdate === !0 && g.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(g.matrix),
          (d !== g || h !== g.version || p !== t.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (d = g),
            (h = g.version),
            (p = t.toneMapping)),
          c.layers.enableAll(),
          m.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function x(m, f) {
    m.getRGB(Mu, bM(t)), i.buffers.color.setClear(Mu.r, Mu.g, Mu.b, f, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (m, f = 1) {
      o.set(m), (l = f), x(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (m) {
      (l = m), x(o, l);
    },
    render: v,
  };
}
function DB(t, e, n, i) {
  const r = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = i.isWebGL2 || s !== null,
    o = {},
    l = m(null);
  let c = l,
    u = !1;
  function d(D, Y, q, W, L) {
    let U = !1;
    if (a) {
      const X = x(W, q, Y);
      c !== X && ((c = X), p(c.object)),
        (U = f(D, W, q, L)),
        U && y(D, W, q, L);
    } else {
      const X = Y.wireframe === !0;
      (c.geometry !== W.id || c.program !== q.id || c.wireframe !== X) &&
        ((c.geometry = W.id), (c.program = q.id), (c.wireframe = X), (U = !0));
    }
    L !== null && n.update(L, t.ELEMENT_ARRAY_BUFFER),
      (U || u) &&
        ((u = !1),
        P(D, Y, q, W),
        L !== null && t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, n.get(L).buffer));
  }
  function h() {
    return i.isWebGL2 ? t.createVertexArray() : s.createVertexArrayOES();
  }
  function p(D) {
    return i.isWebGL2 ? t.bindVertexArray(D) : s.bindVertexArrayOES(D);
  }
  function v(D) {
    return i.isWebGL2 ? t.deleteVertexArray(D) : s.deleteVertexArrayOES(D);
  }
  function x(D, Y, q) {
    const W = q.wireframe === !0;
    let L = o[D.id];
    L === void 0 && ((L = {}), (o[D.id] = L));
    let U = L[Y.id];
    U === void 0 && ((U = {}), (L[Y.id] = U));
    let X = U[W];
    return X === void 0 && ((X = m(h())), (U[W] = X)), X;
  }
  function m(D) {
    const Y = [],
      q = [],
      W = [];
    for (let L = 0; L < r; L++) (Y[L] = 0), (q[L] = 0), (W[L] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: Y,
      enabledAttributes: q,
      attributeDivisors: W,
      object: D,
      attributes: {},
      index: null,
    };
  }
  function f(D, Y, q, W) {
    const L = c.attributes,
      U = Y.attributes;
    let X = 0;
    const K = q.getAttributes();
    for (const oe in K)
      if (K[oe].location >= 0) {
        const V = L[oe];
        let Q = U[oe];
        if (
          (Q === void 0 &&
            (oe === "instanceMatrix" &&
              D.instanceMatrix &&
              (Q = D.instanceMatrix),
            oe === "instanceColor" && D.instanceColor && (Q = D.instanceColor)),
          V === void 0 || V.attribute !== Q || (Q && V.data !== Q.data))
        )
          return !0;
        X++;
      }
    return c.attributesNum !== X || c.index !== W;
  }
  function y(D, Y, q, W) {
    const L = {},
      U = Y.attributes;
    let X = 0;
    const K = q.getAttributes();
    for (const oe in K)
      if (K[oe].location >= 0) {
        let V = U[oe];
        V === void 0 &&
          (oe === "instanceMatrix" &&
            D.instanceMatrix &&
            (V = D.instanceMatrix),
          oe === "instanceColor" && D.instanceColor && (V = D.instanceColor));
        const Q = {};
        (Q.attribute = V), V && V.data && (Q.data = V.data), (L[oe] = Q), X++;
      }
    (c.attributes = L), (c.attributesNum = X), (c.index = W);
  }
  function g() {
    const D = c.newAttributes;
    for (let Y = 0, q = D.length; Y < q; Y++) D[Y] = 0;
  }
  function S(D) {
    T(D, 0);
  }
  function T(D, Y) {
    const q = c.newAttributes,
      W = c.enabledAttributes,
      L = c.attributeDivisors;
    (q[D] = 1),
      W[D] === 0 && (t.enableVertexAttribArray(D), (W[D] = 1)),
      L[D] !== Y &&
        ((i.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](D, Y),
        (L[D] = Y));
  }
  function A() {
    const D = c.newAttributes,
      Y = c.enabledAttributes;
    for (let q = 0, W = Y.length; q < W; q++)
      Y[q] !== D[q] && (t.disableVertexAttribArray(q), (Y[q] = 0));
  }
  function b(D, Y, q, W, L, U, X) {
    X === !0
      ? t.vertexAttribIPointer(D, Y, q, L, U)
      : t.vertexAttribPointer(D, Y, q, W, L, U);
  }
  function P(D, Y, q, W) {
    if (
      i.isWebGL2 === !1 &&
      (D.isInstancedMesh || W.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    g();
    const L = W.attributes,
      U = q.getAttributes(),
      X = Y.defaultAttributeValues;
    for (const K in U) {
      const oe = U[K];
      if (oe.location >= 0) {
        let ke = L[K];
        if (
          (ke === void 0 &&
            (K === "instanceMatrix" &&
              D.instanceMatrix &&
              (ke = D.instanceMatrix),
            K === "instanceColor" && D.instanceColor && (ke = D.instanceColor)),
          ke !== void 0)
        ) {
          const V = ke.normalized,
            Q = ke.itemSize,
            he = n.get(ke);
          if (he === void 0) continue;
          const Re = he.buffer,
            Ee = he.type,
            _e = he.bytesPerElement,
            lt =
              i.isWebGL2 === !0 &&
              (Ee === t.INT || Ee === t.UNSIGNED_INT || ke.gpuType === lM);
          if (ke.isInterleavedBufferAttribute) {
            const Ue = ke.data,
              I = Ue.stride,
              Zt = ke.offset;
            if (Ue.isInstancedInterleavedBuffer) {
              for (let be = 0; be < oe.locationSize; be++)
                T(oe.location + be, Ue.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                W._maxInstanceCount === void 0 &&
                (W._maxInstanceCount = Ue.meshPerAttribute * Ue.count);
            } else
              for (let be = 0; be < oe.locationSize; be++) S(oe.location + be);
            t.bindBuffer(t.ARRAY_BUFFER, Re);
            for (let be = 0; be < oe.locationSize; be++)
              b(
                oe.location + be,
                Q / oe.locationSize,
                Ee,
                V,
                I * _e,
                (Zt + (Q / oe.locationSize) * be) * _e,
                lt
              );
          } else {
            if (ke.isInstancedBufferAttribute) {
              for (let Ue = 0; Ue < oe.locationSize; Ue++)
                T(oe.location + Ue, ke.meshPerAttribute);
              D.isInstancedMesh !== !0 &&
                W._maxInstanceCount === void 0 &&
                (W._maxInstanceCount = ke.meshPerAttribute * ke.count);
            } else
              for (let Ue = 0; Ue < oe.locationSize; Ue++) S(oe.location + Ue);
            t.bindBuffer(t.ARRAY_BUFFER, Re);
            for (let Ue = 0; Ue < oe.locationSize; Ue++)
              b(
                oe.location + Ue,
                Q / oe.locationSize,
                Ee,
                V,
                Q * _e,
                (Q / oe.locationSize) * Ue * _e,
                lt
              );
          }
        } else if (X !== void 0) {
          const V = X[K];
          if (V !== void 0)
            switch (V.length) {
              case 2:
                t.vertexAttrib2fv(oe.location, V);
                break;
              case 3:
                t.vertexAttrib3fv(oe.location, V);
                break;
              case 4:
                t.vertexAttrib4fv(oe.location, V);
                break;
              default:
                t.vertexAttrib1fv(oe.location, V);
            }
        }
      }
    }
    A();
  }
  function G() {
    ie();
    for (const D in o) {
      const Y = o[D];
      for (const q in Y) {
        const W = Y[q];
        for (const L in W) v(W[L].object), delete W[L];
        delete Y[q];
      }
      delete o[D];
    }
  }
  function w(D) {
    if (o[D.id] === void 0) return;
    const Y = o[D.id];
    for (const q in Y) {
      const W = Y[q];
      for (const L in W) v(W[L].object), delete W[L];
      delete Y[q];
    }
    delete o[D.id];
  }
  function R(D) {
    for (const Y in o) {
      const q = o[Y];
      if (q[D.id] === void 0) continue;
      const W = q[D.id];
      for (const L in W) v(W[L].object), delete W[L];
      delete q[D.id];
    }
  }
  function ie() {
    J(), (u = !0), c !== l && ((c = l), p(c.object));
  }
  function J() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: ie,
    resetDefaultState: J,
    dispose: G,
    releaseStatesOfGeometry: w,
    releaseStatesOfProgram: R,
    initAttributes: g,
    enableAttribute: S,
    disableUnusedAttributes: A,
  };
}
function kB(t, e, n, i) {
  const r = i.isWebGL2;
  let s;
  function a(u) {
    s = u;
  }
  function o(u, d) {
    t.drawArrays(s, u, d), n.update(d, s, 1);
  }
  function l(u, d, h) {
    if (h === 0) return;
    let p, v;
    if (r) (p = t), (v = "drawArraysInstanced");
    else if (
      ((p = e.get("ANGLE_instanced_arrays")),
      (v = "drawArraysInstancedANGLE"),
      p === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    p[v](s, u, d, h), n.update(d, s, h);
  }
  function c(u, d, h) {
    if (h === 0) return;
    const p = e.get("WEBGL_multi_draw");
    if (p === null) for (let v = 0; v < h; v++) this.render(u[v], d[v]);
    else {
      p.multiDrawArraysWEBGL(s, u, 0, d, 0, h);
      let v = 0;
      for (let x = 0; x < h; x++) v += d[x];
      n.update(v, s, 1);
    }
  }
  (this.setMode = a),
    (this.render = o),
    (this.renderInstances = l),
    (this.renderMultiDraw = c);
}
function IB(t, e, n) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const b = e.get("EXT_texture_filter_anisotropic");
      i = t.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(b) {
    if (b === "highp") {
      if (
        t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT).precision >
          0 &&
        t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      b = "mediump";
    }
    return b === "mediump" &&
      t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT).precision >
        0 &&
      t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext < "u" &&
    t.constructor.name === "WebGL2RenderingContext";
  let o = n.precision !== void 0 ? n.precision : "highp";
  const l = s(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    u = n.logarithmicDepthBuffer === !0,
    d = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
    h = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = t.getParameter(t.MAX_TEXTURE_SIZE),
    v = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
    x = t.getParameter(t.MAX_VERTEX_ATTRIBS),
    m = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
    f = t.getParameter(t.MAX_VARYING_VECTORS),
    y = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
    g = h > 0,
    S = a || e.has("OES_texture_float"),
    T = g && S,
    A = a ? t.getParameter(t.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: u,
    maxTextures: d,
    maxVertexTextures: h,
    maxTextureSize: p,
    maxCubemapSize: v,
    maxAttributes: x,
    maxVertexUniforms: m,
    maxVaryings: f,
    maxFragmentUniforms: y,
    vertexTextures: g,
    floatFragmentTextures: S,
    floatVertexTextures: T,
    maxSamples: A,
  };
}
function UB(t) {
  const e = this;
  let n = null,
    i = 0,
    r = !1,
    s = !1;
  const a = new Rs(),
    o = new $e(),
    l = {
      value: null,
      needsUpdate: !1,
    };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, h) {
      const p = d.length !== 0 || h || i !== 0 || r;
      return (r = h), (i = d.length), p;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, h) {
      n = u(d, h, 0);
    }),
    (this.setState = function (d, h, p) {
      const v = d.clippingPlanes,
        x = d.clipIntersection,
        m = d.clipShadows,
        f = t.get(d);
      if (!r || v === null || v.length === 0 || (s && !m)) s ? u(null) : c();
      else {
        const y = s ? 0 : i,
          g = y * 4;
        let S = f.clippingState || null;
        (l.value = S), (S = u(v, h, g, p));
        for (let T = 0; T !== g; ++T) S[T] = n[T];
        (f.clippingState = S),
          (this.numIntersection = x ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function c() {
    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function u(d, h, p, v) {
    const x = d !== null ? d.length : 0;
    let m = null;
    if (x !== 0) {
      if (((m = l.value), v !== !0 || m === null)) {
        const f = p + x * 4,
          y = h.matrixWorldInverse;
        o.getNormalMatrix(y),
          (m === null || m.length < f) && (m = new Float32Array(f));
        for (let g = 0, S = p; g !== x; ++g, S += 4)
          a.copy(d[g]).applyMatrix4(y, o),
            a.normal.toArray(m, S),
            (m[S + 3] = a.constant);
      }
      (l.value = m), (l.needsUpdate = !0);
    }
    return (e.numPlanes = x), (e.numIntersection = 0), m;
  }
}
function OB(t) {
  let e = new WeakMap();
  function n(a, o) {
    return o === Im ? (a.mapping = So) : o === Um && (a.mapping = wo), a;
  }
  function i(a) {
    if (a && a.isTexture) {
      const o = a.mapping;
      if (o === Im || o === Um)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return n(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new XO(l.height);
            return (
              c.fromEquirectangularTexture(t, a),
              e.set(a, c),
              a.addEventListener("dispose", r),
              n(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function r(a) {
    const o = a.target;
    o.removeEventListener("dispose", r);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return {
    get: i,
    dispose: s,
  };
}
class FB extends AM {
  constructor(e = -1, n = 1, i = 1, r = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = n),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, n, i, r, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = n),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      n = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      a = i + e,
      o = r + n,
      l = r - n;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= u * this.view.offsetY),
        (l = o - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      a,
      o,
      l,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      (n.object.zoom = this.zoom),
      (n.object.left = this.left),
      (n.object.right = this.right),
      (n.object.top = this.top),
      (n.object.bottom = this.bottom),
      (n.object.near = this.near),
      (n.object.far = this.far),
      this.view !== null && (n.object.view = Object.assign({}, this.view)),
      n
    );
  }
}
const qa = 4,
  $x = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Ds = 20,
  ep = new FB(),
  Xx = new ct();
let tp = null,
  np = 0,
  ip = 0;
const Ps = (1 + Math.sqrt(5)) / 2,
  Aa = 1 / Ps,
  qx = [
    new z(1, 1, 1),
    new z(-1, 1, 1),
    new z(1, 1, -1),
    new z(-1, 1, -1),
    new z(0, Ps, Aa),
    new z(0, Ps, -Aa),
    new z(Aa, 0, Ps),
    new z(-Aa, 0, Ps),
    new z(Ps, Aa, 0),
    new z(-Ps, Aa, 0),
  ];
class Yx {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, n = 0, i = 0.1, r = 100) {
    (tp = this._renderer.getRenderTarget()),
      (np = this._renderer.getActiveCubeFace()),
      (ip = this._renderer.getActiveMipmapLevel()),
      this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      n > 0 && this._blur(s, 0, 0, n),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, n = null) {
    return this._fromTexture(e, n);
  }
  fromCubemap(e, n = null) {
    return this._fromTexture(e, n);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Jx()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Kx()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(tp, np, ip),
      (e.scissorTest = !1),
      bu(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, n) {
    e.mapping === So || e.mapping === wo
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (tp = this._renderer.getRenderTarget()),
      (np = this._renderer.getActiveCubeFace()),
      (ip = this._renderer.getActiveMipmapLevel());
    const i = n || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      n = 4 * this._cubeSize,
      i = {
        magFilter: Mn,
        minFilter: Mn,
        generateMipmaps: !1,
        type: hc,
        format: _i,
        colorSpace: fs,
        depthBuffer: !1,
      },
      r = Zx(e, n, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== n
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Zx(e, n, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = BB(s)),
        (this._blurMaterial = zB(s, e, n));
    }
    return r;
  }
  _compileMaterial(e) {
    const n = new or(this._lodPlanes[0], e);
    this._renderer.compile(n, ep);
  }
  _sceneToCubeUV(e, n, i, r) {
    const o = new ti(90, 1, n, i),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      d = u.autoClear,
      h = u.toneMapping;
    u.getClearColor(Xx), (u.toneMapping = Kr), (u.autoClear = !1);
    const p = new EM({
        name: "PMREM.Background",
        side: Dn,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new or(new Lc(), p);
    let x = !1;
    const m = e.background;
    m
      ? m.isColor && (p.color.copy(m), (e.background = null), (x = !0))
      : (p.color.copy(Xx), (x = !0));
    for (let f = 0; f < 6; f++) {
      const y = f % 3;
      y === 0
        ? (o.up.set(0, l[f], 0), o.lookAt(c[f], 0, 0))
        : y === 1
        ? (o.up.set(0, 0, l[f]), o.lookAt(0, c[f], 0))
        : (o.up.set(0, l[f], 0), o.lookAt(0, 0, c[f]));
      const g = this._cubeSize;
      bu(r, y * g, f > 2 ? g : 0, g, g),
        u.setRenderTarget(r),
        x && u.render(v, o),
        u.render(e, o);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (u.toneMapping = h),
      (u.autoClear = d),
      (e.background = m);
  }
  _textureToCubeUV(e, n) {
    const i = this._renderer,
      r = e.mapping === So || e.mapping === wo;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Jx()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Kx());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      a = new or(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    bu(n, 0, 0, 3 * l, 2 * l), i.setRenderTarget(n), i.render(a, ep);
  }
  _applyPMREM(e) {
    const n = this._renderer,
      i = n.autoClear;
    n.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        a = qx[(r - 1) % qx.length];
      this._blur(e, r - 1, r, s, a);
    }
    n.autoClear = i;
  }
  _blur(e, n, i, r, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, n, i, r, "latitudinal", s),
      this._halfBlur(a, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, n, i, r, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      d = new or(this._lodPlanes[r], c),
      h = c.uniforms,
      p = this._sizeLods[i] - 1,
      v = isFinite(s) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * Ds - 1),
      x = s / v,
      m = isFinite(s) ? 1 + Math.floor(u * x) : Ds;
    m > Ds &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${Ds}`
      );
    const f = [];
    let y = 0;
    for (let b = 0; b < Ds; ++b) {
      const P = b / x,
        G = Math.exp((-P * P) / 2);
      f.push(G), b === 0 ? (y += G) : b < m && (y += 2 * G);
    }
    for (let b = 0; b < f.length; b++) f[b] = f[b] / y;
    (h.envMap.value = e.texture),
      (h.samples.value = m),
      (h.weights.value = f),
      (h.latitudinal.value = a === "latitudinal"),
      o && (h.poleAxis.value = o);
    const { _lodMax: g } = this;
    (h.dTheta.value = v), (h.mipInt.value = g - i);
    const S = this._sizeLods[r],
      T = 3 * S * (r > g - qa ? r - g + qa : 0),
      A = 4 * (this._cubeSize - S);
    bu(n, T, A, 3 * S, 2 * S), l.setRenderTarget(n), l.render(d, ep);
  }
}
function BB(t) {
  const e = [],
    n = [],
    i = [];
  let r = t;
  const s = t - qa + 1 + $x.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, r);
    n.push(o);
    let l = 1 / o;
    a > t - qa ? (l = $x[a - t + qa - 1]) : a === 0 && (l = 0), i.push(l);
    const c = 1 / (o - 2),
      u = -c,
      d = 1 + c,
      h = [u, u, d, u, d, d, u, u, d, d, u, d],
      p = 6,
      v = 6,
      x = 3,
      m = 2,
      f = 1,
      y = new Float32Array(x * v * p),
      g = new Float32Array(m * v * p),
      S = new Float32Array(f * v * p);
    for (let A = 0; A < p; A++) {
      const b = ((A % 3) * 2) / 3 - 1,
        P = A > 2 ? 0 : -1,
        G = [
          b,
          P,
          0,
          b + 2 / 3,
          P,
          0,
          b + 2 / 3,
          P + 1,
          0,
          b,
          P,
          0,
          b + 2 / 3,
          P + 1,
          0,
          b,
          P + 1,
          0,
        ];
      y.set(G, x * v * A), g.set(h, m * v * A);
      const w = [A, A, A, A, A, A];
      S.set(w, f * v * A);
    }
    const T = new _r();
    T.setAttribute("position", new Ei(y, x)),
      T.setAttribute("uv", new Ei(g, m)),
      T.setAttribute("faceIndex", new Ei(S, f)),
      e.push(T),
      r > qa && r--;
  }
  return {
    lodPlanes: e,
    sizeLods: n,
    sigmas: i,
  };
}
function Zx(t, e, n) {
  const i = new ta(t, e, n);
  return (
    (i.texture.mapping = wh),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function bu(t, e, n, i, r) {
  t.viewport.set(e, n, i, r), t.scissor.set(e, n, i, r);
}
function zB(t, e, n) {
  const i = new Float32Array(Ds),
    r = new z(0, 1, 0);
  return new os({
    name: "SphericalGaussianBlur",
    defines: {
      n: Ds,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / n,
      CUBEUV_MAX_MIP: `${t}.0`,
    },
    uniforms: {
      envMap: {
        value: null,
      },
      samples: {
        value: 1,
      },
      weights: {
        value: i,
      },
      latitudinal: {
        value: !1,
      },
      dTheta: {
        value: 0,
      },
      mipInt: {
        value: 0,
      },
      poleAxis: {
        value: r,
      },
    },
    vertexShader: Lv(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,

    blending: Zr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Kx() {
  return new os({
    name: "EquirectangularToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
    },
    vertexShader: Lv(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,

    blending: Zr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Jx() {
  return new os({
    name: "CubemapToCubeUV",
    uniforms: {
      envMap: {
        value: null,
      },
      flipEnvMap: {
        value: -1,
      },
    },
    vertexShader: Lv(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,

    blending: Zr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Lv() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function jB(t) {
  let e = new WeakMap(),
    n = null;
  function i(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === Im || l === Um,
        u = l === So || l === wo;
      if (c || u)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let d = e.get(o);
          return (
            n === null && (n = new Yx(t)),
            (d = c ? n.fromEquirectangular(o, d) : n.fromCubemap(o, d)),
            e.set(o, d),
            d.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const d = o.image;
            if ((c && d && d.height > 0) || (u && d && r(d))) {
              n === null && (n = new Yx(t));
              const h = c ? n.fromEquirectangular(o) : n.fromCubemap(o);
              return e.set(o, h), o.addEventListener("dispose", s), h.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function r(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), n !== null && (n.dispose(), (n = null));
  }
  return {
    get: i,
    dispose: a,
  };
}
function VB(t) {
  const e = {};
  function n(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          t.getExtension("WEBGL_depth_texture") ||
          t.getExtension("MOZ_WEBGL_depth_texture") ||
          t.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          t.getExtension("EXT_texture_filter_anisotropic") ||
          t.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          t.getExtension("WEBGL_compressed_texture_s3tc") ||
          t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          t.getExtension("WEBGL_compressed_texture_pvrtc") ||
          t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = t.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return n(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? (n("EXT_color_buffer_float"), n("WEBGL_clip_cull_distance"))
        : (n("WEBGL_depth_texture"),
          n("OES_texture_float"),
          n("OES_texture_half_float"),
          n("OES_texture_half_float_linear"),
          n("OES_standard_derivatives"),
          n("OES_element_index_uint"),
          n("OES_vertex_array_object"),
          n("ANGLE_instanced_arrays")),
        n("OES_texture_float_linear"),
        n("EXT_color_buffer_half_float"),
        n("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = n(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function HB(t, e, n, i) {
  const r = {},
    s = new WeakMap();
  function a(d) {
    const h = d.target;
    h.index !== null && e.remove(h.index);
    for (const v in h.attributes) e.remove(h.attributes[v]);
    for (const v in h.morphAttributes) {
      const x = h.morphAttributes[v];
      for (let m = 0, f = x.length; m < f; m++) e.remove(x[m]);
    }
    h.removeEventListener("dispose", a), delete r[h.id];
    const p = s.get(h);
    p && (e.remove(p), s.delete(h)),
      i.releaseStatesOfGeometry(h),
      h.isInstancedBufferGeometry === !0 && delete h._maxInstanceCount,
      n.memory.geometries--;
  }
  function o(d, h) {
    return (
      r[h.id] === !0 ||
        (h.addEventListener("dispose", a),
        (r[h.id] = !0),
        n.memory.geometries++),
      h
    );
  }
  function l(d) {
    const h = d.attributes;
    for (const v in h) e.update(h[v], t.ARRAY_BUFFER);
    const p = d.morphAttributes;
    for (const v in p) {
      const x = p[v];
      for (let m = 0, f = x.length; m < f; m++) e.update(x[m], t.ARRAY_BUFFER);
    }
  }
  function c(d) {
    const h = [],
      p = d.index,
      v = d.attributes.position;
    let x = 0;
    if (p !== null) {
      const y = p.array;
      x = p.version;
      for (let g = 0, S = y.length; g < S; g += 3) {
        const T = y[g + 0],
          A = y[g + 1],
          b = y[g + 2];
        h.push(T, A, A, b, b, T);
      }
    } else if (v !== void 0) {
      const y = v.array;
      x = v.version;
      for (let g = 0, S = y.length / 3 - 1; g < S; g += 3) {
        const T = g + 0,
          A = g + 1,
          b = g + 2;
        h.push(T, A, A, b, b, T);
      }
    } else return;
    const m = new (gM(h) ? MM : TM)(h, 1);
    m.version = x;
    const f = s.get(d);
    f && e.remove(f), s.set(d, m);
  }
  function u(d) {
    const h = s.get(d);
    if (h) {
      const p = d.index;
      p !== null && h.version < p.version && c(d);
    } else c(d);
    return s.get(d);
  }
  return {
    get: o,
    update: l,
    getWireframeAttribute: u,
  };
}
function GB(t, e, n, i) {
  const r = i.isWebGL2;
  let s;
  function a(p) {
    s = p;
  }
  let o, l;
  function c(p) {
    (o = p.type), (l = p.bytesPerElement);
  }
  function u(p, v) {
    t.drawElements(s, v, o, p * l), n.update(v, s, 1);
  }
  function d(p, v, x) {
    if (x === 0) return;
    let m, f;
    if (r) (m = t), (f = "drawElementsInstanced");
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (f = "drawElementsInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[f](s, v, o, p * l, x), n.update(v, s, x);
  }
  function h(p, v, x) {
    if (x === 0) return;
    const m = e.get("WEBGL_multi_draw");
    if (m === null) for (let f = 0; f < x; f++) this.render(p[f] / l, v[f]);
    else {
      m.multiDrawElementsWEBGL(s, v, 0, o, p, 0, x);
      let f = 0;
      for (let y = 0; y < x; y++) f += v[y];
      n.update(f, s, 1);
    }
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = u),
    (this.renderInstances = d),
    (this.renderMultiDraw = h);
}
function WB(t) {
  const e = {
      geometries: 0,
      textures: 0,
    },
    n = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
    };
  function i(s, a, o) {
    switch ((n.calls++, a)) {
      case t.TRIANGLES:
        n.triangles += o * (s / 3);
        break;
      case t.LINES:
        n.lines += o * (s / 2);
        break;
      case t.LINE_STRIP:
        n.lines += o * (s - 1);
        break;
      case t.LINE_LOOP:
        n.lines += o * s;
        break;
      case t.POINTS:
        n.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function r() {
    (n.calls = 0), (n.triangles = 0), (n.points = 0), (n.lines = 0);
  }
  return {
    memory: e,
    render: n,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function $B(t, e) {
  return t[0] - e[0];
}
function XB(t, e) {
  return Math.abs(e[1]) - Math.abs(t[1]);
}
function qB(t, e, n) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    a = new Qt(),
    o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function l(c, u, d) {
    const h = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const p =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        v = p !== void 0 ? p.length : 0;
      let x = s.get(u);
      if (x === void 0 || x.count !== v) {
        let ie = function () {
          w.dispose(), s.delete(u), u.removeEventListener("dispose", ie);
        };
        x !== void 0 && x.texture.dispose();
        const m = u.morphAttributes.position !== void 0,
          f = u.morphAttributes.normal !== void 0,
          y = u.morphAttributes.color !== void 0,
          g = u.morphAttributes.position || [],
          S = u.morphAttributes.normal || [],
          T = u.morphAttributes.color || [];
        let A = 0;
        m === !0 && (A = 1), f === !0 && (A = 2), y === !0 && (A = 3);
        let b = u.attributes.position.count * A,
          P = 1;
        b > e.maxTextureSize &&
          ((P = Math.ceil(b / e.maxTextureSize)), (b = e.maxTextureSize));
        const G = new Float32Array(b * P * 4 * v),
          w = new yM(G, b, P, v);
        (w.type = ir), (w.needsUpdate = !0);
        const R = A * 4;
        for (let J = 0; J < v; J++) {
          const D = g[J],
            Y = S[J],
            q = T[J],
            W = b * P * 4 * J;
          for (let L = 0; L < D.count; L++) {
            const U = L * R;
            m === !0 &&
              (a.fromBufferAttribute(D, L),
              (G[W + U + 0] = a.x),
              (G[W + U + 1] = a.y),
              (G[W + U + 2] = a.z),
              (G[W + U + 3] = 0)),
              f === !0 &&
                (a.fromBufferAttribute(Y, L),
                (G[W + U + 4] = a.x),
                (G[W + U + 5] = a.y),
                (G[W + U + 6] = a.z),
                (G[W + U + 7] = 0)),
              y === !0 &&
                (a.fromBufferAttribute(q, L),
                (G[W + U + 8] = a.x),
                (G[W + U + 9] = a.y),
                (G[W + U + 10] = a.z),
                (G[W + U + 11] = q.itemSize === 4 ? a.w : 1));
          }
        }
        (x = {
          count: v,
          texture: w,
          size: new ot(b, P),
        }),
          s.set(u, x),
          u.addEventListener("dispose", ie);
      }
      if (c.isInstancedMesh === !0 && c.morphTexture !== null)
        d.getUniforms().setValue(t, "morphTexture", c.morphTexture, n);
      else {
        let m = 0;
        for (let y = 0; y < h.length; y++) m += h[y];
        const f = u.morphTargetsRelative ? 1 : 1 - m;
        d.getUniforms().setValue(t, "morphTargetBaseInfluence", f),
          d.getUniforms().setValue(t, "morphTargetInfluences", h);
      }
      d.getUniforms().setValue(t, "morphTargetsTexture", x.texture, n),
        d.getUniforms().setValue(t, "morphTargetsTextureSize", x.size);
    } else {
      const p = h === void 0 ? 0 : h.length;
      let v = i[u.id];
      if (v === void 0 || v.length !== p) {
        v = [];
        for (let g = 0; g < p; g++) v[g] = [g, 0];
        i[u.id] = v;
      }
      for (let g = 0; g < p; g++) {
        const S = v[g];
        (S[0] = g), (S[1] = h[g]);
      }
      v.sort(XB);
      for (let g = 0; g < 8; g++)
        g < p && v[g][1]
          ? ((o[g][0] = v[g][0]), (o[g][1] = v[g][1]))
          : ((o[g][0] = Number.MAX_SAFE_INTEGER), (o[g][1] = 0));
      o.sort($B);
      const x = u.morphAttributes.position,
        m = u.morphAttributes.normal;
      let f = 0;
      for (let g = 0; g < 8; g++) {
        const S = o[g],
          T = S[0],
          A = S[1];
        T !== Number.MAX_SAFE_INTEGER && A
          ? (x &&
              u.getAttribute("morphTarget" + g) !== x[T] &&
              u.setAttribute("morphTarget" + g, x[T]),
            m &&
              u.getAttribute("morphNormal" + g) !== m[T] &&
              u.setAttribute("morphNormal" + g, m[T]),
            (r[g] = A),
            (f += A))
          : (x &&
              u.hasAttribute("morphTarget" + g) === !0 &&
              u.deleteAttribute("morphTarget" + g),
            m &&
              u.hasAttribute("morphNormal" + g) === !0 &&
              u.deleteAttribute("morphNormal" + g),
            (r[g] = 0));
      }
      const y = u.morphTargetsRelative ? 1 : 1 - f;
      d.getUniforms().setValue(t, "morphTargetBaseInfluence", y),
        d.getUniforms().setValue(t, "morphTargetInfluences", r);
    }
  }
  return {
    update: l,
  };
}
function YB(t, e, n, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      u = l.geometry,
      d = e.get(l, u);
    if (
      (r.get(d) !== c && (e.update(d), r.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        r.get(l) !== c &&
          (n.update(l.instanceMatrix, t.ARRAY_BUFFER),
          l.instanceColor !== null && n.update(l.instanceColor, t.ARRAY_BUFFER),
          r.set(l, c))),
      l.isSkinnedMesh)
    ) {
      const h = l.skeleton;
      r.get(h) !== c && (h.update(), r.set(h, c));
    }
    return d;
  }
  function a() {
    r = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      n.remove(c.instanceMatrix),
      c.instanceColor !== null && n.remove(c.instanceColor);
  }
  return {
    update: s,
    dispose: a,
  };
}
class LM extends kn {
  constructor(e, n, i, r, s, a, o, l, c, u) {
    if (((u = u !== void 0 ? u : Gs), u !== Gs && u !== Eo))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && u === Gs && (i = zr),
      i === void 0 && u === Eo && (i = Hs),
      super(null, r, s, a, o, l, u, i, c),
      (this.isDepthTexture = !0),
      (this.image = {
        width: e,
        height: n,
      }),
      (this.magFilter = o !== void 0 ? o : vn),
      (this.minFilter = l !== void 0 ? l : vn),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.compareFunction !== null &&
        (n.compareFunction = this.compareFunction),
      n
    );
  }
}
const NM = new kn(),
  DM = new LM(1, 1);
DM.compareFunction = mM;
const kM = new yM(),
  IM = new PO(),
  UM = new CM(),
  Qx = [],
  eS = [],
  tS = new Float32Array(16),
  nS = new Float32Array(9),
  iS = new Float32Array(4);
function Io(t, e, n) {
  const i = t[0];
  if (i <= 0 || i > 0) return t;
  const r = e * n;
  let s = Qx[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (Qx[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += n), t[a].toArray(s, o);
  }
  return s;
}
function jt(t, e) {
  if (t.length !== e.length) return !1;
  for (let n = 0, i = t.length; n < i; n++) if (t[n] !== e[n]) return !1;
  return !0;
}
function Vt(t, e) {
  for (let n = 0, i = e.length; n < i; n++) t[n] = e[n];
}
function bh(t, e) {
  let n = eS[e];
  n === void 0 && ((n = new Int32Array(e)), (eS[e] = n));
  for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
  return n;
}
function ZB(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1f(this.addr, e), (n[0] = e));
}
function KB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2f(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (jt(n, e)) return;
    t.uniform2fv(this.addr, e), Vt(n, e);
  }
}
function JB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3f(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else if (e.r !== void 0)
    (n[0] !== e.r || n[1] !== e.g || n[2] !== e.b) &&
      (t.uniform3f(this.addr, e.r, e.g, e.b),
      (n[0] = e.r),
      (n[1] = e.g),
      (n[2] = e.b));
  else {
    if (jt(n, e)) return;
    t.uniform3fv(this.addr, e), Vt(n, e);
  }
}
function QB(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (jt(n, e)) return;
    t.uniform4fv(this.addr, e), Vt(n, e);
  }
}
function ez(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (jt(n, e)) return;
    t.uniformMatrix2fv(this.addr, !1, e), Vt(n, e);
  } else {
    if (jt(n, i)) return;
    iS.set(i), t.uniformMatrix2fv(this.addr, !1, iS), Vt(n, i);
  }
}
function tz(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (jt(n, e)) return;
    t.uniformMatrix3fv(this.addr, !1, e), Vt(n, e);
  } else {
    if (jt(n, i)) return;
    nS.set(i), t.uniformMatrix3fv(this.addr, !1, nS), Vt(n, i);
  }
}
function nz(t, e) {
  const n = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (jt(n, e)) return;
    t.uniformMatrix4fv(this.addr, !1, e), Vt(n, e);
  } else {
    if (jt(n, i)) return;
    tS.set(i), t.uniformMatrix4fv(this.addr, !1, tS), Vt(n, i);
  }
}
function iz(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1i(this.addr, e), (n[0] = e));
}
function rz(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2i(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (jt(n, e)) return;
    t.uniform2iv(this.addr, e), Vt(n, e);
  }
}
function sz(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3i(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (jt(n, e)) return;
    t.uniform3iv(this.addr, e), Vt(n, e);
  }
}
function az(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (jt(n, e)) return;
    t.uniform4iv(this.addr, e), Vt(n, e);
  }
}
function oz(t, e) {
  const n = this.cache;
  n[0] !== e && (t.uniform1ui(this.addr, e), (n[0] = e));
}
function lz(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y) &&
      (t.uniform2ui(this.addr, e.x, e.y), (n[0] = e.x), (n[1] = e.y));
  else {
    if (jt(n, e)) return;
    t.uniform2uiv(this.addr, e), Vt(n, e);
  }
}
function cz(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z) &&
      (t.uniform3ui(this.addr, e.x, e.y, e.z),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z));
  else {
    if (jt(n, e)) return;
    t.uniform3uiv(this.addr, e), Vt(n, e);
  }
}
function uz(t, e) {
  const n = this.cache;
  if (e.x !== void 0)
    (n[0] !== e.x || n[1] !== e.y || n[2] !== e.z || n[3] !== e.w) &&
      (t.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (n[0] = e.x),
      (n[1] = e.y),
      (n[2] = e.z),
      (n[3] = e.w));
  else {
    if (jt(n, e)) return;
    t.uniform4uiv(this.addr, e), Vt(n, e);
  }
}
function dz(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r));
  const s = this.type === t.SAMPLER_2D_SHADOW ? DM : NM;
  n.setTexture2D(e || s, r);
}
function hz(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture3D(e || IM, r);
}
function fz(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTextureCube(e || UM, r);
}
function pz(t, e, n) {
  const i = this.cache,
    r = n.allocateTextureUnit();
  i[0] !== r && (t.uniform1i(this.addr, r), (i[0] = r)),
    n.setTexture2DArray(e || kM, r);
}
function mz(t) {
  switch (t) {
    case 5126:
      return ZB;
    case 35664:
      return KB;
    case 35665:
      return JB;
    case 35666:
      return QB;
    case 35674:
      return ez;
    case 35675:
      return tz;
    case 35676:
      return nz;
    case 5124:
    case 35670:
      return iz;
    case 35667:
    case 35671:
      return rz;
    case 35668:
    case 35672:
      return sz;
    case 35669:
    case 35673:
      return az;
    case 5125:
      return oz;
    case 36294:
      return lz;
    case 36295:
      return cz;
    case 36296:
      return uz;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return dz;
    case 35679:
    case 36299:
    case 36307:
      return hz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return fz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return pz;
  }
}
function gz(t, e) {
  t.uniform1fv(this.addr, e);
}
function vz(t, e) {
  const n = Io(e, this.size, 2);
  t.uniform2fv(this.addr, n);
}
function _z(t, e) {
  const n = Io(e, this.size, 3);
  t.uniform3fv(this.addr, n);
}
function yz(t, e) {
  const n = Io(e, this.size, 4);
  t.uniform4fv(this.addr, n);
}
function xz(t, e) {
  const n = Io(e, this.size, 4);
  t.uniformMatrix2fv(this.addr, !1, n);
}
function Sz(t, e) {
  const n = Io(e, this.size, 9);
  t.uniformMatrix3fv(this.addr, !1, n);
}
function wz(t, e) {
  const n = Io(e, this.size, 16);
  t.uniformMatrix4fv(this.addr, !1, n);
}
function Ez(t, e) {
  t.uniform1iv(this.addr, e);
}
function Tz(t, e) {
  t.uniform2iv(this.addr, e);
}
function Mz(t, e) {
  t.uniform3iv(this.addr, e);
}
function bz(t, e) {
  t.uniform4iv(this.addr, e);
}
function Az(t, e) {
  t.uniform1uiv(this.addr, e);
}
function Cz(t, e) {
  t.uniform2uiv(this.addr, e);
}
function Rz(t, e) {
  t.uniform3uiv(this.addr, e);
}
function Pz(t, e) {
  t.uniform4uiv(this.addr, e);
}
function Lz(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = bh(n, r);
  jt(i, s) || (t.uniform1iv(this.addr, s), Vt(i, s));
  for (let a = 0; a !== r; ++a) n.setTexture2D(e[a] || NM, s[a]);
}
function Nz(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = bh(n, r);
  jt(i, s) || (t.uniform1iv(this.addr, s), Vt(i, s));
  for (let a = 0; a !== r; ++a) n.setTexture3D(e[a] || IM, s[a]);
}
function Dz(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = bh(n, r);
  jt(i, s) || (t.uniform1iv(this.addr, s), Vt(i, s));
  for (let a = 0; a !== r; ++a) n.setTextureCube(e[a] || UM, s[a]);
}
function kz(t, e, n) {
  const i = this.cache,
    r = e.length,
    s = bh(n, r);
  jt(i, s) || (t.uniform1iv(this.addr, s), Vt(i, s));
  for (let a = 0; a !== r; ++a) n.setTexture2DArray(e[a] || kM, s[a]);
}
function Iz(t) {
  switch (t) {
    case 5126:
      return gz;
    case 35664:
      return vz;
    case 35665:
      return _z;
    case 35666:
      return yz;
    case 35674:
      return xz;
    case 35675:
      return Sz;
    case 35676:
      return wz;
    case 5124:
    case 35670:
      return Ez;
    case 35667:
    case 35671:
      return Tz;
    case 35668:
    case 35672:
      return Mz;
    case 35669:
    case 35673:
      return bz;
    case 5125:
      return Az;
    case 36294:
      return Cz;
    case 36295:
      return Rz;
    case 36296:
      return Pz;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return Lz;
    case 35679:
    case 36299:
    case 36307:
      return Nz;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return Dz;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return kz;
  }
}
class Uz {
  constructor(e, n, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = n.type),
      (this.setValue = mz(n.type));
  }
}
class Oz {
  constructor(e, n, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.type = n.type),
      (this.size = n.size),
      (this.setValue = Iz(n.type));
  }
}
class Fz {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, n, i) {
    const r = this.seq;
    for (let s = 0, a = r.length; s !== a; ++s) {
      const o = r[s];
      o.setValue(e, n[o.id], i);
    }
  }
}
const rp = /(\w+)(\])?(\[|\.)?/g;
function rS(t, e) {
  t.seq.push(e), (t.map[e.id] = e);
}
function Bz(t, e, n) {
  const i = t.name,
    r = i.length;
  for (rp.lastIndex = 0; ; ) {
    const s = rp.exec(i),
      a = rp.lastIndex;
    let o = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === r))) {
      rS(n, c === void 0 ? new Uz(o, t, e) : new Oz(o, t, e));
      break;
    } else {
      let d = n.map[o];
      d === void 0 && ((d = new Fz(o)), rS(n, d)), (n = d);
    }
  }
}
class qu {
  constructor(e, n) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(n, e.ACTIVE_UNIFORMS);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(n, r),
        a = e.getUniformLocation(n, s.name);
      Bz(s, a, this);
    }
  }
  setValue(e, n, i, r) {
    const s = this.map[n];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, n, i) {
    const r = n[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, n, i, r) {
    for (let s = 0, a = n.length; s !== a; ++s) {
      const o = n[s],
        l = i[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, n) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const a = e[r];
      a.id in n && i.push(a);
    }
    return i;
  }
}
function sS(t, e, n) {
  const i = t.createShader(e);
  return t.shaderSource(i, n), t.compileShader(i), i;
}
const zz = 37297;
let jz = 0;
function Vz(t, e) {
  const n = t.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, n.length);
  for (let a = r; a < s; a++) {
    const o = a + 1;
    i.push(`${o === e ? ">" : " "} ${o}: ${n[a]}`);
  }
  return i.join(`
`);
}
function Hz(t) {
  const e = dt.getPrimaries(dt.workingColorSpace),
    n = dt.getPrimaries(t);
  let i;
  switch (
    (e === n
      ? (i = "")
      : e === zd && n === Bd
      ? (i = "LinearDisplayP3ToLinearSRGB")
      : e === Bd && n === zd && (i = "LinearSRGBToLinearDisplayP3"),
    t)
  ) {
    case fs:
    case Eh:
      return [i, "LinearTransferOETF"];
    case Li:
    case Pv:
      return [i, "sRGBTransferOETF"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", t),
        [i, "LinearTransferOETF"]
      );
  }
}
function aS(t, e, n) {
  const i = t.getShaderParameter(e, t.COMPILE_STATUS),
    r = t.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const a = parseInt(s[1]);
    return (
      n.toUpperCase() +
      `

` +
      r +
      `

` +
      Vz(t.getShaderSource(e), a)
    );
  } else return r;
}
function Gz(t, e) {
  const n = Hz(e);
  return `vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`;
}
function Wz(t, e) {
  let n;
  switch (e) {
    case KU:
      n = "Linear";
      break;
    case JU:
      n = "Reinhard";
      break;
    case QU:
      n = "OptimizedCineon";
      break;
    case eO:
      n = "ACESFilmic";
      break;
    case nO:
      n = "AgX";
      break;
    case iO:
      n = "Neutral";
      break;
    case tO:
      n = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (n = "Linear");
  }
  return (
    "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
  );
}
function $z(t) {
  return [
    t.extensionDerivatives ||
    t.envMapCubeUVHeight ||
    t.bumpMap ||
    t.normalMapTangentSpace ||
    t.clearcoatNormalMap ||
    t.flatShading ||
    t.alphaToCoverage ||
    t.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (t.extensionFragDepth || t.logarithmicDepthBuffer) &&
    t.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    t.extensionDrawBuffers && t.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (t.extensionShaderTextureLOD || t.envMap || t.transmission) &&
    t.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(Ya).join(`
`);
}
function Xz(t) {
  return [
    t.extensionClipCullDistance
      ? "#extension GL_ANGLE_clip_cull_distance : require"
      : "",
    t.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : "",
  ].filter(Ya).join(`
`);
}
function qz(t) {
  const e = [];
  for (const n in t) {
    const i = t[n];
    i !== !1 && e.push("#define " + n + " " + i);
  }
  return e.join(`
`);
}
function Yz(t, e) {
  const n = {},
    i = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
  for (let r = 0; r < i; r++) {
    const s = t.getActiveAttrib(e, r),
      a = s.name;
    let o = 1;
    s.type === t.FLOAT_MAT2 && (o = 2),
      s.type === t.FLOAT_MAT3 && (o = 3),
      s.type === t.FLOAT_MAT4 && (o = 4),
      (n[a] = {
        type: s.type,
        location: t.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return n;
}
function Ya(t) {
  return t !== "";
}
function oS(t, e) {
  const n =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return t
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function lS(t, e) {
  return t
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const Zz = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Vm(t) {
  return t.replace(Zz, Jz);
}
const Kz = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function Jz(t, e) {
  let n = We[e];
  if (n === void 0) {
    const i = Kz.get(e);
    if (i !== void 0)
      (n = We[i]),
        console.warn(
          'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
          e,
          i
        );
    else throw new Error("Can not resolve #include <" + e + ">");
  }
  return Vm(n);
}
const Qz =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function cS(t) {
  return t.replace(Qz, ej);
}
function ej(t, e, n, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(n); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function uS(t) {
  let e = `precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	`;
  return (
    t.isWebGL2 &&
      (e += `precision ${t.precision} sampler3D;
		precision ${t.precision} sampler2DArray;
		precision ${t.precision} sampler2DShadow;
		precision ${t.precision} samplerCubeShadow;
		precision ${t.precision} sampler2DArrayShadow;
		precision ${t.precision} isampler2D;
		precision ${t.precision} isampler3D;
		precision ${t.precision} isamplerCube;
		precision ${t.precision} isampler2DArray;
		precision ${t.precision} usampler2D;
		precision ${t.precision} usampler3D;
		precision ${t.precision} usamplerCube;
		precision ${t.precision} usampler2DArray;
		`),
    t.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : t.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : t.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function tj(t) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    t.shadowMapType === sM
      ? (e = "SHADOWMAP_TYPE_PCF")
      : t.shadowMapType === MU
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : t.shadowMapType === Ki && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function nj(t) {
  let e = "ENVMAP_TYPE_CUBE";
  if (t.envMap)
    switch (t.envMapMode) {
      case So:
      case wo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case wh:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function ij(t) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (t.envMap)
    switch (t.envMapMode) {
      case wo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function rj(t) {
  let e = "ENVMAP_BLENDING_NONE";
  if (t.envMap)
    switch (t.combine) {
      case aM:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case YU:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case ZU:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function sj(t) {
  const e = t.envMapCubeUVHeight;
  if (e === null) return null;
  const n = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 7 * 16)),
    texelHeight: i,
    maxMip: n,
  };
}
function aj(t, e, n, i) {
  const r = t.getContext(),
    s = n.defines;
  let a = n.vertexShader,
    o = n.fragmentShader;
  const l = tj(n),
    c = nj(n),
    u = ij(n),
    d = rj(n),
    h = sj(n),
    p = n.isWebGL2 ? "" : $z(n),
    v = Xz(n),
    x = qz(s),
    m = r.createProgram();
  let f,
    y,
    g = n.glslVersion
      ? "#version " +
        n.glslVersion +
        `
`
      : "";
  n.isRawShaderMaterial
    ? ((f = [
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        x,
      ].filter(Ya).join(`
`)),
      f.length > 0 &&
        (f += `
`),
      (y = [
        p,
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        x,
      ].filter(Ya).join(`
`)),
      y.length > 0 &&
        (y += `
`))
    : ((f = [
        uS(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        x,
        n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
        n.batching ? "#define USE_BATCHING" : "",
        n.instancing ? "#define USE_INSTANCING" : "",
        n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.map ? "#define USE_MAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + u : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.mapUv ? "#define MAP_UV " + n.mapUv : "",
        n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
        n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
        n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
        n.emissiveMapUv ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv : "",
        n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
        n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
        n.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
          : "",
        n.metalnessMapUv ? "#define METALNESSMAP_UV " + n.metalnessMapUv : "",
        n.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv : "",
        n.anisotropyMapUv
          ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
          : "",
        n.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv : "",
        n.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
          : "",
        n.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + n.clearcoatRoughnessMapUv
          : "",
        n.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
          : "",
        n.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + n.iridescenceThicknessMapUv
          : "",
        n.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
          : "",
        n.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
          : "",
        n.specularMapUv ? "#define SPECULARMAP_UV " + n.specularMapUv : "",
        n.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
          : "",
        n.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
          : "",
        n.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
          : "",
        n.thicknessMapUv ? "#define THICKNESSMAP_UV " + n.thicknessMapUv : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.skinning ? "#define USE_SKINNING" : "",
        n.morphTargets ? "#define USE_MORPHTARGETS" : "",
        n.morphNormals && n.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        n.morphColors && n.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
          : "",
        n.morphTargetsCount > 0 && n.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
          : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "#ifdef USE_INSTANCING_MORPH",
        "	uniform sampler2D morphTexture;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(Ya).join(`
`)),
      (y = [
        p,
        uS(n),
        "#define SHADER_TYPE " + n.shaderType,
        "#define SHADER_NAME " + n.shaderName,
        x,
        n.useFog && n.fog ? "#define USE_FOG" : "",
        n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
        n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
        n.map ? "#define USE_MAP" : "",
        n.matcap ? "#define USE_MATCAP" : "",
        n.envMap ? "#define USE_ENVMAP" : "",
        n.envMap ? "#define " + c : "",
        n.envMap ? "#define " + u : "",
        n.envMap ? "#define " + d : "",
        h ? "#define CUBEUV_TEXEL_WIDTH " + h.texelWidth : "",
        h ? "#define CUBEUV_TEXEL_HEIGHT " + h.texelHeight : "",
        h ? "#define CUBEUV_MAX_MIP " + h.maxMip + ".0" : "",
        n.lightMap ? "#define USE_LIGHTMAP" : "",
        n.aoMap ? "#define USE_AOMAP" : "",
        n.bumpMap ? "#define USE_BUMPMAP" : "",
        n.normalMap ? "#define USE_NORMALMAP" : "",
        n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        n.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        n.anisotropy ? "#define USE_ANISOTROPY" : "",
        n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
        n.clearcoat ? "#define USE_CLEARCOAT" : "",
        n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        n.iridescence ? "#define USE_IRIDESCENCE" : "",
        n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        n.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        n.specularMap ? "#define USE_SPECULARMAP" : "",
        n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        n.metalnessMap ? "#define USE_METALNESSMAP" : "",
        n.alphaMap ? "#define USE_ALPHAMAP" : "",
        n.alphaTest ? "#define USE_ALPHATEST" : "",
        n.alphaHash ? "#define USE_ALPHAHASH" : "",
        n.sheen ? "#define USE_SHEEN" : "",
        n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        n.transmission ? "#define USE_TRANSMISSION" : "",
        n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        n.vertexTangents && n.flatShading === !1 ? "#define USE_TANGENT" : "",
        n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "",
        n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        n.vertexUv1s ? "#define USE_UV1" : "",
        n.vertexUv2s ? "#define USE_UV2" : "",
        n.vertexUv3s ? "#define USE_UV3" : "",
        n.pointsUvs ? "#define USE_POINTS_UV" : "",
        n.gradientMap ? "#define USE_GRADIENTMAP" : "",
        n.flatShading ? "#define FLAT_SHADED" : "",
        n.doubleSided ? "#define DOUBLE_SIDED" : "",
        n.flipSided ? "#define FLIP_SIDED" : "",
        n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        n.shadowMapEnabled ? "#define " + l : "",
        n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
        n.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        n.logarithmicDepthBuffer && n.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        n.toneMapping !== Kr ? "#define TONE_MAPPING" : "",
        n.toneMapping !== Kr ? We.tonemapping_pars_fragment : "",
        n.toneMapping !== Kr ? Wz("toneMapping", n.toneMapping) : "",
        n.dithering ? "#define DITHERING" : "",
        n.opaque ? "#define OPAQUE" : "",
        We.colorspace_pars_fragment,
        Gz("linearToOutputTexel", n.outputColorSpace),
        n.useDepthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
        `
`,
      ].filter(Ya).join(`
`))),
    (a = Vm(a)),
    (a = oS(a, n)),
    (a = lS(a, n)),
    (o = Vm(o)),
    (o = oS(o, n)),
    (o = lS(o, n)),
    (a = cS(a)),
    (o = cS(o)),
    n.isWebGL2 &&
      n.isRawShaderMaterial !== !0 &&
      ((g = `#version 300 es
`),
      (f =
        [
          v,
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        f),
      (y =
        [
          "precision mediump sampler2DArray;",
          "#define varying in",
          n.glslVersion === bx
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          n.glslVersion === bx ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        y));
  const S = g + f + a,
    T = g + y + o,
    A = sS(r, r.VERTEX_SHADER, S),
    b = sS(r, r.FRAGMENT_SHADER, T);
  r.attachShader(m, A),
    r.attachShader(m, b),
    n.index0AttributeName !== void 0
      ? r.bindAttribLocation(m, 0, n.index0AttributeName)
      : n.morphTargets === !0 && r.bindAttribLocation(m, 0, "position"),
    r.linkProgram(m);
  function P(ie) {
    if (t.debug.checkShaderErrors) {
      const J = r.getProgramInfoLog(m).trim(),
        D = r.getShaderInfoLog(A).trim(),
        Y = r.getShaderInfoLog(b).trim();
      let q = !0,
        W = !0;
      if (r.getProgramParameter(m, r.LINK_STATUS) === !1)
        if (((q = !1), typeof t.debug.onShaderError == "function"))
          t.debug.onShaderError(r, m, A, b);
        else {
          const L = aS(r, A, "vertex"),
            U = aS(r, b, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " +
              r.getError() +
              " - VALIDATE_STATUS " +
              r.getProgramParameter(m, r.VALIDATE_STATUS) +
              `

Material Name: ` +
              ie.name +
              `
Material Type: ` +
              ie.type +
              `

Program Info Log: ` +
              J +
              `
` +
              L +
              `
` +
              U
          );
        }
      else
        J !== ""
          ? console.warn("THREE.WebGLProgram: Program Info Log:", J)
          : (D === "" || Y === "") && (W = !1);
      W &&
        (ie.diagnostics = {
          runnable: q,
          programLog: J,
          vertexShader: {
            log: D,
            prefix: f,
          },
          fragmentShader: {
            log: Y,
            prefix: y,
          },
        });
    }
    r.deleteShader(A), r.deleteShader(b), (G = new qu(r, m)), (w = Yz(r, m));
  }
  let G;
  this.getUniforms = function () {
    return G === void 0 && P(this), G;
  };
  let w;
  this.getAttributes = function () {
    return w === void 0 && P(this), w;
  };
  let R = n.rendererExtensionParallelShaderCompile === !1;
  return (
    (this.isReady = function () {
      return R === !1 && (R = r.getProgramParameter(m, zz)), R;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.type = n.shaderType),
    (this.name = n.shaderName),
    (this.id = jz++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = A),
    (this.fragmentShader = b),
    this
  );
}
let oj = 0;
class lj {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const n = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(n),
      s = this._getShaderStage(i),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(r) === !1 && (a.add(r), r.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const n = this.materialCache.get(e);
    for (const i of n)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const n = this.materialCache;
    let i = n.get(e);
    return i === void 0 && ((i = new Set()), n.set(e, i)), i;
  }
  _getShaderStage(e) {
    const n = this.shaderCache;
    let i = n.get(e);
    return i === void 0 && ((i = new cj(e)), n.set(e, i)), i;
  }
}
class cj {
  constructor(e) {
    (this.id = oj++), (this.code = e), (this.usedTimes = 0);
  }
}
function uj(t, e, n, i, r, s, a) {
  const o = new SM(),
    l = new lj(),
    c = new Set(),
    u = [],
    d = r.isWebGL2,
    h = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let v = r.precision;
  const x = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function m(w) {
    return c.add(w), w === 0 ? "uv" : `uv${w}`;
  }
  function f(w, R, ie, J, D) {
    const Y = J.fog,
      q = D.geometry,
      W = w.isMeshStandardMaterial ? J.environment : null,
      L = (w.isMeshStandardMaterial ? n : e).get(w.envMap || W),
      U = L && L.mapping === wh ? L.image.height : null,
      X = x[w.type];
    w.precision !== null &&
      ((v = r.getMaxPrecision(w.precision)),
      v !== w.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          w.precision,
          "not supported, using",
          v,
          "instead."
        ));
    const K =
        q.morphAttributes.position ||
        q.morphAttributes.normal ||
        q.morphAttributes.color,
      oe = K !== void 0 ? K.length : 0;
    let ke = 0;
    q.morphAttributes.position !== void 0 && (ke = 1),
      q.morphAttributes.normal !== void 0 && (ke = 2),
      q.morphAttributes.color !== void 0 && (ke = 3);
    let V, Q, he, Re;
    if (X) {
      const ht = Ni[X];
      (V = ht.vertexShader), (Q = ht.fragmentShader);
    } else
      (V = w.vertexShader),
        (Q = w.fragmentShader),
        l.update(w),
        (he = l.getVertexShaderID(w)),
        (Re = l.getFragmentShaderID(w));
    const Ee = t.getRenderTarget(),
      _e = D.isInstancedMesh === !0,
      lt = D.isBatchedMesh === !0,
      Ue = !!w.map,
      I = !!w.matcap,
      Zt = !!L,
      be = !!w.aoMap,
      Ze = !!w.lightMap,
      Ne = !!w.bumpMap,
      nt = !!w.normalMap,
      qe = !!w.displacementMap,
      Ke = !!w.emissiveMap,
      Pt = !!w.metalnessMap,
      C = !!w.roughnessMap,
      E = w.anisotropy > 0,
      $ = w.clearcoat > 0,
      Z = w.iridescence > 0,
      re = w.sheen > 0,
      ee = w.transmission > 0,
      Ve = E && !!w.anisotropyMap,
      De = $ && !!w.clearcoatMap,
      ce = $ && !!w.clearcoatNormalMap,
      fe = $ && !!w.clearcoatRoughnessMap,
      He = Z && !!w.iridescenceMap,
      se = Z && !!w.iridescenceThicknessMap,
      kt = re && !!w.sheenColorMap,
      Je = re && !!w.sheenRoughnessMap,
      Te = !!w.specularMap,
      xe = !!w.specularColorMap,
      Se = !!w.specularIntensityMap,
      it = ee && !!w.transmissionMap,
      Be = ee && !!w.thicknessMap,
      yt = !!w.gradientMap,
      N = !!w.alphaMap,
      de = w.alphaTest > 0,
      B = !!w.alphaHash,
      ae = !!w.extensions;
    let pe = Kr;
    w.toneMapped &&
      (Ee === null || Ee.isXRRenderTarget === !0) &&
      (pe = t.toneMapping);
    const et = {
      isWebGL2: d,
      shaderID: X,
      shaderType: w.type,
      shaderName: w.name,
      vertexShader: V,
      fragmentShader: Q,
      defines: w.defines,
      customVertexShaderID: he,
      customFragmentShaderID: Re,
      isRawShaderMaterial: w.isRawShaderMaterial === !0,
      glslVersion: w.glslVersion,
      precision: v,
      batching: lt,
      instancing: _e,
      instancingColor: _e && D.instanceColor !== null,
      instancingMorph: _e && D.morphTexture !== null,
      supportsVertexTextures: p,
      outputColorSpace:
        Ee === null
          ? t.outputColorSpace
          : Ee.isXRRenderTarget === !0
          ? Ee.texture.colorSpace
          : fs,
      alphaToCoverage: !!w.alphaToCoverage,
      map: Ue,
      matcap: I,
      envMap: Zt,
      envMapMode: Zt && L.mapping,
      envMapCubeUVHeight: U,
      aoMap: be,
      lightMap: Ze,
      bumpMap: Ne,
      normalMap: nt,
      displacementMap: p && qe,
      emissiveMap: Ke,
      normalMapObjectSpace: nt && w.normalMapType === mO,
      normalMapTangentSpace: nt && w.normalMapType === pO,
      metalnessMap: Pt,
      roughnessMap: C,
      anisotropy: E,
      anisotropyMap: Ve,
      clearcoat: $,
      clearcoatMap: De,
      clearcoatNormalMap: ce,
      clearcoatRoughnessMap: fe,
      iridescence: Z,
      iridescenceMap: He,
      iridescenceThicknessMap: se,
      sheen: re,
      sheenColorMap: kt,
      sheenRoughnessMap: Je,
      specularMap: Te,
      specularColorMap: xe,
      specularIntensityMap: Se,
      transmission: ee,
      transmissionMap: it,
      thicknessMap: Be,
      gradientMap: yt,
      opaque:
        w.transparent === !1 && w.blending === ro && w.alphaToCoverage === !1,
      alphaMap: N,
      alphaTest: de,
      alphaHash: B,
      combine: w.combine,
      mapUv: Ue && m(w.map.channel),
      aoMapUv: be && m(w.aoMap.channel),
      lightMapUv: Ze && m(w.lightMap.channel),
      bumpMapUv: Ne && m(w.bumpMap.channel),
      normalMapUv: nt && m(w.normalMap.channel),
      displacementMapUv: qe && m(w.displacementMap.channel),
      emissiveMapUv: Ke && m(w.emissiveMap.channel),
      metalnessMapUv: Pt && m(w.metalnessMap.channel),
      roughnessMapUv: C && m(w.roughnessMap.channel),
      anisotropyMapUv: Ve && m(w.anisotropyMap.channel),
      clearcoatMapUv: De && m(w.clearcoatMap.channel),
      clearcoatNormalMapUv: ce && m(w.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: fe && m(w.clearcoatRoughnessMap.channel),
      iridescenceMapUv: He && m(w.iridescenceMap.channel),
      iridescenceThicknessMapUv: se && m(w.iridescenceThicknessMap.channel),
      sheenColorMapUv: kt && m(w.sheenColorMap.channel),
      sheenRoughnessMapUv: Je && m(w.sheenRoughnessMap.channel),
      specularMapUv: Te && m(w.specularMap.channel),
      specularColorMapUv: xe && m(w.specularColorMap.channel),
      specularIntensityMapUv: Se && m(w.specularIntensityMap.channel),
      transmissionMapUv: it && m(w.transmissionMap.channel),
      thicknessMapUv: Be && m(w.thicknessMap.channel),
      alphaMapUv: N && m(w.alphaMap.channel),
      vertexTangents: !!q.attributes.tangent && (nt || E),
      vertexColors: w.vertexColors,
      vertexAlphas:
        w.vertexColors === !0 &&
        !!q.attributes.color &&
        q.attributes.color.itemSize === 4,
      pointsUvs: D.isPoints === !0 && !!q.attributes.uv && (Ue || N),
      fog: !!Y,
      useFog: w.fog === !0,
      fogExp2: !!Y && Y.isFogExp2,
      flatShading: w.flatShading === !0,
      sizeAttenuation: w.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      skinning: D.isSkinnedMesh === !0,
      morphTargets: q.morphAttributes.position !== void 0,
      morphNormals: q.morphAttributes.normal !== void 0,
      morphColors: q.morphAttributes.color !== void 0,
      morphTargetsCount: oe,
      morphTextureStride: ke,
      numDirLights: R.directional.length,
      numPointLights: R.point.length,
      numSpotLights: R.spot.length,
      numSpotLightMaps: R.spotLightMap.length,
      numRectAreaLights: R.rectArea.length,
      numHemiLights: R.hemi.length,
      numDirLightShadows: R.directionalShadowMap.length,
      numPointLightShadows: R.pointShadowMap.length,
      numSpotLightShadows: R.spotShadowMap.length,
      numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
      numLightProbes: R.numLightProbes,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: w.dithering,
      shadowMapEnabled: t.shadowMap.enabled && ie.length > 0,
      shadowMapType: t.shadowMap.type,
      toneMapping: pe,
      useLegacyLights: t._useLegacyLights,
      decodeVideoTexture:
        Ue &&
        w.map.isVideoTexture === !0 &&
        dt.getTransfer(w.map.colorSpace) === vt,
      premultipliedAlpha: w.premultipliedAlpha,
      doubleSided: w.side === nr,
      flipSided: w.side === Dn,
      useDepthPacking: w.depthPacking >= 0,
      depthPacking: w.depthPacking || 0,
      index0AttributeName: w.index0AttributeName,
      extensionDerivatives: ae && w.extensions.derivatives === !0,
      extensionFragDepth: ae && w.extensions.fragDepth === !0,
      extensionDrawBuffers: ae && w.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: ae && w.extensions.shaderTextureLOD === !0,
      extensionClipCullDistance:
        ae &&
        w.extensions.clipCullDistance === !0 &&
        i.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw:
        ae && w.extensions.multiDraw === !0 && i.has("WEBGL_multi_draw"),
      rendererExtensionFragDepth: d || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: d || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: d || i.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: i.has(
        "KHR_parallel_shader_compile"
      ),
      customProgramCacheKey: w.customProgramCacheKey(),
    };
    return (
      (et.vertexUv1s = c.has(1)),
      (et.vertexUv2s = c.has(2)),
      (et.vertexUv3s = c.has(3)),
      c.clear(),
      et
    );
  }
  function y(w) {
    const R = [];
    if (
      (w.shaderID
        ? R.push(w.shaderID)
        : (R.push(w.customVertexShaderID), R.push(w.customFragmentShaderID)),
      w.defines !== void 0)
    )
      for (const ie in w.defines) R.push(ie), R.push(w.defines[ie]);
    return (
      w.isRawShaderMaterial === !1 &&
        (g(R, w), S(R, w), R.push(t.outputColorSpace)),
      R.push(w.customProgramCacheKey),
      R.join()
    );
  }
  function g(w, R) {
    w.push(R.precision),
      w.push(R.outputColorSpace),
      w.push(R.envMapMode),
      w.push(R.envMapCubeUVHeight),
      w.push(R.mapUv),
      w.push(R.alphaMapUv),
      w.push(R.lightMapUv),
      w.push(R.aoMapUv),
      w.push(R.bumpMapUv),
      w.push(R.normalMapUv),
      w.push(R.displacementMapUv),
      w.push(R.emissiveMapUv),
      w.push(R.metalnessMapUv),
      w.push(R.roughnessMapUv),
      w.push(R.anisotropyMapUv),
      w.push(R.clearcoatMapUv),
      w.push(R.clearcoatNormalMapUv),
      w.push(R.clearcoatRoughnessMapUv),
      w.push(R.iridescenceMapUv),
      w.push(R.iridescenceThicknessMapUv),
      w.push(R.sheenColorMapUv),
      w.push(R.sheenRoughnessMapUv),
      w.push(R.specularMapUv),
      w.push(R.specularColorMapUv),
      w.push(R.specularIntensityMapUv),
      w.push(R.transmissionMapUv),
      w.push(R.thicknessMapUv),
      w.push(R.combine),
      w.push(R.fogExp2),
      w.push(R.sizeAttenuation),
      w.push(R.morphTargetsCount),
      w.push(R.morphAttributeCount),
      w.push(R.numDirLights),
      w.push(R.numPointLights),
      w.push(R.numSpotLights),
      w.push(R.numSpotLightMaps),
      w.push(R.numHemiLights),
      w.push(R.numRectAreaLights),
      w.push(R.numDirLightShadows),
      w.push(R.numPointLightShadows),
      w.push(R.numSpotLightShadows),
      w.push(R.numSpotLightShadowsWithMaps),
      w.push(R.numLightProbes),
      w.push(R.shadowMapType),
      w.push(R.toneMapping),
      w.push(R.numClippingPlanes),
      w.push(R.numClipIntersection),
      w.push(R.depthPacking);
  }
  function S(w, R) {
    o.disableAll(),
      R.isWebGL2 && o.enable(0),
      R.supportsVertexTextures && o.enable(1),
      R.instancing && o.enable(2),
      R.instancingColor && o.enable(3),
      R.instancingMorph && o.enable(4),
      R.matcap && o.enable(5),
      R.envMap && o.enable(6),
      R.normalMapObjectSpace && o.enable(7),
      R.normalMapTangentSpace && o.enable(8),
      R.clearcoat && o.enable(9),
      R.iridescence && o.enable(10),
      R.alphaTest && o.enable(11),
      R.vertexColors && o.enable(12),
      R.vertexAlphas && o.enable(13),
      R.vertexUv1s && o.enable(14),
      R.vertexUv2s && o.enable(15),
      R.vertexUv3s && o.enable(16),
      R.vertexTangents && o.enable(17),
      R.anisotropy && o.enable(18),
      R.alphaHash && o.enable(19),
      R.batching && o.enable(20),
      w.push(o.mask),
      o.disableAll(),
      R.fog && o.enable(0),
      R.useFog && o.enable(1),
      R.flatShading && o.enable(2),
      R.logarithmicDepthBuffer && o.enable(3),
      R.skinning && o.enable(4),
      R.morphTargets && o.enable(5),
      R.morphNormals && o.enable(6),
      R.morphColors && o.enable(7),
      R.premultipliedAlpha && o.enable(8),
      R.shadowMapEnabled && o.enable(9),
      R.useLegacyLights && o.enable(10),
      R.doubleSided && o.enable(11),
      R.flipSided && o.enable(12),
      R.useDepthPacking && o.enable(13),
      R.dithering && o.enable(14),
      R.transmission && o.enable(15),
      R.sheen && o.enable(16),
      R.opaque && o.enable(17),
      R.pointsUvs && o.enable(18),
      R.decodeVideoTexture && o.enable(19),
      R.alphaToCoverage && o.enable(20),
      w.push(o.mask);
  }
  function T(w) {
    const R = x[w.type];
    let ie;
    if (R) {
      const J = Ni[R];
      ie = HO.clone(J.uniforms);
    } else ie = w.uniforms;
    return ie;
  }
  function A(w, R) {
    let ie;
    for (let J = 0, D = u.length; J < D; J++) {
      const Y = u[J];
      if (Y.cacheKey === R) {
        (ie = Y), ++ie.usedTimes;
        break;
      }
    }
    return ie === void 0 && ((ie = new aj(t, R, w, s)), u.push(ie)), ie;
  }
  function b(w) {
    if (--w.usedTimes === 0) {
      const R = u.indexOf(w);
      (u[R] = u[u.length - 1]), u.pop(), w.destroy();
    }
  }
  function P(w) {
    l.remove(w);
  }
  function G() {
    l.dispose();
  }
  return {
    getParameters: f,
    getProgramCacheKey: y,
    getUniforms: T,
    acquireProgram: A,
    releaseProgram: b,
    releaseShaderCache: P,
    programs: u,
    dispose: G,
  };
}
function dj() {
  let t = new WeakMap();
  function e(s) {
    let a = t.get(s);
    return a === void 0 && ((a = {}), t.set(s, a)), a;
  }
  function n(s) {
    t.delete(s);
  }
  function i(s, a, o) {
    t.get(s)[a] = o;
  }
  function r() {
    t = new WeakMap();
  }
  return {
    get: e,
    remove: n,
    update: i,
    dispose: r,
  };
}
function hj(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.material.id !== e.material.id
    ? t.material.id - e.material.id
    : t.z !== e.z
    ? t.z - e.z
    : t.id - e.id;
}
function dS(t, e) {
  return t.groupOrder !== e.groupOrder
    ? t.groupOrder - e.groupOrder
    : t.renderOrder !== e.renderOrder
    ? t.renderOrder - e.renderOrder
    : t.z !== e.z
    ? e.z - t.z
    : t.id - e.id;
}
function hS() {
  const t = [];
  let e = 0;
  const n = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (n.length = 0), (i.length = 0), (r.length = 0);
  }
  function a(d, h, p, v, x, m) {
    let f = t[e];
    return (
      f === void 0
        ? ((f = {
            id: d.id,
            object: d,
            geometry: h,
            material: p,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: x,
            group: m,
          }),
          (t[e] = f))
        : ((f.id = d.id),
          (f.object = d),
          (f.geometry = h),
          (f.material = p),
          (f.groupOrder = v),
          (f.renderOrder = d.renderOrder),
          (f.z = x),
          (f.group = m)),
      e++,
      f
    );
  }
  function o(d, h, p, v, x, m) {
    const f = a(d, h, p, v, x, m);
    p.transmission > 0
      ? i.push(f)
      : p.transparent === !0
      ? r.push(f)
      : n.push(f);
  }
  function l(d, h, p, v, x, m) {
    const f = a(d, h, p, v, x, m);
    p.transmission > 0
      ? i.unshift(f)
      : p.transparent === !0
      ? r.unshift(f)
      : n.unshift(f);
  }
  function c(d, h) {
    n.length > 1 && n.sort(d || hj),
      i.length > 1 && i.sort(h || dS),
      r.length > 1 && r.sort(h || dS);
  }
  function u() {
    for (let d = e, h = t.length; d < h; d++) {
      const p = t[d];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: n,
    transmissive: i,
    transparent: r,
    init: s,
    push: o,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function fj() {
  let t = new WeakMap();
  function e(i, r) {
    const s = t.get(i);
    let a;
    return (
      s === void 0
        ? ((a = new hS()), t.set(i, [a]))
        : r >= s.length
        ? ((a = new hS()), s.push(a))
        : (a = s[r]),
      a
    );
  }
  function n() {
    t = new WeakMap();
  }
  return {
    get: e,
    dispose: n,
  };
}
function pj() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            direction: new z(),
            color: new ct(),
          };
          break;
        case "SpotLight":
          n = {
            position: new z(),
            direction: new z(),
            color: new ct(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          n = {
            position: new z(),
            color: new ct(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          n = {
            direction: new z(),
            skyColor: new ct(),
            groundColor: new ct(),
          };
          break;
        case "RectAreaLight":
          n = {
            color: new ct(),
            position: new z(),
            halfWidth: new z(),
            halfHeight: new z(),
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
function mj() {
  const t = {};
  return {
    get: function (e) {
      if (t[e.id] !== void 0) return t[e.id];
      let n;
      switch (e.type) {
        case "DirectionalLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ot(),
          };
          break;
        case "SpotLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ot(),
          };
          break;
        case "PointLight":
          n = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ot(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (t[e.id] = n), n;
    },
  };
}
let gj = 0;
function vj(t, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (t.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (t.map ? 1 : 0)
  );
}
function _j(t, e) {
  const n = new pj(),
    i = mj(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
        numLightProbes: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
      numLightProbes: 0,
    };
  for (let u = 0; u < 9; u++) r.probe.push(new z());
  const s = new z(),
    a = new Ft(),
    o = new Ft();
  function l(u, d) {
    let h = 0,
      p = 0,
      v = 0;
    for (let ie = 0; ie < 9; ie++) r.probe[ie].set(0, 0, 0);
    let x = 0,
      m = 0,
      f = 0,
      y = 0,
      g = 0,
      S = 0,
      T = 0,
      A = 0,
      b = 0,
      P = 0,
      G = 0;
    u.sort(vj);
    const w = d === !0 ? Math.PI : 1;
    for (let ie = 0, J = u.length; ie < J; ie++) {
      const D = u[ie],
        Y = D.color,
        q = D.intensity,
        W = D.distance,
        L = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
      if (D.isAmbientLight)
        (h += Y.r * q * w), (p += Y.g * q * w), (v += Y.b * q * w);
      else if (D.isLightProbe) {
        for (let U = 0; U < 9; U++)
          r.probe[U].addScaledVector(D.sh.coefficients[U], q);
        G++;
      } else if (D.isDirectionalLight) {
        const U = n.get(D);
        if (
          (U.color.copy(D.color).multiplyScalar(D.intensity * w), D.castShadow)
        ) {
          const X = D.shadow,
            K = i.get(D);
          (K.shadowBias = X.bias),
            (K.shadowNormalBias = X.normalBias),
            (K.shadowRadius = X.radius),
            (K.shadowMapSize = X.mapSize),
            (r.directionalShadow[x] = K),
            (r.directionalShadowMap[x] = L),
            (r.directionalShadowMatrix[x] = D.shadow.matrix),
            S++;
        }
        (r.directional[x] = U), x++;
      } else if (D.isSpotLight) {
        const U = n.get(D);
        U.position.setFromMatrixPosition(D.matrixWorld),
          U.color.copy(Y).multiplyScalar(q * w),
          (U.distance = W),
          (U.coneCos = Math.cos(D.angle)),
          (U.penumbraCos = Math.cos(D.angle * (1 - D.penumbra))),
          (U.decay = D.decay),
          (r.spot[f] = U);
        const X = D.shadow;
        if (
          (D.map &&
            ((r.spotLightMap[b] = D.map),
            b++,
            X.updateMatrices(D),
            D.castShadow && P++),
          (r.spotLightMatrix[f] = X.matrix),
          D.castShadow)
        ) {
          const K = i.get(D);
          (K.shadowBias = X.bias),
            (K.shadowNormalBias = X.normalBias),
            (K.shadowRadius = X.radius),
            (K.shadowMapSize = X.mapSize),
            (r.spotShadow[f] = K),
            (r.spotShadowMap[f] = L),
            A++;
        }
        f++;
      } else if (D.isRectAreaLight) {
        const U = n.get(D);
        U.color.copy(Y).multiplyScalar(q),
          U.halfWidth.set(D.width * 0.5, 0, 0),
          U.halfHeight.set(0, D.height * 0.5, 0),
          (r.rectArea[y] = U),
          y++;
      } else if (D.isPointLight) {
        const U = n.get(D);
        if (
          (U.color.copy(D.color).multiplyScalar(D.intensity * w),
          (U.distance = D.distance),
          (U.decay = D.decay),
          D.castShadow)
        ) {
          const X = D.shadow,
            K = i.get(D);
          (K.shadowBias = X.bias),
            (K.shadowNormalBias = X.normalBias),
            (K.shadowRadius = X.radius),
            (K.shadowMapSize = X.mapSize),
            (K.shadowCameraNear = X.camera.near),
            (K.shadowCameraFar = X.camera.far),
            (r.pointShadow[m] = K),
            (r.pointShadowMap[m] = L),
            (r.pointShadowMatrix[m] = D.shadow.matrix),
            T++;
        }
        (r.point[m] = U), m++;
      } else if (D.isHemisphereLight) {
        const U = n.get(D);
        U.skyColor.copy(D.color).multiplyScalar(q * w),
          U.groundColor.copy(D.groundColor).multiplyScalar(q * w),
          (r.hemi[g] = U),
          g++;
      }
    }
    y > 0 &&
      (e.isWebGL2
        ? t.has("OES_texture_float_linear") === !0
          ? ((r.rectAreaLTC1 = le.LTC_FLOAT_1),
            (r.rectAreaLTC2 = le.LTC_FLOAT_2))
          : ((r.rectAreaLTC1 = le.LTC_HALF_1), (r.rectAreaLTC2 = le.LTC_HALF_2))
        : t.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = le.LTC_FLOAT_1), (r.rectAreaLTC2 = le.LTC_FLOAT_2))
        : t.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = le.LTC_HALF_1), (r.rectAreaLTC2 = le.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = h),
      (r.ambient[1] = p),
      (r.ambient[2] = v);
    const R = r.hash;
    (R.directionalLength !== x ||
      R.pointLength !== m ||
      R.spotLength !== f ||
      R.rectAreaLength !== y ||
      R.hemiLength !== g ||
      R.numDirectionalShadows !== S ||
      R.numPointShadows !== T ||
      R.numSpotShadows !== A ||
      R.numSpotMaps !== b ||
      R.numLightProbes !== G) &&
      ((r.directional.length = x),
      (r.spot.length = f),
      (r.rectArea.length = y),
      (r.point.length = m),
      (r.hemi.length = g),
      (r.directionalShadow.length = S),
      (r.directionalShadowMap.length = S),
      (r.pointShadow.length = T),
      (r.pointShadowMap.length = T),
      (r.spotShadow.length = A),
      (r.spotShadowMap.length = A),
      (r.directionalShadowMatrix.length = S),
      (r.pointShadowMatrix.length = T),
      (r.spotLightMatrix.length = A + b - P),
      (r.spotLightMap.length = b),
      (r.numSpotLightShadowsWithMaps = P),
      (r.numLightProbes = G),
      (R.directionalLength = x),
      (R.pointLength = m),
      (R.spotLength = f),
      (R.rectAreaLength = y),
      (R.hemiLength = g),
      (R.numDirectionalShadows = S),
      (R.numPointShadows = T),
      (R.numSpotShadows = A),
      (R.numSpotMaps = b),
      (R.numLightProbes = G),
      (r.version = gj++));
  }
  function c(u, d) {
    let h = 0,
      p = 0,
      v = 0,
      x = 0,
      m = 0;
    const f = d.matrixWorldInverse;
    for (let y = 0, g = u.length; y < g; y++) {
      const S = u[y];
      if (S.isDirectionalLight) {
        const T = r.directional[h];
        T.direction.setFromMatrixPosition(S.matrixWorld),
          s.setFromMatrixPosition(S.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(f),
          h++;
      } else if (S.isSpotLight) {
        const T = r.spot[v];
        T.position.setFromMatrixPosition(S.matrixWorld),
          T.position.applyMatrix4(f),
          T.direction.setFromMatrixPosition(S.matrixWorld),
          s.setFromMatrixPosition(S.target.matrixWorld),
          T.direction.sub(s),
          T.direction.transformDirection(f),
          v++;
      } else if (S.isRectAreaLight) {
        const T = r.rectArea[x];
        T.position.setFromMatrixPosition(S.matrixWorld),
          T.position.applyMatrix4(f),
          o.identity(),
          a.copy(S.matrixWorld),
          a.premultiply(f),
          o.extractRotation(a),
          T.halfWidth.set(S.width * 0.5, 0, 0),
          T.halfHeight.set(0, S.height * 0.5, 0),
          T.halfWidth.applyMatrix4(o),
          T.halfHeight.applyMatrix4(o),
          x++;
      } else if (S.isPointLight) {
        const T = r.point[p];
        T.position.setFromMatrixPosition(S.matrixWorld),
          T.position.applyMatrix4(f),
          p++;
      } else if (S.isHemisphereLight) {
        const T = r.hemi[m];
        T.direction.setFromMatrixPosition(S.matrixWorld),
          T.direction.transformDirection(f),
          m++;
      }
    }
  }
  return {
    setup: l,
    setupView: c,
    state: r,
  };
}
function fS(t, e) {
  const n = new _j(t, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function a(d) {
    i.push(d);
  }
  function o(d) {
    r.push(d);
  }
  function l(d) {
    n.setup(i, d);
  }
  function c(d) {
    n.setupView(i, d);
  }
  return {
    init: s,
    state: {
      lightsArray: i,
      shadowsArray: r,
      lights: n,
    },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o,
  };
}
function yj(t, e) {
  let n = new WeakMap();
  function i(s, a = 0) {
    const o = n.get(s);
    let l;
    return (
      o === void 0
        ? ((l = new fS(t, e)), n.set(s, [l]))
        : a >= o.length
        ? ((l = new fS(t, e)), o.push(l))
        : (l = o[a]),
      l
    );
  }
  function r() {
    n = new WeakMap();
  }
  return {
    get: i,
    dispose: r,
  };
}
class xj extends Pc {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = hO),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Sj extends Pc {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const wj = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  Ej = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function Tj(t, e, n) {
  let i = new RM();
  const r = new ot(),
    s = new ot(),
    a = new Qt(),
    o = new xj({
      depthPacking: fO,
    }),
    l = new Sj(),
    c = {},
    u = n.maxTextureSize,
    d = {
      [as]: Dn,
      [Dn]: as,
      [nr]: nr,
    },
    h = new os({
      defines: {
        VSM_SAMPLES: 8,
      },
      uniforms: {
        shadow_pass: {
          value: null,
        },
        resolution: {
          value: new ot(),
        },
        radius: {
          value: 4,
        },
      },
      vertexShader: wj,
      fragmentShader: Ej,
    }),
    p = h.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const v = new _r();
  v.setAttribute(
    "position",
    new Ei(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const x = new or(v, h),
    m = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = sM);
  let f = this.type;
  this.render = function (A, b, P) {
    if (
      m.enabled === !1 ||
      (m.autoUpdate === !1 && m.needsUpdate === !1) ||
      A.length === 0
    )
      return;
    const G = t.getRenderTarget(),
      w = t.getActiveCubeFace(),
      R = t.getActiveMipmapLevel(),
      ie = t.state;
    ie.setBlending(Zr),
      ie.buffers.color.setClear(1, 1, 1, 1),
      ie.buffers.depth.setTest(!0),
      ie.setScissorTest(!1);
    const J = f !== Ki && this.type === Ki,
      D = f === Ki && this.type !== Ki;
    for (let Y = 0, q = A.length; Y < q; Y++) {
      const W = A[Y],
        L = W.shadow;
      if (L === void 0) {
        console.warn("THREE.WebGLShadowMap:", W, "has no shadow.");
        continue;
      }
      if (L.autoUpdate === !1 && L.needsUpdate === !1) continue;
      r.copy(L.mapSize);
      const U = L.getFrameExtents();
      if (
        (r.multiply(U),
        s.copy(L.mapSize),
        (r.x > u || r.y > u) &&
          (r.x > u &&
            ((s.x = Math.floor(u / U.x)),
            (r.x = s.x * U.x),
            (L.mapSize.x = s.x)),
          r.y > u &&
            ((s.y = Math.floor(u / U.y)),
            (r.y = s.y * U.y),
            (L.mapSize.y = s.y))),
        L.map === null || J === !0 || D === !0)
      ) {
        const K =
          this.type !== Ki
            ? {
                minFilter: vn,
                magFilter: vn,
              }
            : {};
        L.map !== null && L.map.dispose(),
          (L.map = new ta(r.x, r.y, K)),
          (L.map.texture.name = W.name + ".shadowMap"),
          L.camera.updateProjectionMatrix();
      }
      t.setRenderTarget(L.map), t.clear();
      const X = L.getViewportCount();
      for (let K = 0; K < X; K++) {
        const oe = L.getViewport(K);
        a.set(s.x * oe.x, s.y * oe.y, s.x * oe.z, s.y * oe.w),
          ie.viewport(a),
          L.updateMatrices(W, K),
          (i = L.getFrustum()),
          S(b, P, L.camera, W, this.type);
      }
      L.isPointLightShadow !== !0 && this.type === Ki && y(L, P),
        (L.needsUpdate = !1);
    }
    (f = this.type), (m.needsUpdate = !1), t.setRenderTarget(G, w, R);
  };
  function y(A, b) {
    const P = e.update(x);
    h.defines.VSM_SAMPLES !== A.blurSamples &&
      ((h.defines.VSM_SAMPLES = A.blurSamples),
      (p.defines.VSM_SAMPLES = A.blurSamples),
      (h.needsUpdate = !0),
      (p.needsUpdate = !0)),
      A.mapPass === null && (A.mapPass = new ta(r.x, r.y)),
      (h.uniforms.shadow_pass.value = A.map.texture),
      (h.uniforms.resolution.value = A.mapSize),
      (h.uniforms.radius.value = A.radius),
      t.setRenderTarget(A.mapPass),
      t.clear(),
      t.renderBufferDirect(b, null, P, h, x, null),
      (p.uniforms.shadow_pass.value = A.mapPass.texture),
      (p.uniforms.resolution.value = A.mapSize),
      (p.uniforms.radius.value = A.radius),
      t.setRenderTarget(A.map),
      t.clear(),
      t.renderBufferDirect(b, null, P, p, x, null);
  }
  function g(A, b, P, G) {
    let w = null;
    const R =
      P.isPointLight === !0 ? A.customDistanceMaterial : A.customDepthMaterial;
    if (R !== void 0) w = R;
    else if (
      ((w = P.isPointLight === !0 ? l : o),
      (t.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const ie = w.uuid,
        J = b.uuid;
      let D = c[ie];
      D === void 0 && ((D = {}), (c[ie] = D));
      let Y = D[J];
      Y === void 0 &&
        ((Y = w.clone()), (D[J] = Y), b.addEventListener("dispose", T)),
        (w = Y);
    }
    if (
      ((w.visible = b.visible),
      (w.wireframe = b.wireframe),
      G === Ki
        ? (w.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (w.side = b.shadowSide !== null ? b.shadowSide : d[b.side]),
      (w.alphaMap = b.alphaMap),
      (w.alphaTest = b.alphaTest),
      (w.map = b.map),
      (w.clipShadows = b.clipShadows),
      (w.clippingPlanes = b.clippingPlanes),
      (w.clipIntersection = b.clipIntersection),
      (w.displacementMap = b.displacementMap),
      (w.displacementScale = b.displacementScale),
      (w.displacementBias = b.displacementBias),
      (w.wireframeLinewidth = b.wireframeLinewidth),
      (w.linewidth = b.linewidth),
      P.isPointLight === !0 && w.isMeshDistanceMaterial === !0)
    ) {
      const ie = t.properties.get(w);
      ie.light = P;
    }
    return w;
  }
  function S(A, b, P, G, w) {
    if (A.visible === !1) return;
    if (
      A.layers.test(b.layers) &&
      (A.isMesh || A.isLine || A.isPoints) &&
      (A.castShadow || (A.receiveShadow && w === Ki)) &&
      (!A.frustumCulled || i.intersectsObject(A))
    ) {
      A.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, A.matrixWorld);
      const J = e.update(A),
        D = A.material;
      if (Array.isArray(D)) {
        const Y = J.groups;
        for (let q = 0, W = Y.length; q < W; q++) {
          const L = Y[q],
            U = D[L.materialIndex];
          if (U && U.visible) {
            const X = g(A, U, G, w);
            A.onBeforeShadow(t, A, b, P, J, X, L),
              t.renderBufferDirect(P, null, J, X, A, L),
              A.onAfterShadow(t, A, b, P, J, X, L);
          }
        }
      } else if (D.visible) {
        const Y = g(A, D, G, w);
        A.onBeforeShadow(t, A, b, P, J, Y, null),
          t.renderBufferDirect(P, null, J, Y, A, null),
          A.onAfterShadow(t, A, b, P, J, Y, null);
      }
    }
    const ie = A.children;
    for (let J = 0, D = ie.length; J < D; J++) S(ie[J], b, P, G, w);
  }
  function T(A) {
    A.target.removeEventListener("dispose", T);
    for (const P in c) {
      const G = c[P],
        w = A.target.uuid;
      w in G && (G[w].dispose(), delete G[w]);
    }
  }
}
function Mj(t, e, n) {
  const i = n.isWebGL2;
  function r() {
    let N = !1;
    const de = new Qt();
    let B = null;
    const ae = new Qt(0, 0, 0, 0);
    return {
      setMask: function (pe) {
        B !== pe && !N && (t.colorMask(pe, pe, pe, pe), (B = pe));
      },
      setLocked: function (pe) {
        N = pe;
      },
      setClear: function (pe, et, ht, Kt, qn) {
        qn === !0 && ((pe *= Kt), (et *= Kt), (ht *= Kt)),
          de.set(pe, et, ht, Kt),
          ae.equals(de) === !1 && (t.clearColor(pe, et, ht, Kt), ae.copy(de));
      },
      reset: function () {
        (N = !1), (B = null), ae.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let N = !1,
      de = null,
      B = null,
      ae = null;
    return {
      setTest: function (pe) {
        pe ? _e(t.DEPTH_TEST) : lt(t.DEPTH_TEST);
      },
      setMask: function (pe) {
        de !== pe && !N && (t.depthMask(pe), (de = pe));
      },
      setFunc: function (pe) {
        if (B !== pe) {
          switch (pe) {
            case VU:
              t.depthFunc(t.NEVER);
              break;
            case HU:
              t.depthFunc(t.ALWAYS);
              break;
            case GU:
              t.depthFunc(t.LESS);
              break;
            case Od:
              t.depthFunc(t.LEQUAL);
              break;
            case WU:
              t.depthFunc(t.EQUAL);
              break;
            case $U:
              t.depthFunc(t.GEQUAL);
              break;
            case XU:
              t.depthFunc(t.GREATER);
              break;
            case qU:
              t.depthFunc(t.NOTEQUAL);
              break;
            default:
              t.depthFunc(t.LEQUAL);
          }
          B = pe;
        }
      },
      setLocked: function (pe) {
        N = pe;
      },
      setClear: function (pe) {
        ae !== pe && (t.clearDepth(pe), (ae = pe));
      },
      reset: function () {
        (N = !1), (de = null), (B = null), (ae = null);
      },
    };
  }
  function a() {
    let N = !1,
      de = null,
      B = null,
      ae = null,
      pe = null,
      et = null,
      ht = null,
      Kt = null,
      qn = null;
    return {
      setTest: function (ft) {
        N || (ft ? _e(t.STENCIL_TEST) : lt(t.STENCIL_TEST));
      },
      setMask: function (ft) {
        de !== ft && !N && (t.stencilMask(ft), (de = ft));
      },
      setFunc: function (ft, pn, Ai) {
        (B !== ft || ae !== pn || pe !== Ai) &&
          (t.stencilFunc(ft, pn, Ai), (B = ft), (ae = pn), (pe = Ai));
      },
      setOp: function (ft, pn, Ai) {
        (et !== ft || ht !== pn || Kt !== Ai) &&
          (t.stencilOp(ft, pn, Ai), (et = ft), (ht = pn), (Kt = Ai));
      },
      setLocked: function (ft) {
        N = ft;
      },
      setClear: function (ft) {
        qn !== ft && (t.clearStencil(ft), (qn = ft));
      },
      reset: function () {
        (N = !1),
          (de = null),
          (B = null),
          (ae = null),
          (pe = null),
          (et = null),
          (ht = null),
          (Kt = null),
          (qn = null);
      },
    };
  }
  const o = new r(),
    l = new s(),
    c = new a(),
    u = new WeakMap(),
    d = new WeakMap();
  let h = {},
    p = {},
    v = new WeakMap(),
    x = [],
    m = null,
    f = !1,
    y = null,
    g = null,
    S = null,
    T = null,
    A = null,
    b = null,
    P = null,
    G = new ct(0, 0, 0),
    w = 0,
    R = !1,
    ie = null,
    J = null,
    D = null,
    Y = null,
    q = null;
  const W = t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let L = !1,
    U = 0;
  const X = t.getParameter(t.VERSION);
  X.indexOf("WebGL") !== -1
    ? ((U = parseFloat(/^WebGL (\d)/.exec(X)[1])), (L = U >= 1))
    : X.indexOf("OpenGL ES") !== -1 &&
      ((U = parseFloat(/^OpenGL ES (\d)/.exec(X)[1])), (L = U >= 2));
  let K = null,
    oe = {};
  const ke = t.getParameter(t.SCISSOR_BOX),
    V = t.getParameter(t.VIEWPORT),
    Q = new Qt().fromArray(ke),
    he = new Qt().fromArray(V);
  function Re(N, de, B, ae) {
    const pe = new Uint8Array(4),
      et = t.createTexture();
    t.bindTexture(N, et),
      t.texParameteri(N, t.TEXTURE_MIN_FILTER, t.NEAREST),
      t.texParameteri(N, t.TEXTURE_MAG_FILTER, t.NEAREST);
    for (let ht = 0; ht < B; ht++)
      i && (N === t.TEXTURE_3D || N === t.TEXTURE_2D_ARRAY)
        ? t.texImage3D(de, 0, t.RGBA, 1, 1, ae, 0, t.RGBA, t.UNSIGNED_BYTE, pe)
        : t.texImage2D(
            de + ht,
            0,
            t.RGBA,
            1,
            1,
            0,
            t.RGBA,
            t.UNSIGNED_BYTE,
            pe
          );
    return et;
  }
  const Ee = {};
  (Ee[t.TEXTURE_2D] = Re(t.TEXTURE_2D, t.TEXTURE_2D, 1)),
    (Ee[t.TEXTURE_CUBE_MAP] = Re(
      t.TEXTURE_CUBE_MAP,
      t.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    i &&
      ((Ee[t.TEXTURE_2D_ARRAY] = Re(
        t.TEXTURE_2D_ARRAY,
        t.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Ee[t.TEXTURE_3D] = Re(t.TEXTURE_3D, t.TEXTURE_3D, 1, 1))),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    _e(t.DEPTH_TEST),
    l.setFunc(Od),
    qe(!1),
    Ke(Xy),
    _e(t.CULL_FACE),
    Ne(Zr);
  function _e(N) {
    h[N] !== !0 && (t.enable(N), (h[N] = !0));
  }
  function lt(N) {
    h[N] !== !1 && (t.disable(N), (h[N] = !1));
  }
  function Ue(N, de) {
    return p[N] !== de
      ? (t.bindFramebuffer(N, de),
        (p[N] = de),
        i &&
          (N === t.DRAW_FRAMEBUFFER && (p[t.FRAMEBUFFER] = de),
          N === t.FRAMEBUFFER && (p[t.DRAW_FRAMEBUFFER] = de)),
        !0)
      : !1;
  }
  function I(N, de) {
    let B = x,
      ae = !1;
    if (N) {
      (B = v.get(de)), B === void 0 && ((B = []), v.set(de, B));
      const pe = N.textures;
      if (B.length !== pe.length || B[0] !== t.COLOR_ATTACHMENT0) {
        for (let et = 0, ht = pe.length; et < ht; et++)
          B[et] = t.COLOR_ATTACHMENT0 + et;
        (B.length = pe.length), (ae = !0);
      }
    } else B[0] !== t.BACK && ((B[0] = t.BACK), (ae = !0));
    if (ae)
      if (n.isWebGL2) t.drawBuffers(B);
      else if (e.has("WEBGL_draw_buffers") === !0)
        e.get("WEBGL_draw_buffers").drawBuffersWEBGL(B);
      else
        throw new Error(
          "THREE.WebGLState: Usage of gl.drawBuffers() require WebGL2 or WEBGL_draw_buffers extension"
        );
  }
  function Zt(N) {
    return m !== N ? (t.useProgram(N), (m = N), !0) : !1;
  }
  const be = {
    [Ns]: t.FUNC_ADD,
    [AU]: t.FUNC_SUBTRACT,
    [CU]: t.FUNC_REVERSE_SUBTRACT,
  };
  if (i) (be[Zy] = t.MIN), (be[Ky] = t.MAX);
  else {
    const N = e.get("EXT_blend_minmax");
    N !== null && ((be[Zy] = N.MIN_EXT), (be[Ky] = N.MAX_EXT));
  }
  const Ze = {
    [RU]: t.ZERO,
    [PU]: t.ONE,
    [LU]: t.SRC_COLOR,
    [Dm]: t.SRC_ALPHA,
    [OU]: t.SRC_ALPHA_SATURATE,
    [IU]: t.DST_COLOR,
    [DU]: t.DST_ALPHA,
    [NU]: t.ONE_MINUS_SRC_COLOR,
    [km]: t.ONE_MINUS_SRC_ALPHA,
    [UU]: t.ONE_MINUS_DST_COLOR,
    [kU]: t.ONE_MINUS_DST_ALPHA,
    [FU]: t.CONSTANT_COLOR,
    [BU]: t.ONE_MINUS_CONSTANT_COLOR,
    [zU]: t.CONSTANT_ALPHA,
    [jU]: t.ONE_MINUS_CONSTANT_ALPHA,
  };
  function Ne(N, de, B, ae, pe, et, ht, Kt, qn, ft) {
    if (N === Zr) {
      f === !0 && (lt(t.BLEND), (f = !1));
      return;
    }
    if ((f === !1 && (_e(t.BLEND), (f = !0)), N !== bU)) {
      if (N !== y || ft !== R) {
        if (
          ((g !== Ns || A !== Ns) &&
            (t.blendEquation(t.FUNC_ADD), (g = Ns), (A = Ns)),
          ft)
        )
          switch (N) {
            case ro:
              t.blendFuncSeparate(
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nm:
              t.blendFunc(t.ONE, t.ONE);
              break;
            case qy:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case Yy:
              t.blendFuncSeparate(t.ZERO, t.SRC_COLOR, t.ZERO, t.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        else
          switch (N) {
            case ro:
              t.blendFuncSeparate(
                t.SRC_ALPHA,
                t.ONE_MINUS_SRC_ALPHA,
                t.ONE,
                t.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nm:
              t.blendFunc(t.SRC_ALPHA, t.ONE);
              break;
            case qy:
              t.blendFuncSeparate(t.ZERO, t.ONE_MINUS_SRC_COLOR, t.ZERO, t.ONE);
              break;
            case Yy:
              t.blendFunc(t.ZERO, t.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", N);
              break;
          }
        (S = null),
          (T = null),
          (b = null),
          (P = null),
          G.set(0, 0, 0),
          (w = 0),
          (y = N),
          (R = ft);
      }
      return;
    }
    (pe = pe || de),
      (et = et || B),
      (ht = ht || ae),
      (de !== g || pe !== A) &&
        (t.blendEquationSeparate(be[de], be[pe]), (g = de), (A = pe)),
      (B !== S || ae !== T || et !== b || ht !== P) &&
        (t.blendFuncSeparate(Ze[B], Ze[ae], Ze[et], Ze[ht]),
        (S = B),
        (T = ae),
        (b = et),
        (P = ht)),
      (Kt.equals(G) === !1 || qn !== w) &&
        (t.blendColor(Kt.r, Kt.g, Kt.b, qn), G.copy(Kt), (w = qn)),
      (y = N),
      (R = !1);
  }
  function nt(N, de) {
    N.side === nr ? lt(t.CULL_FACE) : _e(t.CULL_FACE);
    let B = N.side === Dn;
    de && (B = !B),
      qe(B),
      N.blending === ro && N.transparent === !1
        ? Ne(Zr)
        : Ne(
            N.blending,
            N.blendEquation,
            N.blendSrc,
            N.blendDst,
            N.blendEquationAlpha,
            N.blendSrcAlpha,
            N.blendDstAlpha,
            N.blendColor,
            N.blendAlpha,
            N.premultipliedAlpha
          ),
      l.setFunc(N.depthFunc),
      l.setTest(N.depthTest),
      l.setMask(N.depthWrite),
      o.setMask(N.colorWrite);
    const ae = N.stencilWrite;
    c.setTest(ae),
      ae &&
        (c.setMask(N.stencilWriteMask),
        c.setFunc(N.stencilFunc, N.stencilRef, N.stencilFuncMask),
        c.setOp(N.stencilFail, N.stencilZFail, N.stencilZPass)),
      C(N.polygonOffset, N.polygonOffsetFactor, N.polygonOffsetUnits),
      N.alphaToCoverage === !0
        ? _e(t.SAMPLE_ALPHA_TO_COVERAGE)
        : lt(t.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function qe(N) {
    ie !== N && (N ? t.frontFace(t.CW) : t.frontFace(t.CCW), (ie = N));
  }
  function Ke(N) {
    N !== EU
      ? (_e(t.CULL_FACE),
        N !== J &&
          (N === Xy
            ? t.cullFace(t.BACK)
            : N === TU
            ? t.cullFace(t.FRONT)
            : t.cullFace(t.FRONT_AND_BACK)))
      : lt(t.CULL_FACE),
      (J = N);
  }
  function Pt(N) {
    N !== D && (L && t.lineWidth(N), (D = N));
  }
  function C(N, de, B) {
    N
      ? (_e(t.POLYGON_OFFSET_FILL),
        (Y !== de || q !== B) && (t.polygonOffset(de, B), (Y = de), (q = B)))
      : lt(t.POLYGON_OFFSET_FILL);
  }
  function E(N) {
    N ? _e(t.SCISSOR_TEST) : lt(t.SCISSOR_TEST);
  }
  function $(N) {
    N === void 0 && (N = t.TEXTURE0 + W - 1),
      K !== N && (t.activeTexture(N), (K = N));
  }
  function Z(N, de, B) {
    B === void 0 && (K === null ? (B = t.TEXTURE0 + W - 1) : (B = K));
    let ae = oe[B];
    ae === void 0 &&
      ((ae = {
        type: void 0,
        texture: void 0,
      }),
      (oe[B] = ae)),
      (ae.type !== N || ae.texture !== de) &&
        (K !== B && (t.activeTexture(B), (K = B)),
        t.bindTexture(N, de || Ee[N]),
        (ae.type = N),
        (ae.texture = de));
  }
  function re() {
    const N = oe[K];
    N !== void 0 &&
      N.type !== void 0 &&
      (t.bindTexture(N.type, null), (N.type = void 0), (N.texture = void 0));
  }
  function ee() {
    try {
      t.compressedTexImage2D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Ve() {
    try {
      t.compressedTexImage3D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function De() {
    try {
      t.texSubImage2D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function ce() {
    try {
      t.texSubImage3D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function fe() {
    try {
      t.compressedTexSubImage2D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function He() {
    try {
      t.compressedTexSubImage3D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function se() {
    try {
      t.texStorage2D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function kt() {
    try {
      t.texStorage3D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Je() {
    try {
      t.texImage2D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function Te() {
    try {
      t.texImage3D.apply(t, arguments);
    } catch (N) {
      console.error("THREE.WebGLState:", N);
    }
  }
  function xe(N) {
    Q.equals(N) === !1 && (t.scissor(N.x, N.y, N.z, N.w), Q.copy(N));
  }
  function Se(N) {
    he.equals(N) === !1 && (t.viewport(N.x, N.y, N.z, N.w), he.copy(N));
  }
  function it(N, de) {
    let B = d.get(de);
    B === void 0 && ((B = new WeakMap()), d.set(de, B));
    let ae = B.get(N);
    ae === void 0 && ((ae = t.getUniformBlockIndex(de, N.name)), B.set(N, ae));
  }
  function Be(N, de) {
    const ae = d.get(de).get(N);
    u.get(de) !== ae &&
      (t.uniformBlockBinding(de, ae, N.__bindingPointIndex), u.set(de, ae));
  }
  function yt() {
    t.disable(t.BLEND),
      t.disable(t.CULL_FACE),
      t.disable(t.DEPTH_TEST),
      t.disable(t.POLYGON_OFFSET_FILL),
      t.disable(t.SCISSOR_TEST),
      t.disable(t.STENCIL_TEST),
      t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),
      t.blendEquation(t.FUNC_ADD),
      t.blendFunc(t.ONE, t.ZERO),
      t.blendFuncSeparate(t.ONE, t.ZERO, t.ONE, t.ZERO),
      t.blendColor(0, 0, 0, 0),
      t.colorMask(!0, !0, !0, !0),
      t.clearColor(0, 0, 0, 0),
      t.depthMask(!0),
      t.depthFunc(t.LESS),
      t.clearDepth(1),
      t.stencilMask(4294967295),
      t.stencilFunc(t.ALWAYS, 0, 4294967295),
      t.stencilOp(t.KEEP, t.KEEP, t.KEEP),
      t.clearStencil(0),
      t.cullFace(t.BACK),
      t.frontFace(t.CCW),
      t.polygonOffset(0, 0),
      t.activeTexture(t.TEXTURE0),
      t.bindFramebuffer(t.FRAMEBUFFER, null),
      i === !0 &&
        (t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        t.bindFramebuffer(t.READ_FRAMEBUFFER, null)),
      t.useProgram(null),
      t.lineWidth(1),
      t.scissor(0, 0, t.canvas.width, t.canvas.height),
      t.viewport(0, 0, t.canvas.width, t.canvas.height),
      (h = {}),
      (K = null),
      (oe = {}),
      (p = {}),
      (v = new WeakMap()),
      (x = []),
      (m = null),
      (f = !1),
      (y = null),
      (g = null),
      (S = null),
      (T = null),
      (A = null),
      (b = null),
      (P = null),
      (G = new ct(0, 0, 0)),
      (w = 0),
      (R = !1),
      (ie = null),
      (J = null),
      (D = null),
      (Y = null),
      (q = null),
      Q.set(0, 0, t.canvas.width, t.canvas.height),
      he.set(0, 0, t.canvas.width, t.canvas.height),
      o.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: {
      color: o,
      depth: l,
      stencil: c,
    },
    enable: _e,
    disable: lt,
    bindFramebuffer: Ue,
    drawBuffers: I,
    useProgram: Zt,
    setBlending: Ne,
    setMaterial: nt,
    setFlipSided: qe,
    setCullFace: Ke,
    setLineWidth: Pt,
    setPolygonOffset: C,
    setScissorTest: E,
    activeTexture: $,
    bindTexture: Z,
    unbindTexture: re,
    compressedTexImage2D: ee,
    compressedTexImage3D: Ve,
    texImage2D: Je,
    texImage3D: Te,
    updateUBOMapping: it,
    uniformBlockBinding: Be,
    texStorage2D: se,
    texStorage3D: kt,
    texSubImage2D: De,
    texSubImage3D: ce,
    compressedTexSubImage2D: fe,
    compressedTexSubImage3D: He,
    scissor: xe,
    viewport: Se,
    reset: yt,
  };
}
function bj(t, e, n, i, r, s, a) {
  const o = r.isWebGL2,
    l = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    c =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    u = new ot(),
    d = new WeakMap();
  let h;
  const p = new WeakMap();
  let v = !1;
  try {
    v =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function x(C, E) {
    return v ? new OffscreenCanvas(C, E) : Vd("canvas");
  }
  function m(C, E, $, Z) {
    let re = 1;
    const ee = Pt(C);
    if (
      ((ee.width > Z || ee.height > Z) &&
        (re = Z / Math.max(ee.width, ee.height)),
      re < 1 || E === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && C instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && C instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && C instanceof ImageBitmap) ||
        (typeof VideoFrame < "u" && C instanceof VideoFrame)
      ) {
        const Ve = E ? jm : Math.floor,
          De = Ve(re * ee.width),
          ce = Ve(re * ee.height);
        h === void 0 && (h = x(De, ce));
        const fe = $ ? x(De, ce) : h;
        return (
          (fe.width = De),
          (fe.height = ce),
          fe.getContext("2d").drawImage(C, 0, 0, De, ce),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              ee.width +
              "x" +
              ee.height +
              ") to (" +
              De +
              "x" +
              ce +
              ")."
          ),
          fe
        );
      } else
        return (
          "data" in C &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                ee.width +
                "x" +
                ee.height +
                ")."
            ),
          C
        );
    return C;
  }
  function f(C) {
    const E = Pt(C);
    return Ax(E.width) && Ax(E.height);
  }
  function y(C) {
    return o
      ? !1
      : C.wrapS !== vi ||
          C.wrapT !== vi ||
          (C.minFilter !== vn && C.minFilter !== Mn);
  }
  function g(C, E) {
    return C.generateMipmaps && E && C.minFilter !== vn && C.minFilter !== Mn;
  }
  function S(C) {
    t.generateMipmap(C);
  }
  function T(C, E, $, Z, re = !1) {
    if (o === !1) return E;
    if (C !== null) {
      if (t[C] !== void 0) return t[C];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          C +
          "'"
      );
    }
    let ee = E;
    if (
      (E === t.RED &&
        ($ === t.FLOAT && (ee = t.R32F),
        $ === t.HALF_FLOAT && (ee = t.R16F),
        $ === t.UNSIGNED_BYTE && (ee = t.R8)),
      E === t.RED_INTEGER &&
        ($ === t.UNSIGNED_BYTE && (ee = t.R8UI),
        $ === t.UNSIGNED_SHORT && (ee = t.R16UI),
        $ === t.UNSIGNED_INT && (ee = t.R32UI),
        $ === t.BYTE && (ee = t.R8I),
        $ === t.SHORT && (ee = t.R16I),
        $ === t.INT && (ee = t.R32I)),
      E === t.RG &&
        ($ === t.FLOAT && (ee = t.RG32F),
        $ === t.HALF_FLOAT && (ee = t.RG16F),
        $ === t.UNSIGNED_BYTE && (ee = t.RG8)),
      E === t.RG_INTEGER &&
        ($ === t.UNSIGNED_BYTE && (ee = t.RG8UI),
        $ === t.UNSIGNED_SHORT && (ee = t.RG16UI),
        $ === t.UNSIGNED_INT && (ee = t.RG32UI),
        $ === t.BYTE && (ee = t.RG8I),
        $ === t.SHORT && (ee = t.RG16I),
        $ === t.INT && (ee = t.RG32I)),
      E === t.RGBA)
    ) {
      const Ve = re ? Fd : dt.getTransfer(Z);
      $ === t.FLOAT && (ee = t.RGBA32F),
        $ === t.HALF_FLOAT && (ee = t.RGBA16F),
        $ === t.UNSIGNED_BYTE && (ee = Ve === vt ? t.SRGB8_ALPHA8 : t.RGBA8),
        $ === t.UNSIGNED_SHORT_4_4_4_4 && (ee = t.RGBA4),
        $ === t.UNSIGNED_SHORT_5_5_5_1 && (ee = t.RGB5_A1);
    }
    return (
      (ee === t.R16F ||
        ee === t.R32F ||
        ee === t.RG16F ||
        ee === t.RG32F ||
        ee === t.RGBA16F ||
        ee === t.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      ee
    );
  }
  function A(C, E, $) {
    return g(C, $) === !0 ||
      (C.isFramebufferTexture && C.minFilter !== vn && C.minFilter !== Mn)
      ? Math.log2(Math.max(E.width, E.height)) + 1
      : C.mipmaps !== void 0 && C.mipmaps.length > 0
      ? C.mipmaps.length
      : C.isCompressedTexture && Array.isArray(C.image)
      ? E.mipmaps.length
      : 1;
  }
  function b(C) {
    return C === vn || C === Jy || C === qo ? t.NEAREST : t.LINEAR;
  }
  function P(C) {
    const E = C.target;
    E.removeEventListener("dispose", P), w(E), E.isVideoTexture && d.delete(E);
  }
  function G(C) {
    const E = C.target;
    E.removeEventListener("dispose", G), ie(E);
  }
  function w(C) {
    const E = i.get(C);
    if (E.__webglInit === void 0) return;
    const $ = C.source,
      Z = p.get($);
    if (Z) {
      const re = Z[E.__cacheKey];
      re.usedTimes--,
        re.usedTimes === 0 && R(C),
        Object.keys(Z).length === 0 && p.delete($);
    }
    i.remove(C);
  }
  function R(C) {
    const E = i.get(C);
    t.deleteTexture(E.__webglTexture);
    const $ = C.source,
      Z = p.get($);
    delete Z[E.__cacheKey], a.memory.textures--;
  }
  function ie(C) {
    const E = i.get(C);
    if ((C.depthTexture && C.depthTexture.dispose(), C.isWebGLCubeRenderTarget))
      for (let Z = 0; Z < 6; Z++) {
        if (Array.isArray(E.__webglFramebuffer[Z]))
          for (let re = 0; re < E.__webglFramebuffer[Z].length; re++)
            t.deleteFramebuffer(E.__webglFramebuffer[Z][re]);
        else t.deleteFramebuffer(E.__webglFramebuffer[Z]);
        E.__webglDepthbuffer && t.deleteRenderbuffer(E.__webglDepthbuffer[Z]);
      }
    else {
      if (Array.isArray(E.__webglFramebuffer))
        for (let Z = 0; Z < E.__webglFramebuffer.length; Z++)
          t.deleteFramebuffer(E.__webglFramebuffer[Z]);
      else t.deleteFramebuffer(E.__webglFramebuffer);
      if (
        (E.__webglDepthbuffer && t.deleteRenderbuffer(E.__webglDepthbuffer),
        E.__webglMultisampledFramebuffer &&
          t.deleteFramebuffer(E.__webglMultisampledFramebuffer),
        E.__webglColorRenderbuffer)
      )
        for (let Z = 0; Z < E.__webglColorRenderbuffer.length; Z++)
          E.__webglColorRenderbuffer[Z] &&
            t.deleteRenderbuffer(E.__webglColorRenderbuffer[Z]);
      E.__webglDepthRenderbuffer &&
        t.deleteRenderbuffer(E.__webglDepthRenderbuffer);
    }
    const $ = C.textures;
    for (let Z = 0, re = $.length; Z < re; Z++) {
      const ee = i.get($[Z]);
      ee.__webglTexture &&
        (t.deleteTexture(ee.__webglTexture), a.memory.textures--),
        i.remove($[Z]);
    }
    i.remove(C);
  }
  let J = 0;
  function D() {
    J = 0;
  }
  function Y() {
    const C = J;
    return (
      C >= r.maxTextures &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            C +
            " texture units while this GPU supports only " +
            r.maxTextures
        ),
      (J += 1),
      C
    );
  }
  function q(C) {
    const E = [];
    return (
      E.push(C.wrapS),
      E.push(C.wrapT),
      E.push(C.wrapR || 0),
      E.push(C.magFilter),
      E.push(C.minFilter),
      E.push(C.anisotropy),
      E.push(C.internalFormat),
      E.push(C.format),
      E.push(C.type),
      E.push(C.generateMipmaps),
      E.push(C.premultiplyAlpha),
      E.push(C.flipY),
      E.push(C.unpackAlignment),
      E.push(C.colorSpace),
      E.join()
    );
  }
  function W(C, E) {
    const $ = i.get(C);
    if (
      (C.isVideoTexture && qe(C),
      C.isRenderTargetTexture === !1 &&
        C.version > 0 &&
        $.__version !== C.version)
    ) {
      const Z = C.image;
      if (Z === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Z.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        he($, C, E);
        return;
      }
    }
    n.bindTexture(t.TEXTURE_2D, $.__webglTexture, t.TEXTURE0 + E);
  }
  function L(C, E) {
    const $ = i.get(C);
    if (C.version > 0 && $.__version !== C.version) {
      he($, C, E);
      return;
    }
    n.bindTexture(t.TEXTURE_2D_ARRAY, $.__webglTexture, t.TEXTURE0 + E);
  }
  function U(C, E) {
    const $ = i.get(C);
    if (C.version > 0 && $.__version !== C.version) {
      he($, C, E);
      return;
    }
    n.bindTexture(t.TEXTURE_3D, $.__webglTexture, t.TEXTURE0 + E);
  }
  function X(C, E) {
    const $ = i.get(C);
    if (C.version > 0 && $.__version !== C.version) {
      Re($, C, E);
      return;
    }
    n.bindTexture(t.TEXTURE_CUBE_MAP, $.__webglTexture, t.TEXTURE0 + E);
  }
  const K = {
      [Om]: t.REPEAT,
      [vi]: t.CLAMP_TO_EDGE,
      [Fm]: t.MIRRORED_REPEAT,
    },
    oe = {
      [vn]: t.NEAREST,
      [Jy]: t.NEAREST_MIPMAP_NEAREST,
      [qo]: t.NEAREST_MIPMAP_LINEAR,
      [Mn]: t.LINEAR,
      [Af]: t.LINEAR_MIPMAP_NEAREST,
      [Fs]: t.LINEAR_MIPMAP_LINEAR,
    },
    ke = {
      [gO]: t.NEVER,
      [wO]: t.ALWAYS,
      [vO]: t.LESS,
      [mM]: t.LEQUAL,
      [_O]: t.EQUAL,
      [SO]: t.GEQUAL,
      [yO]: t.GREATER,
      [xO]: t.NOTEQUAL,
    };
  function V(C, E, $) {
    if (
      (E.type === ir &&
        e.has("OES_texture_float_linear") === !1 &&
        (E.magFilter === Mn ||
          E.magFilter === Af ||
          E.magFilter === qo ||
          E.magFilter === Fs ||
          E.minFilter === Mn ||
          E.minFilter === Af ||
          E.minFilter === qo ||
          E.minFilter === Fs) &&
        console.warn(
          "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
        ),
      $
        ? (t.texParameteri(C, t.TEXTURE_WRAP_S, K[E.wrapS]),
          t.texParameteri(C, t.TEXTURE_WRAP_T, K[E.wrapT]),
          (C === t.TEXTURE_3D || C === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(C, t.TEXTURE_WRAP_R, K[E.wrapR]),
          t.texParameteri(C, t.TEXTURE_MAG_FILTER, oe[E.magFilter]),
          t.texParameteri(C, t.TEXTURE_MIN_FILTER, oe[E.minFilter]))
        : (t.texParameteri(C, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE),
          t.texParameteri(C, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE),
          (C === t.TEXTURE_3D || C === t.TEXTURE_2D_ARRAY) &&
            t.texParameteri(C, t.TEXTURE_WRAP_R, t.CLAMP_TO_EDGE),
          (E.wrapS !== vi || E.wrapT !== vi) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          t.texParameteri(C, t.TEXTURE_MAG_FILTER, b(E.magFilter)),
          t.texParameteri(C, t.TEXTURE_MIN_FILTER, b(E.minFilter)),
          E.minFilter !== vn &&
            E.minFilter !== Mn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      E.compareFunction &&
        (t.texParameteri(C, t.TEXTURE_COMPARE_MODE, t.COMPARE_REF_TO_TEXTURE),
        t.texParameteri(C, t.TEXTURE_COMPARE_FUNC, ke[E.compareFunction])),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      if (
        E.magFilter === vn ||
        (E.minFilter !== qo && E.minFilter !== Fs) ||
        (E.type === ir && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          E.type === hc &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      if (E.anisotropy > 1 || i.get(E).__currentAnisotropy) {
        const Z = e.get("EXT_texture_filter_anisotropic");
        t.texParameterf(
          C,
          Z.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(E.anisotropy, r.getMaxAnisotropy())
        ),
          (i.get(E).__currentAnisotropy = E.anisotropy);
      }
    }
  }
  function Q(C, E) {
    let $ = !1;
    C.__webglInit === void 0 &&
      ((C.__webglInit = !0), E.addEventListener("dispose", P));
    const Z = E.source;
    let re = p.get(Z);
    re === void 0 && ((re = {}), p.set(Z, re));
    const ee = q(E);
    if (ee !== C.__cacheKey) {
      re[ee] === void 0 &&
        ((re[ee] = {
          texture: t.createTexture(),
          usedTimes: 0,
        }),
        a.memory.textures++,
        ($ = !0)),
        re[ee].usedTimes++;
      const Ve = re[C.__cacheKey];
      Ve !== void 0 &&
        (re[C.__cacheKey].usedTimes--, Ve.usedTimes === 0 && R(E)),
        (C.__cacheKey = ee),
        (C.__webglTexture = re[ee].texture);
    }
    return $;
  }
  function he(C, E, $) {
    let Z = t.TEXTURE_2D;
    (E.isDataArrayTexture || E.isCompressedArrayTexture) &&
      (Z = t.TEXTURE_2D_ARRAY),
      E.isData3DTexture && (Z = t.TEXTURE_3D);
    const re = Q(C, E),
      ee = E.source;
    n.bindTexture(Z, C.__webglTexture, t.TEXTURE0 + $);
    const Ve = i.get(ee);
    if (ee.version !== Ve.__version || re === !0) {
      n.activeTexture(t.TEXTURE0 + $);
      const De = dt.getPrimaries(dt.workingColorSpace),
        ce = E.colorSpace === Ur ? null : dt.getPrimaries(E.colorSpace),
        fe =
          E.colorSpace === Ur || De === ce ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, E.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, E.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, fe);
      const He = y(E) && f(E.image) === !1;
      let se = m(E.image, He, !1, r.maxTextureSize);
      se = Ke(E, se);
      const kt = f(se) || o,
        Je = s.convert(E.format, E.colorSpace);
      let Te = s.convert(E.type),
        xe = T(E.internalFormat, Je, Te, E.colorSpace, E.isVideoTexture);
      V(Z, E, kt);
      let Se;
      const it = E.mipmaps,
        Be = o && E.isVideoTexture !== !0 && xe !== pM,
        yt = Ve.__version === void 0 || re === !0,
        N = ee.dataReady,
        de = A(E, se, kt);
      if (E.isDepthTexture)
        (xe = t.DEPTH_COMPONENT),
          o
            ? E.type === ir
              ? (xe = t.DEPTH_COMPONENT32F)
              : E.type === zr
              ? (xe = t.DEPTH_COMPONENT24)
              : E.type === Hs
              ? (xe = t.DEPTH24_STENCIL8)
              : (xe = t.DEPTH_COMPONENT16)
            : E.type === ir &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          E.format === Gs &&
            xe === t.DEPTH_COMPONENT &&
            E.type !== Rv &&
            E.type !== zr &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (E.type = zr),
            (Te = s.convert(E.type))),
          E.format === Eo &&
            xe === t.DEPTH_COMPONENT &&
            ((xe = t.DEPTH_STENCIL),
            E.type !== Hs &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (E.type = Hs),
              (Te = s.convert(E.type)))),
          yt &&
            (Be
              ? n.texStorage2D(t.TEXTURE_2D, 1, xe, se.width, se.height)
              : n.texImage2D(
                  t.TEXTURE_2D,
                  0,
                  xe,
                  se.width,
                  se.height,
                  0,
                  Je,
                  Te,
                  null
                ));
      else if (E.isDataTexture)
        if (it.length > 0 && kt) {
          Be &&
            yt &&
            n.texStorage2D(t.TEXTURE_2D, de, xe, it[0].width, it[0].height);
          for (let B = 0, ae = it.length; B < ae; B++)
            (Se = it[B]),
              Be
                ? N &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    B,
                    0,
                    0,
                    Se.width,
                    Se.height,
                    Je,
                    Te,
                    Se.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    B,
                    xe,
                    Se.width,
                    Se.height,
                    0,
                    Je,
                    Te,
                    Se.data
                  );
          E.generateMipmaps = !1;
        } else
          Be
            ? (yt && n.texStorage2D(t.TEXTURE_2D, de, xe, se.width, se.height),
              N &&
                n.texSubImage2D(
                  t.TEXTURE_2D,
                  0,
                  0,
                  0,
                  se.width,
                  se.height,
                  Je,
                  Te,
                  se.data
                ))
            : n.texImage2D(
                t.TEXTURE_2D,
                0,
                xe,
                se.width,
                se.height,
                0,
                Je,
                Te,
                se.data
              );
      else if (E.isCompressedTexture)
        if (E.isCompressedArrayTexture) {
          Be &&
            yt &&
            n.texStorage3D(
              t.TEXTURE_2D_ARRAY,
              de,
              xe,
              it[0].width,
              it[0].height,
              se.depth
            );
          for (let B = 0, ae = it.length; B < ae; B++)
            (Se = it[B]),
              E.format !== _i
                ? Je !== null
                  ? Be
                    ? N &&
                      n.compressedTexSubImage3D(
                        t.TEXTURE_2D_ARRAY,
                        B,
                        0,
                        0,
                        0,
                        Se.width,
                        Se.height,
                        se.depth,
                        Je,
                        Se.data,
                        0,
                        0
                      )
                    : n.compressedTexImage3D(
                        t.TEXTURE_2D_ARRAY,
                        B,
                        xe,
                        Se.width,
                        Se.height,
                        se.depth,
                        0,
                        Se.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Be
                ? N &&
                  n.texSubImage3D(
                    t.TEXTURE_2D_ARRAY,
                    B,
                    0,
                    0,
                    0,
                    Se.width,
                    Se.height,
                    se.depth,
                    Je,
                    Te,
                    Se.data
                  )
                : n.texImage3D(
                    t.TEXTURE_2D_ARRAY,
                    B,
                    xe,
                    Se.width,
                    Se.height,
                    se.depth,
                    0,
                    Je,
                    Te,
                    Se.data
                  );
        } else {
          Be &&
            yt &&
            n.texStorage2D(t.TEXTURE_2D, de, xe, it[0].width, it[0].height);
          for (let B = 0, ae = it.length; B < ae; B++)
            (Se = it[B]),
              E.format !== _i
                ? Je !== null
                  ? Be
                    ? N &&
                      n.compressedTexSubImage2D(
                        t.TEXTURE_2D,
                        B,
                        0,
                        0,
                        Se.width,
                        Se.height,
                        Je,
                        Se.data
                      )
                    : n.compressedTexImage2D(
                        t.TEXTURE_2D,
                        B,
                        xe,
                        Se.width,
                        Se.height,
                        0,
                        Se.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : Be
                ? N &&
                  n.texSubImage2D(
                    t.TEXTURE_2D,
                    B,
                    0,
                    0,
                    Se.width,
                    Se.height,
                    Je,
                    Te,
                    Se.data
                  )
                : n.texImage2D(
                    t.TEXTURE_2D,
                    B,
                    xe,
                    Se.width,
                    Se.height,
                    0,
                    Je,
                    Te,
                    Se.data
                  );
        }
      else if (E.isDataArrayTexture)
        Be
          ? (yt &&
              n.texStorage3D(
                t.TEXTURE_2D_ARRAY,
                de,
                xe,
                se.width,
                se.height,
                se.depth
              ),
            N &&
              n.texSubImage3D(
                t.TEXTURE_2D_ARRAY,
                0,
                0,
                0,
                0,
                se.width,
                se.height,
                se.depth,
                Je,
                Te,
                se.data
              ))
          : n.texImage3D(
              t.TEXTURE_2D_ARRAY,
              0,
              xe,
              se.width,
              se.height,
              se.depth,
              0,
              Je,
              Te,
              se.data
            );
      else if (E.isData3DTexture)
        Be
          ? (yt &&
              n.texStorage3D(
                t.TEXTURE_3D,
                de,
                xe,
                se.width,
                se.height,
                se.depth
              ),
            N &&
              n.texSubImage3D(
                t.TEXTURE_3D,
                0,
                0,
                0,
                0,
                se.width,
                se.height,
                se.depth,
                Je,
                Te,
                se.data
              ))
          : n.texImage3D(
              t.TEXTURE_3D,
              0,
              xe,
              se.width,
              se.height,
              se.depth,
              0,
              Je,
              Te,
              se.data
            );
      else if (E.isFramebufferTexture) {
        if (yt)
          if (Be) n.texStorage2D(t.TEXTURE_2D, de, xe, se.width, se.height);
          else {
            let B = se.width,
              ae = se.height;
            for (let pe = 0; pe < de; pe++)
              n.texImage2D(t.TEXTURE_2D, pe, xe, B, ae, 0, Je, Te, null),
                (B >>= 1),
                (ae >>= 1);
          }
      } else if (it.length > 0 && kt) {
        if (Be && yt) {
          const B = Pt(it[0]);
          n.texStorage2D(t.TEXTURE_2D, de, xe, B.width, B.height);
        }
        for (let B = 0, ae = it.length; B < ae; B++)
          (Se = it[B]),
            Be
              ? N && n.texSubImage2D(t.TEXTURE_2D, B, 0, 0, Je, Te, Se)
              : n.texImage2D(t.TEXTURE_2D, B, xe, Je, Te, Se);
        E.generateMipmaps = !1;
      } else if (Be) {
        if (yt) {
          const B = Pt(se);
          n.texStorage2D(t.TEXTURE_2D, de, xe, B.width, B.height);
        }
        N && n.texSubImage2D(t.TEXTURE_2D, 0, 0, 0, Je, Te, se);
      } else n.texImage2D(t.TEXTURE_2D, 0, xe, Je, Te, se);
      g(E, kt) && S(Z),
        (Ve.__version = ee.version),
        E.onUpdate && E.onUpdate(E);
    }
    C.__version = E.version;
  }
  function Re(C, E, $) {
    if (E.image.length !== 6) return;
    const Z = Q(C, E),
      re = E.source;
    n.bindTexture(t.TEXTURE_CUBE_MAP, C.__webglTexture, t.TEXTURE0 + $);
    const ee = i.get(re);
    if (re.version !== ee.__version || Z === !0) {
      n.activeTexture(t.TEXTURE0 + $);
      const Ve = dt.getPrimaries(dt.workingColorSpace),
        De = E.colorSpace === Ur ? null : dt.getPrimaries(E.colorSpace),
        ce =
          E.colorSpace === Ur || Ve === De ? t.NONE : t.BROWSER_DEFAULT_WEBGL;
      t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL, E.flipY),
        t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL, E.premultiplyAlpha),
        t.pixelStorei(t.UNPACK_ALIGNMENT, E.unpackAlignment),
        t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL, ce);
      const fe = E.isCompressedTexture || E.image[0].isCompressedTexture,
        He = E.image[0] && E.image[0].isDataTexture,
        se = [];
      for (let B = 0; B < 6; B++)
        !fe && !He
          ? (se[B] = m(E.image[B], !1, !0, r.maxCubemapSize))
          : (se[B] = He ? E.image[B].image : E.image[B]),
          (se[B] = Ke(E, se[B]));
      const kt = se[0],
        Je = f(kt) || o,
        Te = s.convert(E.format, E.colorSpace),
        xe = s.convert(E.type),
        Se = T(E.internalFormat, Te, xe, E.colorSpace),
        it = o && E.isVideoTexture !== !0,
        Be = ee.__version === void 0 || Z === !0,
        yt = re.dataReady;
      let N = A(E, kt, Je);
      V(t.TEXTURE_CUBE_MAP, E, Je);
      let de;
      if (fe) {
        it &&
          Be &&
          n.texStorage2D(t.TEXTURE_CUBE_MAP, N, Se, kt.width, kt.height);
        for (let B = 0; B < 6; B++) {
          de = se[B].mipmaps;
          for (let ae = 0; ae < de.length; ae++) {
            const pe = de[ae];
            E.format !== _i
              ? Te !== null
                ? it
                  ? yt &&
                    n.compressedTexSubImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                      ae,
                      0,
                      0,
                      pe.width,
                      pe.height,
                      Te,
                      pe.data
                    )
                  : n.compressedTexImage2D(
                      t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                      ae,
                      Se,
                      pe.width,
                      pe.height,
                      0,
                      pe.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : it
              ? yt &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  ae,
                  0,
                  0,
                  pe.width,
                  pe.height,
                  Te,
                  xe,
                  pe.data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  ae,
                  Se,
                  pe.width,
                  pe.height,
                  0,
                  Te,
                  xe,
                  pe.data
                );
          }
        }
      } else {
        if (((de = E.mipmaps), it && Be)) {
          de.length > 0 && N++;
          const B = Pt(se[0]);
          n.texStorage2D(t.TEXTURE_CUBE_MAP, N, Se, B.width, B.height);
        }
        for (let B = 0; B < 6; B++)
          if (He) {
            it
              ? yt &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  0,
                  0,
                  0,
                  se[B].width,
                  se[B].height,
                  Te,
                  xe,
                  se[B].data
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  0,
                  Se,
                  se[B].width,
                  se[B].height,
                  0,
                  Te,
                  xe,
                  se[B].data
                );
            for (let ae = 0; ae < de.length; ae++) {
              const et = de[ae].image[B].image;
              it
                ? yt &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                    ae + 1,
                    0,
                    0,
                    et.width,
                    et.height,
                    Te,
                    xe,
                    et.data
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                    ae + 1,
                    Se,
                    et.width,
                    et.height,
                    0,
                    Te,
                    xe,
                    et.data
                  );
            }
          } else {
            it
              ? yt &&
                n.texSubImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  0,
                  0,
                  0,
                  Te,
                  xe,
                  se[B]
                )
              : n.texImage2D(
                  t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                  0,
                  Se,
                  Te,
                  xe,
                  se[B]
                );
            for (let ae = 0; ae < de.length; ae++) {
              const pe = de[ae];
              it
                ? yt &&
                  n.texSubImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                    ae + 1,
                    0,
                    0,
                    Te,
                    xe,
                    pe.image[B]
                  )
                : n.texImage2D(
                    t.TEXTURE_CUBE_MAP_POSITIVE_X + B,
                    ae + 1,
                    Se,
                    Te,
                    xe,
                    pe.image[B]
                  );
            }
          }
      }
      g(E, Je) && S(t.TEXTURE_CUBE_MAP),
        (ee.__version = re.version),
        E.onUpdate && E.onUpdate(E);
    }
    C.__version = E.version;
  }
  function Ee(C, E, $, Z, re, ee) {
    const Ve = s.convert($.format, $.colorSpace),
      De = s.convert($.type),
      ce = T($.internalFormat, Ve, De, $.colorSpace);
    if (!i.get(E).__hasExternalTextures) {
      const He = Math.max(1, E.width >> ee),
        se = Math.max(1, E.height >> ee);
      re === t.TEXTURE_3D || re === t.TEXTURE_2D_ARRAY
        ? n.texImage3D(re, ee, ce, He, se, E.depth, 0, Ve, De, null)
        : n.texImage2D(re, ee, ce, He, se, 0, Ve, De, null);
    }
    n.bindFramebuffer(t.FRAMEBUFFER, C),
      nt(E)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            Z,
            re,
            i.get($).__webglTexture,
            0,
            Ne(E)
          )
        : (re === t.TEXTURE_2D ||
            (re >= t.TEXTURE_CUBE_MAP_POSITIVE_X &&
              re <= t.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          t.framebufferTexture2D(
            t.FRAMEBUFFER,
            Z,
            re,
            i.get($).__webglTexture,
            ee
          ),
      n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function _e(C, E, $) {
    if (
      (t.bindRenderbuffer(t.RENDERBUFFER, C), E.depthBuffer && !E.stencilBuffer)
    ) {
      let Z = o === !0 ? t.DEPTH_COMPONENT24 : t.DEPTH_COMPONENT16;
      if ($ || nt(E)) {
        const re = E.depthTexture;
        re &&
          re.isDepthTexture &&
          (re.type === ir
            ? (Z = t.DEPTH_COMPONENT32F)
            : re.type === zr && (Z = t.DEPTH_COMPONENT24));
        const ee = Ne(E);
        nt(E)
          ? l.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              ee,
              Z,
              E.width,
              E.height
            )
          : t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              ee,
              Z,
              E.width,
              E.height
            );
      } else t.renderbufferStorage(t.RENDERBUFFER, Z, E.width, E.height);
      t.framebufferRenderbuffer(
        t.FRAMEBUFFER,
        t.DEPTH_ATTACHMENT,
        t.RENDERBUFFER,
        C
      );
    } else if (E.depthBuffer && E.stencilBuffer) {
      const Z = Ne(E);
      $ && nt(E) === !1
        ? t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Z,
            t.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : nt(E)
        ? l.renderbufferStorageMultisampleEXT(
            t.RENDERBUFFER,
            Z,
            t.DEPTH24_STENCIL8,
            E.width,
            E.height
          )
        : t.renderbufferStorage(
            t.RENDERBUFFER,
            t.DEPTH_STENCIL,
            E.width,
            E.height
          ),
        t.framebufferRenderbuffer(
          t.FRAMEBUFFER,
          t.DEPTH_STENCIL_ATTACHMENT,
          t.RENDERBUFFER,
          C
        );
    } else {
      const Z = E.textures;
      for (let re = 0; re < Z.length; re++) {
        const ee = Z[re],
          Ve = s.convert(ee.format, ee.colorSpace),
          De = s.convert(ee.type),
          ce = T(ee.internalFormat, Ve, De, ee.colorSpace),
          fe = Ne(E);
        $ && nt(E) === !1
          ? t.renderbufferStorageMultisample(
              t.RENDERBUFFER,
              fe,
              ce,
              E.width,
              E.height
            )
          : nt(E)
          ? l.renderbufferStorageMultisampleEXT(
              t.RENDERBUFFER,
              fe,
              ce,
              E.width,
              E.height
            )
          : t.renderbufferStorage(t.RENDERBUFFER, ce, E.width, E.height);
      }
    }
    t.bindRenderbuffer(t.RENDERBUFFER, null);
  }
  function lt(C, E) {
    if (E && E.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (n.bindFramebuffer(t.FRAMEBUFFER, C),
      !(E.depthTexture && E.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(E.depthTexture).__webglTexture ||
      E.depthTexture.image.width !== E.width ||
      E.depthTexture.image.height !== E.height) &&
      ((E.depthTexture.image.width = E.width),
      (E.depthTexture.image.height = E.height),
      (E.depthTexture.needsUpdate = !0)),
      W(E.depthTexture, 0);
    const Z = i.get(E.depthTexture).__webglTexture,
      re = Ne(E);
    if (E.depthTexture.format === Gs)
      nt(E)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            Z,
            0,
            re
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_ATTACHMENT,
            t.TEXTURE_2D,
            Z,
            0
          );
    else if (E.depthTexture.format === Eo)
      nt(E)
        ? l.framebufferTexture2DMultisampleEXT(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            Z,
            0,
            re
          )
        : t.framebufferTexture2D(
            t.FRAMEBUFFER,
            t.DEPTH_STENCIL_ATTACHMENT,
            t.TEXTURE_2D,
            Z,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function Ue(C) {
    const E = i.get(C),
      $ = C.isWebGLCubeRenderTarget === !0;
    if (C.depthTexture && !E.__autoAllocateDepthBuffer) {
      if ($)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      lt(E.__webglFramebuffer, C);
    } else if ($) {
      E.__webglDepthbuffer = [];
      for (let Z = 0; Z < 6; Z++)
        n.bindFramebuffer(t.FRAMEBUFFER, E.__webglFramebuffer[Z]),
          (E.__webglDepthbuffer[Z] = t.createRenderbuffer()),
          _e(E.__webglDepthbuffer[Z], C, !1);
    } else
      n.bindFramebuffer(t.FRAMEBUFFER, E.__webglFramebuffer),
        (E.__webglDepthbuffer = t.createRenderbuffer()),
        _e(E.__webglDepthbuffer, C, !1);
    n.bindFramebuffer(t.FRAMEBUFFER, null);
  }
  function I(C, E, $) {
    const Z = i.get(C);
    E !== void 0 &&
      Ee(
        Z.__webglFramebuffer,
        C,
        C.texture,
        t.COLOR_ATTACHMENT0,
        t.TEXTURE_2D,
        0
      ),
      $ !== void 0 && Ue(C);
  }
  function Zt(C) {
    const E = C.texture,
      $ = i.get(C),
      Z = i.get(E);
    C.addEventListener("dispose", G);
    const re = C.textures,
      ee = C.isWebGLCubeRenderTarget === !0,
      Ve = re.length > 1,
      De = f(C) || o;
    if (
      (Ve ||
        (Z.__webglTexture === void 0 && (Z.__webglTexture = t.createTexture()),
        (Z.__version = E.version),
        a.memory.textures++),
      ee)
    ) {
      $.__webglFramebuffer = [];
      for (let ce = 0; ce < 6; ce++)
        if (o && E.mipmaps && E.mipmaps.length > 0) {
          $.__webglFramebuffer[ce] = [];
          for (let fe = 0; fe < E.mipmaps.length; fe++)
            $.__webglFramebuffer[ce][fe] = t.createFramebuffer();
        } else $.__webglFramebuffer[ce] = t.createFramebuffer();
    } else {
      if (o && E.mipmaps && E.mipmaps.length > 0) {
        $.__webglFramebuffer = [];
        for (let ce = 0; ce < E.mipmaps.length; ce++)
          $.__webglFramebuffer[ce] = t.createFramebuffer();
      } else $.__webglFramebuffer = t.createFramebuffer();
      if (Ve)
        if (r.drawBuffers)
          for (let ce = 0, fe = re.length; ce < fe; ce++) {
            const He = i.get(re[ce]);
            He.__webglTexture === void 0 &&
              ((He.__webglTexture = t.createTexture()), a.memory.textures++);
          }
        else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && C.samples > 0 && nt(C) === !1) {
        ($.__webglMultisampledFramebuffer = t.createFramebuffer()),
          ($.__webglColorRenderbuffer = []),
          n.bindFramebuffer(t.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
        for (let ce = 0; ce < re.length; ce++) {
          const fe = re[ce];
          ($.__webglColorRenderbuffer[ce] = t.createRenderbuffer()),
            t.bindRenderbuffer(t.RENDERBUFFER, $.__webglColorRenderbuffer[ce]);
          const He = s.convert(fe.format, fe.colorSpace),
            se = s.convert(fe.type),
            kt = T(
              fe.internalFormat,
              He,
              se,
              fe.colorSpace,
              C.isXRRenderTarget === !0
            ),
            Je = Ne(C);
          t.renderbufferStorageMultisample(
            t.RENDERBUFFER,
            Je,
            kt,
            C.width,
            C.height
          ),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + ce,
              t.RENDERBUFFER,
              $.__webglColorRenderbuffer[ce]
            );
        }
        t.bindRenderbuffer(t.RENDERBUFFER, null),
          C.depthBuffer &&
            (($.__webglDepthRenderbuffer = t.createRenderbuffer()),
            _e($.__webglDepthRenderbuffer, C, !0)),
          n.bindFramebuffer(t.FRAMEBUFFER, null);
      }
    }
    if (ee) {
      n.bindTexture(t.TEXTURE_CUBE_MAP, Z.__webglTexture),
        V(t.TEXTURE_CUBE_MAP, E, De);
      for (let ce = 0; ce < 6; ce++)
        if (o && E.mipmaps && E.mipmaps.length > 0)
          for (let fe = 0; fe < E.mipmaps.length; fe++)
            Ee(
              $.__webglFramebuffer[ce][fe],
              C,
              E,
              t.COLOR_ATTACHMENT0,
              t.TEXTURE_CUBE_MAP_POSITIVE_X + ce,
              fe
            );
        else
          Ee(
            $.__webglFramebuffer[ce],
            C,
            E,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_CUBE_MAP_POSITIVE_X + ce,
            0
          );
      g(E, De) && S(t.TEXTURE_CUBE_MAP), n.unbindTexture();
    } else if (Ve) {
      for (let ce = 0, fe = re.length; ce < fe; ce++) {
        const He = re[ce],
          se = i.get(He);
        n.bindTexture(t.TEXTURE_2D, se.__webglTexture),
          V(t.TEXTURE_2D, He, De),
          Ee(
            $.__webglFramebuffer,
            C,
            He,
            t.COLOR_ATTACHMENT0 + ce,
            t.TEXTURE_2D,
            0
          ),
          g(He, De) && S(t.TEXTURE_2D);
      }
      n.unbindTexture();
    } else {
      let ce = t.TEXTURE_2D;
      if (
        ((C.isWebGL3DRenderTarget || C.isWebGLArrayRenderTarget) &&
          (o
            ? (ce = C.isWebGL3DRenderTarget ? t.TEXTURE_3D : t.TEXTURE_2D_ARRAY)
            : console.error(
                "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
              )),
        n.bindTexture(ce, Z.__webglTexture),
        V(ce, E, De),
        o && E.mipmaps && E.mipmaps.length > 0)
      )
        for (let fe = 0; fe < E.mipmaps.length; fe++)
          Ee($.__webglFramebuffer[fe], C, E, t.COLOR_ATTACHMENT0, ce, fe);
      else Ee($.__webglFramebuffer, C, E, t.COLOR_ATTACHMENT0, ce, 0);
      g(E, De) && S(ce), n.unbindTexture();
    }
    C.depthBuffer && Ue(C);
  }
  function be(C) {
    const E = f(C) || o,
      $ = C.textures;
    for (let Z = 0, re = $.length; Z < re; Z++) {
      const ee = $[Z];
      if (g(ee, E)) {
        const Ve = C.isWebGLCubeRenderTarget
            ? t.TEXTURE_CUBE_MAP
            : t.TEXTURE_2D,
          De = i.get(ee).__webglTexture;
        n.bindTexture(Ve, De), S(Ve), n.unbindTexture();
      }
    }
  }
  function Ze(C) {
    if (o && C.samples > 0 && nt(C) === !1) {
      const E = C.textures,
        $ = C.width,
        Z = C.height;
      let re = t.COLOR_BUFFER_BIT;
      const ee = [],
        Ve = C.stencilBuffer ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT,
        De = i.get(C),
        ce = E.length > 1;
      if (ce)
        for (let fe = 0; fe < E.length; fe++)
          n.bindFramebuffer(t.FRAMEBUFFER, De.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + fe,
              t.RENDERBUFFER,
              null
            ),
            n.bindFramebuffer(t.FRAMEBUFFER, De.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + fe,
              t.TEXTURE_2D,
              null,
              0
            );
      n.bindFramebuffer(t.READ_FRAMEBUFFER, De.__webglMultisampledFramebuffer),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, De.__webglFramebuffer);
      for (let fe = 0; fe < E.length; fe++) {
        ee.push(t.COLOR_ATTACHMENT0 + fe), C.depthBuffer && ee.push(Ve);
        const He =
          De.__ignoreDepthValues !== void 0 ? De.__ignoreDepthValues : !1;
        if (
          (He === !1 &&
            (C.depthBuffer && (re |= t.DEPTH_BUFFER_BIT),
            C.stencilBuffer && (re |= t.STENCIL_BUFFER_BIT)),
          ce &&
            t.framebufferRenderbuffer(
              t.READ_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0,
              t.RENDERBUFFER,
              De.__webglColorRenderbuffer[fe]
            ),
          He === !0 &&
            (t.invalidateFramebuffer(t.READ_FRAMEBUFFER, [Ve]),
            t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, [Ve])),
          ce)
        ) {
          const se = i.get(E[fe]).__webglTexture;
          t.framebufferTexture2D(
            t.DRAW_FRAMEBUFFER,
            t.COLOR_ATTACHMENT0,
            t.TEXTURE_2D,
            se,
            0
          );
        }
        t.blitFramebuffer(0, 0, $, Z, 0, 0, $, Z, re, t.NEAREST),
          c && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, ee);
      }
      if (
        (n.bindFramebuffer(t.READ_FRAMEBUFFER, null),
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
        ce)
      )
        for (let fe = 0; fe < E.length; fe++) {
          n.bindFramebuffer(t.FRAMEBUFFER, De.__webglMultisampledFramebuffer),
            t.framebufferRenderbuffer(
              t.FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + fe,
              t.RENDERBUFFER,
              De.__webglColorRenderbuffer[fe]
            );
          const He = i.get(E[fe]).__webglTexture;
          n.bindFramebuffer(t.FRAMEBUFFER, De.__webglFramebuffer),
            t.framebufferTexture2D(
              t.DRAW_FRAMEBUFFER,
              t.COLOR_ATTACHMENT0 + fe,
              t.TEXTURE_2D,
              He,
              0
            );
        }
      n.bindFramebuffer(t.DRAW_FRAMEBUFFER, De.__webglMultisampledFramebuffer);
    }
  }
  function Ne(C) {
    return Math.min(r.maxSamples, C.samples);
  }
  function nt(C) {
    const E = i.get(C);
    return (
      o &&
      C.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      E.__useRenderToTexture !== !1
    );
  }
  function qe(C) {
    const E = a.render.frame;
    d.get(C) !== E && (d.set(C, E), C.update());
  }
  function Ke(C, E) {
    const $ = C.colorSpace,
      Z = C.format,
      re = C.type;
    return (
      C.isCompressedTexture === !0 ||
        C.isVideoTexture === !0 ||
        C.format === Bm ||
        ($ !== fs &&
          $ !== Ur &&
          (dt.getTransfer($) === vt
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && Z === _i
                ? ((C.format = Bm),
                  (C.minFilter = Mn),
                  (C.generateMipmaps = !1))
                : (E = vM.sRGBToLinear(E))
              : (Z !== _i || re !== Jr) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                $
              ))),
      E
    );
  }
  function Pt(C) {
    return (
      typeof HTMLImageElement < "u" && C instanceof HTMLImageElement
        ? ((u.width = C.naturalWidth || C.width),
          (u.height = C.naturalHeight || C.height))
        : typeof VideoFrame < "u" && C instanceof VideoFrame
        ? ((u.width = C.displayWidth), (u.height = C.displayHeight))
        : ((u.width = C.width), (u.height = C.height)),
      u
    );
  }
  (this.allocateTextureUnit = Y),
    (this.resetTextureUnits = D),
    (this.setTexture2D = W),
    (this.setTexture2DArray = L),
    (this.setTexture3D = U),
    (this.setTextureCube = X),
    (this.rebindTextures = I),
    (this.setupRenderTarget = Zt),
    (this.updateRenderTargetMipmap = be),
    (this.updateMultisampleRenderTarget = Ze),
    (this.setupDepthRenderbuffer = Ue),
    (this.setupFrameBufferTexture = Ee),
    (this.useMultisampledRTT = nt);
}
function Aj(t, e, n) {
  const i = n.isWebGL2;
  function r(s, a = Ur) {
    let o;
    const l = dt.getTransfer(a);
    if (s === Jr) return t.UNSIGNED_BYTE;
    if (s === cM) return t.UNSIGNED_SHORT_4_4_4_4;
    if (s === uM) return t.UNSIGNED_SHORT_5_5_5_1;
    if (s === rO) return t.BYTE;
    if (s === sO) return t.SHORT;
    if (s === Rv) return t.UNSIGNED_SHORT;
    if (s === lM) return t.INT;
    if (s === zr) return t.UNSIGNED_INT;
    if (s === ir) return t.FLOAT;
    if (s === hc)
      return i
        ? t.HALF_FLOAT
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === aO) return t.ALPHA;
    if (s === _i) return t.RGBA;
    if (s === oO) return t.LUMINANCE;
    if (s === lO) return t.LUMINANCE_ALPHA;
    if (s === Gs) return t.DEPTH_COMPONENT;
    if (s === Eo) return t.DEPTH_STENCIL;
    if (s === Bm)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === cO) return t.RED;
    if (s === dM) return t.RED_INTEGER;
    if (s === uO) return t.RG;
    if (s === hM) return t.RG_INTEGER;
    if (s === fM) return t.RGBA_INTEGER;
    if (s === Cf || s === Rf || s === Pf || s === Lf)
      if (l === vt)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (s === Cf) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Rf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Pf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Lf) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === Cf) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Rf) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Pf) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Lf) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Qy || s === ex || s === tx || s === nx)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === Qy) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === ex) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === tx) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === nx) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === pM)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === ix || s === rx)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (s === ix)
          return l === vt ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === rx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === sx ||
      s === ax ||
      s === ox ||
      s === lx ||
      s === cx ||
      s === ux ||
      s === dx ||
      s === hx ||
      s === fx ||
      s === px ||
      s === mx ||
      s === gx ||
      s === vx ||
      s === _x
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (s === sx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === ax)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === ox)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === lx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === cx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === ux)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === dx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === hx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === fx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === px)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === mx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === gx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === vx)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === _x)
          return l === vt
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === Nf || s === yx || s === xx)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (s === Nf)
          return l === vt
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (s === yx) return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (s === xx) return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else return null;
    if (s === dO || s === Sx || s === wx || s === Ex)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (s === Nf) return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === Sx) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === wx) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === Ex) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === Hs
      ? i
        ? t.UNSIGNED_INT_24_8
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : t[s] !== void 0
      ? t[s]
      : null;
  }
  return {
    convert: r,
  };
}
class Cj extends ti {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Au extends In {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const Rj = {
  type: "move",
};
class sp {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Au()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = {
          pinching: !1,
        })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Au()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new z()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new z())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Au()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new z()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new z())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const n = this._hand;
      if (n) for (const i of e.hand.values()) this._getHandJoint(n, i);
    }
    return (
      this.dispatchEvent({
        type: "connected",
        data: e,
      }),
      this
    );
  }
  disconnect(e) {
    return (
      this.dispatchEvent({
        type: "disconnected",
        data: e,
      }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, n, i) {
    let r = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && n.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const x of e.hand.values()) {
          const m = n.getJointPose(x, i),
            f = this._getHandJoint(c, x);
          m !== null &&
            (f.matrix.fromArray(m.transform.matrix),
            f.matrix.decompose(f.position, f.rotation, f.scale),
            (f.matrixWorldNeedsUpdate = !0),
            (f.jointRadius = m.radius)),
            (f.visible = m !== null);
        }
        const u = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          h = u.position.distanceTo(d.position),
          p = 0.02,
          v = 0.005;
        c.inputState.pinching && h > p + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            h <= p - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = n.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((r = n.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (o.matrix.fromArray(r.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          r.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(r.linearVelocity))
            : (o.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(r.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(Rj)));
    }
    return (
      o !== null && (o.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, n) {
    if (e.joints[n.jointName] === void 0) {
      const i = new Au();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[n.jointName] = i),
        e.add(i);
    }
    return e.joints[n.jointName];
  }
}
const Pj = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
  Lj = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepthEXT = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;

class Nj {
  constructor() {
    (this.texture = null),
      (this.mesh = null),
      (this.depthNear = 0),
      (this.depthFar = 0);
  }
  init(e, n, i) {
    if (this.texture === null) {
      const r = new kn(),
        s = e.properties.get(r);
      (s.__webglTexture = n.texture),
        (n.depthNear != i.depthNear || n.depthFar != i.depthFar) &&
          ((this.depthNear = n.depthNear), (this.depthFar = n.depthFar)),
        (this.texture = r);
    }
  }
  render(e, n) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const i = n.cameras[0].viewport,
          r = new os({
            extensions: {
              fragDepth: !0,
            },
            vertexShader: Pj,
            fragmentShader: Lj,
            uniforms: {
              depthColor: {
                value: this.texture,
              },
              depthWidth: {
                value: i.z,
              },
              depthHeight: {
                value: i.w,
              },
            },
          });
        this.mesh = new or(new Mh(20, 20), r);
      }
      e.render(this.mesh, n);
    }
  }
  reset() {
    (this.texture = null), (this.mesh = null);
  }
}
class Dj extends ko {
  constructor(e, n) {
    super();
    const i = this;
    let r = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      u = null,
      d = null,
      h = null,
      p = null,
      v = null;
    const x = new Nj(),
      m = n.getContextAttributes();
    let f = null,
      y = null;
    const g = [],
      S = [],
      T = new ot();
    let A = null;
    const b = new ti();
    b.layers.enable(1), (b.viewport = new Qt());
    const P = new ti();
    P.layers.enable(2), (P.viewport = new Qt());
    const G = [b, P],
      w = new Cj();
    w.layers.enable(1), w.layers.enable(2);
    let R = null,
      ie = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (V) {
        let Q = g[V];
        return (
          Q === void 0 && ((Q = new sp()), (g[V] = Q)), Q.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (V) {
        let Q = g[V];
        return Q === void 0 && ((Q = new sp()), (g[V] = Q)), Q.getGripSpace();
      }),
      (this.getHand = function (V) {
        let Q = g[V];
        return Q === void 0 && ((Q = new sp()), (g[V] = Q)), Q.getHandSpace();
      });
    function J(V) {
      const Q = S.indexOf(V.inputSource);
      if (Q === -1) return;
      const he = g[Q];
      he !== void 0 &&
        (he.update(V.inputSource, V.frame, c || a),
        he.dispatchEvent({
          type: V.type,
          data: V.inputSource,
        }));
    }
    function D() {
      r.removeEventListener("select", J),
        r.removeEventListener("selectstart", J),
        r.removeEventListener("selectend", J),
        r.removeEventListener("squeeze", J),
        r.removeEventListener("squeezestart", J),
        r.removeEventListener("squeezeend", J),
        r.removeEventListener("end", D),
        r.removeEventListener("inputsourceschange", Y);
      for (let V = 0; V < g.length; V++) {
        const Q = S[V];
        Q !== null && ((S[V] = null), g[V].disconnect(Q));
      }
      (R = null),
        (ie = null),
        x.reset(),
        e.setRenderTarget(f),
        (p = null),
        (h = null),
        (d = null),
        (r = null),
        (y = null),
        ke.stop(),
        (i.isPresenting = !1),
        e.setPixelRatio(A),
        e.setSize(T.width, T.height, !1),
        i.dispatchEvent({
          type: "sessionend",
        });
    }
    (this.setFramebufferScaleFactor = function (V) {
      (s = V),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (V) {
        (o = V),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (V) {
        c = V;
      }),
      (this.getBaseLayer = function () {
        return h !== null ? h : p;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (V) {
        if (((r = V), r !== null)) {
          if (
            ((f = e.getRenderTarget()),
            r.addEventListener("select", J),
            r.addEventListener("selectstart", J),
            r.addEventListener("selectend", J),
            r.addEventListener("squeeze", J),
            r.addEventListener("squeezestart", J),
            r.addEventListener("squeezeend", J),
            r.addEventListener("end", D),
            r.addEventListener("inputsourceschange", Y),
            m.xrCompatible !== !0 && (await n.makeXRCompatible()),
            (A = e.getPixelRatio()),
            e.getSize(T),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const Q = {
              antialias: r.renderState.layers === void 0 ? m.antialias : !0,
              alpha: !0,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: s,
            };
            (p = new XRWebGLLayer(r, n, Q)),
              r.updateRenderState({
                baseLayer: p,
              }),
              e.setPixelRatio(1),
              e.setSize(p.framebufferWidth, p.framebufferHeight, !1),
              (y = new ta(p.framebufferWidth, p.framebufferHeight, {
                format: _i,
                type: Jr,
                colorSpace: e.outputColorSpace,
                stencilBuffer: m.stencil,
              }));
          } else {
            let Q = null,
              he = null,
              Re = null;
            m.depth &&
              ((Re = m.stencil ? n.DEPTH24_STENCIL8 : n.DEPTH_COMPONENT24),
              (Q = m.stencil ? Eo : Gs),
              (he = m.stencil ? Hs : zr));
            const Ee = {
              colorFormat: n.RGBA8,
              depthFormat: Re,
              scaleFactor: s,
            };
            (d = new XRWebGLBinding(r, n)),
              (h = d.createProjectionLayer(Ee)),
              r.updateRenderState({
                layers: [h],
              }),
              e.setPixelRatio(1),
              e.setSize(h.textureWidth, h.textureHeight, !1),
              (y = new ta(h.textureWidth, h.textureHeight, {
                format: _i,
                type: Jr,
                depthTexture: new LM(
                  h.textureWidth,
                  h.textureHeight,
                  he,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Q
                ),
                stencilBuffer: m.stencil,
                colorSpace: e.outputColorSpace,
                samples: m.antialias ? 4 : 0,
              }));
            const _e = e.properties.get(y);
            _e.__ignoreDepthValues = h.ignoreDepthValues;
          }
          (y.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await r.requestReferenceSpace(o)),
            ke.setContext(r),
            ke.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({
              type: "sessionstart",
            });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (r !== null) return r.environmentBlendMode;
      });
    function Y(V) {
      for (let Q = 0; Q < V.removed.length; Q++) {
        const he = V.removed[Q],
          Re = S.indexOf(he);
        Re >= 0 && ((S[Re] = null), g[Re].disconnect(he));
      }
      for (let Q = 0; Q < V.added.length; Q++) {
        const he = V.added[Q];
        let Re = S.indexOf(he);
        if (Re === -1) {
          for (let _e = 0; _e < g.length; _e++)
            if (_e >= S.length) {
              S.push(he), (Re = _e);
              break;
            } else if (S[_e] === null) {
              (S[_e] = he), (Re = _e);
              break;
            }
          if (Re === -1) break;
        }
        const Ee = g[Re];
        Ee && Ee.connect(he);
      }
    }
    const q = new z(),
      W = new z();
    function L(V, Q, he) {
      q.setFromMatrixPosition(Q.matrixWorld),
        W.setFromMatrixPosition(he.matrixWorld);
      const Re = q.distanceTo(W),
        Ee = Q.projectionMatrix.elements,
        _e = he.projectionMatrix.elements,
        lt = Ee[14] / (Ee[10] - 1),
        Ue = Ee[14] / (Ee[10] + 1),
        I = (Ee[9] + 1) / Ee[5],
        Zt = (Ee[9] - 1) / Ee[5],
        be = (Ee[8] - 1) / Ee[0],
        Ze = (_e[8] + 1) / _e[0],
        Ne = lt * be,
        nt = lt * Ze,
        qe = Re / (-be + Ze),
        Ke = qe * -be;
      Q.matrixWorld.decompose(V.position, V.quaternion, V.scale),
        V.translateX(Ke),
        V.translateZ(qe),
        V.matrixWorld.compose(V.position, V.quaternion, V.scale),
        V.matrixWorldInverse.copy(V.matrixWorld).invert();
      const Pt = lt + qe,
        C = Ue + qe,
        E = Ne - Ke,
        $ = nt + (Re - Ke),
        Z = ((I * Ue) / C) * Pt,
        re = ((Zt * Ue) / C) * Pt;
      V.projectionMatrix.makePerspective(E, $, Z, re, Pt, C),
        V.projectionMatrixInverse.copy(V.projectionMatrix).invert();
    }
    function U(V, Q) {
      Q === null
        ? V.matrixWorld.copy(V.matrix)
        : V.matrixWorld.multiplyMatrices(Q.matrixWorld, V.matrix),
        V.matrixWorldInverse.copy(V.matrixWorld).invert();
    }
    this.updateCamera = function (V) {
      if (r === null) return;
      x.texture !== null && ((V.near = x.depthNear), (V.far = x.depthFar)),
        (w.near = P.near = b.near = V.near),
        (w.far = P.far = b.far = V.far),
        (R !== w.near || ie !== w.far) &&
          (r.updateRenderState({
            depthNear: w.near,
            depthFar: w.far,
          }),
          (R = w.near),
          (ie = w.far),
          (b.near = R),
          (b.far = ie),
          (P.near = R),
          (P.far = ie),
          b.updateProjectionMatrix(),
          P.updateProjectionMatrix(),
          V.updateProjectionMatrix());
      const Q = V.parent,
        he = w.cameras;
      U(w, Q);
      for (let Re = 0; Re < he.length; Re++) U(he[Re], Q);
      he.length === 2
        ? L(w, b, P)
        : w.projectionMatrix.copy(b.projectionMatrix),
        X(V, w, Q);
    };
    function X(V, Q, he) {
      he === null
        ? V.matrix.copy(Q.matrixWorld)
        : (V.matrix.copy(he.matrixWorld),
          V.matrix.invert(),
          V.matrix.multiply(Q.matrixWorld)),
        V.matrix.decompose(V.position, V.quaternion, V.scale),
        V.updateMatrixWorld(!0),
        V.projectionMatrix.copy(Q.projectionMatrix),
        V.projectionMatrixInverse.copy(Q.projectionMatrixInverse),
        V.isPerspectiveCamera &&
          ((V.fov = zm * 2 * Math.atan(1 / V.projectionMatrix.elements[5])),
          (V.zoom = 1));
    }
    (this.getCamera = function () {
      return w;
    }),
      (this.getFoveation = function () {
        if (!(h === null && p === null)) return l;
      }),
      (this.setFoveation = function (V) {
        (l = V),
          h !== null && (h.fixedFoveation = V),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = V);
      }),
      (this.hasDepthSensing = function () {
        return x.texture !== null;
      });
    let K = null;
    function oe(V, Q) {
      if (((u = Q.getViewerPose(c || a)), (v = Q), u !== null)) {
        const he = u.views;
        p !== null &&
          (e.setRenderTargetFramebuffer(y, p.framebuffer),
          e.setRenderTarget(y));
        let Re = !1;
        he.length !== w.cameras.length && ((w.cameras.length = 0), (Re = !0));
        for (let _e = 0; _e < he.length; _e++) {
          const lt = he[_e];
          let Ue = null;
          if (p !== null) Ue = p.getViewport(lt);
          else {
            const Zt = d.getViewSubImage(h, lt);
            (Ue = Zt.viewport),
              _e === 0 &&
                (e.setRenderTargetTextures(
                  y,
                  Zt.colorTexture,
                  h.ignoreDepthValues ? void 0 : Zt.depthStencilTexture
                ),
                e.setRenderTarget(y));
          }
          let I = G[_e];
          I === void 0 &&
            ((I = new ti()),
            I.layers.enable(_e),
            (I.viewport = new Qt()),
            (G[_e] = I)),
            I.matrix.fromArray(lt.transform.matrix),
            I.matrix.decompose(I.position, I.quaternion, I.scale),
            I.projectionMatrix.fromArray(lt.projectionMatrix),
            I.projectionMatrixInverse.copy(I.projectionMatrix).invert(),
            I.viewport.set(Ue.x, Ue.y, Ue.width, Ue.height),
            _e === 0 &&
              (w.matrix.copy(I.matrix),
              w.matrix.decompose(w.position, w.quaternion, w.scale)),
            Re === !0 && w.cameras.push(I);
        }
        const Ee = r.enabledFeatures;
        if (Ee && Ee.includes("depth-sensing")) {
          const _e = d.getDepthInformation(he[0]);
          _e && _e.isValid && _e.texture && x.init(e, _e, r.renderState);
        }
      }
      for (let he = 0; he < g.length; he++) {
        const Re = S[he],
          Ee = g[he];
        Re !== null && Ee !== void 0 && Ee.update(Re, Q, c || a);
      }
      x.render(e, w),
        K && K(V, Q),
        Q.detectedPlanes &&
          i.dispatchEvent({
            type: "planesdetected",
            data: Q,
          }),
        (v = null);
    }
    const ke = new PM();
    ke.setAnimationLoop(oe),
      (this.setAnimationLoop = function (V) {
        K = V;
      }),
      (this.dispose = function () {});
  }
}
const Es = new gr(),
  kj = new Ft();
function Ij(t, e) {
  function n(m, f) {
    m.matrixAutoUpdate === !0 && m.updateMatrix(), f.value.copy(m.matrix);
  }
  function i(m, f) {
    f.color.getRGB(m.fogColor.value, bM(t)),
      f.isFog
        ? ((m.fogNear.value = f.near), (m.fogFar.value = f.far))
        : f.isFogExp2 && (m.fogDensity.value = f.density);
  }
  function r(m, f, y, g, S) {
    f.isMeshBasicMaterial || f.isMeshLambertMaterial
      ? s(m, f)
      : f.isMeshToonMaterial
      ? (s(m, f), d(m, f))
      : f.isMeshPhongMaterial
      ? (s(m, f), u(m, f))
      : f.isMeshStandardMaterial
      ? (s(m, f), h(m, f), f.isMeshPhysicalMaterial && p(m, f, S))
      : f.isMeshMatcapMaterial
      ? (s(m, f), v(m, f))
      : f.isMeshDepthMaterial
      ? s(m, f)
      : f.isMeshDistanceMaterial
      ? (s(m, f), x(m, f))
      : f.isMeshNormalMaterial
      ? s(m, f)
      : f.isLineBasicMaterial
      ? (a(m, f), f.isLineDashedMaterial && o(m, f))
      : f.isPointsMaterial
      ? l(m, f, y, g)
      : f.isSpriteMaterial
      ? c(m, f)
      : f.isShadowMaterial
      ? (m.color.value.copy(f.color), (m.opacity.value = f.opacity))
      : f.isShaderMaterial && (f.uniformsNeedUpdate = !1);
  }
  function s(m, f) {
    (m.opacity.value = f.opacity),
      f.color && m.diffuse.value.copy(f.color),
      f.emissive &&
        m.emissive.value.copy(f.emissive).multiplyScalar(f.emissiveIntensity),
      f.map && ((m.map.value = f.map), n(f.map, m.mapTransform)),
      f.alphaMap &&
        ((m.alphaMap.value = f.alphaMap), n(f.alphaMap, m.alphaMapTransform)),
      f.bumpMap &&
        ((m.bumpMap.value = f.bumpMap),
        n(f.bumpMap, m.bumpMapTransform),
        (m.bumpScale.value = f.bumpScale),
        f.side === Dn && (m.bumpScale.value *= -1)),
      f.normalMap &&
        ((m.normalMap.value = f.normalMap),
        n(f.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(f.normalScale),
        f.side === Dn && m.normalScale.value.negate()),
      f.displacementMap &&
        ((m.displacementMap.value = f.displacementMap),
        n(f.displacementMap, m.displacementMapTransform),
        (m.displacementScale.value = f.displacementScale),
        (m.displacementBias.value = f.displacementBias)),
      f.emissiveMap &&
        ((m.emissiveMap.value = f.emissiveMap),
        n(f.emissiveMap, m.emissiveMapTransform)),
      f.specularMap &&
        ((m.specularMap.value = f.specularMap),
        n(f.specularMap, m.specularMapTransform)),
      f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
    const y = e.get(f),
      g = y.envMap,
      S = y.envMapRotation;
    if (
      (g &&
        ((m.envMap.value = g),
        Es.copy(S),
        (Es.x *= -1),
        (Es.y *= -1),
        (Es.z *= -1),
        g.isCubeTexture &&
          g.isRenderTargetTexture === !1 &&
          ((Es.y *= -1), (Es.z *= -1)),
        m.envMapRotation.value.setFromMatrix4(kj.makeRotationFromEuler(Es)),
        (m.flipEnvMap.value =
          g.isCubeTexture && g.isRenderTargetTexture === !1 ? -1 : 1),
        (m.reflectivity.value = f.reflectivity),
        (m.ior.value = f.ior),
        (m.refractionRatio.value = f.refractionRatio)),
      f.lightMap)
    ) {
      m.lightMap.value = f.lightMap;
      const T = t._useLegacyLights === !0 ? Math.PI : 1;
      (m.lightMapIntensity.value = f.lightMapIntensity * T),
        n(f.lightMap, m.lightMapTransform);
    }
    f.aoMap &&
      ((m.aoMap.value = f.aoMap),
      (m.aoMapIntensity.value = f.aoMapIntensity),
      n(f.aoMap, m.aoMapTransform));
  }
  function a(m, f) {
    m.diffuse.value.copy(f.color),
      (m.opacity.value = f.opacity),
      f.map && ((m.map.value = f.map), n(f.map, m.mapTransform));
  }
  function o(m, f) {
    (m.dashSize.value = f.dashSize),
      (m.totalSize.value = f.dashSize + f.gapSize),
      (m.scale.value = f.scale);
  }
  function l(m, f, y, g) {
    m.diffuse.value.copy(f.color),
      (m.opacity.value = f.opacity),
      (m.size.value = f.size * y),
      (m.scale.value = g * 0.5),
      f.map && ((m.map.value = f.map), n(f.map, m.uvTransform)),
      f.alphaMap &&
        ((m.alphaMap.value = f.alphaMap), n(f.alphaMap, m.alphaMapTransform)),
      f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
  }
  function c(m, f) {
    m.diffuse.value.copy(f.color),
      (m.opacity.value = f.opacity),
      (m.rotation.value = f.rotation),
      f.map && ((m.map.value = f.map), n(f.map, m.mapTransform)),
      f.alphaMap &&
        ((m.alphaMap.value = f.alphaMap), n(f.alphaMap, m.alphaMapTransform)),
      f.alphaTest > 0 && (m.alphaTest.value = f.alphaTest);
  }
  function u(m, f) {
    m.specular.value.copy(f.specular),
      (m.shininess.value = Math.max(f.shininess, 1e-4));
  }
  function d(m, f) {
    f.gradientMap && (m.gradientMap.value = f.gradientMap);
  }
  function h(m, f) {
    (m.metalness.value = f.metalness),
      f.metalnessMap &&
        ((m.metalnessMap.value = f.metalnessMap),
        n(f.metalnessMap, m.metalnessMapTransform)),
      (m.roughness.value = f.roughness),
      f.roughnessMap &&
        ((m.roughnessMap.value = f.roughnessMap),
        n(f.roughnessMap, m.roughnessMapTransform)),
      e.get(f).envMap && (m.envMapIntensity.value = f.envMapIntensity);
  }
  function p(m, f, y) {
    (m.ior.value = f.ior),
      f.sheen > 0 &&
        (m.sheenColor.value.copy(f.sheenColor).multiplyScalar(f.sheen),
        (m.sheenRoughness.value = f.sheenRoughness),
        f.sheenColorMap &&
          ((m.sheenColorMap.value = f.sheenColorMap),
          n(f.sheenColorMap, m.sheenColorMapTransform)),
        f.sheenRoughnessMap &&
          ((m.sheenRoughnessMap.value = f.sheenRoughnessMap),
          n(f.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
      f.clearcoat > 0 &&
        ((m.clearcoat.value = f.clearcoat),
        (m.clearcoatRoughness.value = f.clearcoatRoughness),
        f.clearcoatMap &&
          ((m.clearcoatMap.value = f.clearcoatMap),
          n(f.clearcoatMap, m.clearcoatMapTransform)),
        f.clearcoatRoughnessMap &&
          ((m.clearcoatRoughnessMap.value = f.clearcoatRoughnessMap),
          n(f.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        f.clearcoatNormalMap &&
          ((m.clearcoatNormalMap.value = f.clearcoatNormalMap),
          n(f.clearcoatNormalMap, m.clearcoatNormalMapTransform),
          m.clearcoatNormalScale.value.copy(f.clearcoatNormalScale),
          f.side === Dn && m.clearcoatNormalScale.value.negate())),
      f.iridescence > 0 &&
        ((m.iridescence.value = f.iridescence),
        (m.iridescenceIOR.value = f.iridescenceIOR),
        (m.iridescenceThicknessMinimum.value = f.iridescenceThicknessRange[0]),
        (m.iridescenceThicknessMaximum.value = f.iridescenceThicknessRange[1]),
        f.iridescenceMap &&
          ((m.iridescenceMap.value = f.iridescenceMap),
          n(f.iridescenceMap, m.iridescenceMapTransform)),
        f.iridescenceThicknessMap &&
          ((m.iridescenceThicknessMap.value = f.iridescenceThicknessMap),
          n(f.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
      f.transmission > 0 &&
        ((m.transmission.value = f.transmission),
        (m.transmissionSamplerMap.value = y.texture),
        m.transmissionSamplerSize.value.set(y.width, y.height),
        f.transmissionMap &&
          ((m.transmissionMap.value = f.transmissionMap),
          n(f.transmissionMap, m.transmissionMapTransform)),
        (m.thickness.value = f.thickness),
        f.thicknessMap &&
          ((m.thicknessMap.value = f.thicknessMap),
          n(f.thicknessMap, m.thicknessMapTransform)),
        (m.attenuationDistance.value = f.attenuationDistance),
        m.attenuationColor.value.copy(f.attenuationColor)),
      f.anisotropy > 0 &&
        (m.anisotropyVector.value.set(
          f.anisotropy * Math.cos(f.anisotropyRotation),
          f.anisotropy * Math.sin(f.anisotropyRotation)
        ),
        f.anisotropyMap &&
          ((m.anisotropyMap.value = f.anisotropyMap),
          n(f.anisotropyMap, m.anisotropyMapTransform))),
      (m.specularIntensity.value = f.specularIntensity),
      m.specularColor.value.copy(f.specularColor),
      f.specularColorMap &&
        ((m.specularColorMap.value = f.specularColorMap),
        n(f.specularColorMap, m.specularColorMapTransform)),
      f.specularIntensityMap &&
        ((m.specularIntensityMap.value = f.specularIntensityMap),
        n(f.specularIntensityMap, m.specularIntensityMapTransform));
  }
  function v(m, f) {
    f.matcap && (m.matcap.value = f.matcap);
  }
  function x(m, f) {
    const y = e.get(f).light;
    m.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (m.nearDistance.value = y.shadow.camera.near),
      (m.farDistance.value = y.shadow.camera.far);
  }
  return {
    refreshFogUniforms: i,
    refreshMaterialUniforms: r,
  };
}
function Uj(t, e, n, i) {
  let r = {},
    s = {},
    a = [];
  const o = n.isWebGL2 ? t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(y, g) {
    const S = g.program;
    i.uniformBlockBinding(y, S);
  }
  function c(y, g) {
    let S = r[y.id];
    S === void 0 &&
      (v(y), (S = u(y)), (r[y.id] = S), y.addEventListener("dispose", m));
    const T = g.program;
    i.updateUBOMapping(y, T);
    const A = e.render.frame;
    s[y.id] !== A && (h(y), (s[y.id] = A));
  }
  function u(y) {
    const g = d();
    y.__bindingPointIndex = g;
    const S = t.createBuffer(),
      T = y.__size,
      A = y.usage;
    return (
      t.bindBuffer(t.UNIFORM_BUFFER, S),
      t.bufferData(t.UNIFORM_BUFFER, T, A),
      t.bindBuffer(t.UNIFORM_BUFFER, null),
      t.bindBufferBase(t.UNIFORM_BUFFER, g, S),
      S
    );
  }
  function d() {
    for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function h(y) {
    const g = r[y.id],
      S = y.uniforms,
      T = y.__cache;
    t.bindBuffer(t.UNIFORM_BUFFER, g);
    for (let A = 0, b = S.length; A < b; A++) {
      const P = Array.isArray(S[A]) ? S[A] : [S[A]];
      for (let G = 0, w = P.length; G < w; G++) {
        const R = P[G];
        if (p(R, A, G, T) === !0) {
          const ie = R.__offset,
            J = Array.isArray(R.value) ? R.value : [R.value];
          let D = 0;
          for (let Y = 0; Y < J.length; Y++) {
            const q = J[Y],
              W = x(q);
            typeof q == "number" || typeof q == "boolean"
              ? ((R.__data[0] = q),
                t.bufferSubData(t.UNIFORM_BUFFER, ie + D, R.__data))
              : q.isMatrix3
              ? ((R.__data[0] = q.elements[0]),
                (R.__data[1] = q.elements[1]),
                (R.__data[2] = q.elements[2]),
                (R.__data[3] = 0),
                (R.__data[4] = q.elements[3]),
                (R.__data[5] = q.elements[4]),
                (R.__data[6] = q.elements[5]),
                (R.__data[7] = 0),
                (R.__data[8] = q.elements[6]),
                (R.__data[9] = q.elements[7]),
                (R.__data[10] = q.elements[8]),
                (R.__data[11] = 0))
              : (q.toArray(R.__data, D),
                (D += W.storage / Float32Array.BYTES_PER_ELEMENT));
          }
          t.bufferSubData(t.UNIFORM_BUFFER, ie, R.__data);
        }
      }
    }
    t.bindBuffer(t.UNIFORM_BUFFER, null);
  }
  function p(y, g, S, T) {
    const A = y.value,
      b = g + "_" + S;
    if (T[b] === void 0)
      return (
        typeof A == "number" || typeof A == "boolean"
          ? (T[b] = A)
          : (T[b] = A.clone()),
        !0
      );
    {
      const P = T[b];
      if (typeof A == "number" || typeof A == "boolean") {
        if (P !== A) return (T[b] = A), !0;
      } else if (P.equals(A) === !1) return P.copy(A), !0;
    }
    return !1;
  }
  function v(y) {
    const g = y.uniforms;
    let S = 0;
    const T = 16;
    for (let b = 0, P = g.length; b < P; b++) {
      const G = Array.isArray(g[b]) ? g[b] : [g[b]];
      for (let w = 0, R = G.length; w < R; w++) {
        const ie = G[w],
          J = Array.isArray(ie.value) ? ie.value : [ie.value];
        for (let D = 0, Y = J.length; D < Y; D++) {
          const q = J[D],
            W = x(q),
            L = S % T;
          L !== 0 && T - L < W.boundary && (S += T - L),
            (ie.__data = new Float32Array(
              W.storage / Float32Array.BYTES_PER_ELEMENT
            )),
            (ie.__offset = S),
            (S += W.storage);
        }
      }
    }
    const A = S % T;
    return A > 0 && (S += T - A), (y.__size = S), (y.__cache = {}), this;
  }
  function x(y) {
    const g = {
      boundary: 0,
      storage: 0,
    };
    return (
      typeof y == "number" || typeof y == "boolean"
        ? ((g.boundary = 4), (g.storage = 4))
        : y.isVector2
        ? ((g.boundary = 8), (g.storage = 8))
        : y.isVector3 || y.isColor
        ? ((g.boundary = 16), (g.storage = 12))
        : y.isVector4
        ? ((g.boundary = 16), (g.storage = 16))
        : y.isMatrix3
        ? ((g.boundary = 48), (g.storage = 48))
        : y.isMatrix4
        ? ((g.boundary = 64), (g.storage = 64))
        : y.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            y
          ),
      g
    );
  }
  function m(y) {
    const g = y.target;
    g.removeEventListener("dispose", m);
    const S = a.indexOf(g.__bindingPointIndex);
    a.splice(S, 1), t.deleteBuffer(r[g.id]), delete r[g.id], delete s[g.id];
  }
  function f() {
    for (const y in r) t.deleteBuffer(r[y]);
    (a = []), (r = {}), (s = {});
  }
  return {
    bind: l,
    update: c,
    dispose: f,
  };
}
class OM {
  constructor(e = {}) {
    const {
      canvas: n = TO(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let h;
    i !== null ? (h = i.getContextAttributes().alpha) : (h = a);
    const p = new Uint32Array(4),
      v = new Int32Array(4);
    let x = null,
      m = null;
    const f = [],
      y = [];
    (this.domElement = n),
      (this.debug = {
        checkShaderErrors: !0,
        onShaderError: null,
      }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this._outputColorSpace = Li),
      (this._useLegacyLights = !1),
      (this.toneMapping = Kr),
      (this.toneMappingExposure = 1);
    const g = this;
    let S = !1,
      T = 0,
      A = 0,
      b = null,
      P = -1,
      G = null;
    const w = new Qt(),
      R = new Qt();
    let ie = null;
    const J = new ct(0);
    let D = 0,
      Y = n.width,
      q = n.height,
      W = 1,
      L = null,
      U = null;
    const X = new Qt(0, 0, Y, q),
      K = new Qt(0, 0, Y, q);
    let oe = !1;
    const ke = new RM();
    let V = !1,
      Q = !1,
      he = null;
    const Re = new Ft(),
      Ee = new ot(),
      _e = new z(),
      lt = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function Ue() {
      return b === null ? W : 1;
    }
    let I = i;
    function Zt(M, k) {
      for (let j = 0; j < M.length; j++) {
        const H = M[j],
          F = n.getContext(H, k);
        if (F !== null) return F;
      }
      return null;
    }
    try {
      const M = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in n &&
          n.setAttribute("data-engine", `three.js r${Cv}`),
        n.addEventListener("webglcontextlost", yt, !1),
        n.addEventListener("webglcontextrestored", N, !1),
        n.addEventListener("webglcontextcreationerror", de, !1),
        I === null)
      ) {
        const k = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (g.isWebGL1Renderer === !0 && k.shift(), (I = Zt(k, M)), I === null)
        )
          throw Zt(k)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      typeof WebGLRenderingContext < "u" &&
        I instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        I.getShaderPrecisionFormat === void 0 &&
          (I.getShaderPrecisionFormat = function () {
            return {
              rangeMin: 1,
              rangeMax: 1,
              precision: 1,
            };
          });
    } catch (M) {
      throw (console.error("THREE.WebGLRenderer: " + M.message), M);
    }
    let be,
      Ze,
      Ne,
      nt,
      qe,
      Ke,
      Pt,
      C,
      E,
      $,
      Z,
      re,
      ee,
      Ve,
      De,
      ce,
      fe,
      He,
      se,
      kt,
      Je,
      Te,
      xe,
      Se;
    function it() {
      (be = new VB(I)),
        (Ze = new IB(I, be, e)),
        be.init(Ze),
        (Te = new Aj(I, be, Ze)),
        (Ne = new Mj(I, be, Ze)),
        (nt = new WB(I)),
        (qe = new dj()),
        (Ke = new bj(I, be, Ne, qe, Ze, Te, nt)),
        (Pt = new OB(g)),
        (C = new jB(g)),
        (E = new ZO(I, Ze)),
        (xe = new DB(I, be, E, Ze)),
        ($ = new HB(I, E, nt, xe)),
        (Z = new YB(I, $, E, nt)),
        (se = new qB(I, Ze, Ke)),
        (ce = new UB(qe)),
        (re = new uj(g, Pt, C, be, Ze, xe, ce)),
        (ee = new Ij(g, qe)),
        (Ve = new fj()),
        (De = new yj(be, Ze)),
        (He = new NB(g, Pt, C, Ne, Z, h, l)),
        (fe = new Tj(g, Z, Ze)),
        (Se = new Uj(I, nt, Ze, Ne)),
        (kt = new kB(I, be, nt, Ze)),
        (Je = new GB(I, be, nt, Ze)),
        (nt.programs = re.programs),
        (g.capabilities = Ze),
        (g.extensions = be),
        (g.properties = qe),
        (g.renderLists = Ve),
        (g.shadowMap = fe),
        (g.state = Ne),
        (g.info = nt);
    }
    it();
    const Be = new Dj(g, I);
    (this.xr = Be),
      (this.getContext = function () {
        return I;
      }),
      (this.getContextAttributes = function () {
        return I.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const M = be.get("WEBGL_lose_context");
        M && M.loseContext();
      }),
      (this.forceContextRestore = function () {
        const M = be.get("WEBGL_lose_context");
        M && M.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return W;
      }),
      (this.setPixelRatio = function (M) {
        M !== void 0 && ((W = M), this.setSize(Y, q, !1));
      }),
      (this.getSize = function (M) {
        return M.set(Y, q);
      }),
      (this.setSize = function (M, k, j = !0) {
        if (Be.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (Y = M),
          (q = k),
          (n.width = Math.floor(M * W)),
          (n.height = Math.floor(k * W)),
          j === !0 && ((n.style.width = M + "px"), (n.style.height = k + "px")),
          this.setViewport(0, 0, M, k);
      }),
      (this.getDrawingBufferSize = function (M) {
        return M.set(Y * W, q * W).floor();
      }),
      (this.setDrawingBufferSize = function (M, k, j) {
        (Y = M),
          (q = k),
          (W = j),
          (n.width = Math.floor(M * j)),
          (n.height = Math.floor(k * j)),
          this.setViewport(0, 0, M, k);
      }),
      (this.getCurrentViewport = function (M) {
        return M.copy(w);
      }),
      (this.getViewport = function (M) {
        return M.copy(X);
      }),
      (this.setViewport = function (M, k, j, H) {
        M.isVector4 ? X.set(M.x, M.y, M.z, M.w) : X.set(M, k, j, H),
          Ne.viewport(w.copy(X).multiplyScalar(W).round());
      }),
      (this.getScissor = function (M) {
        return M.copy(K);
      }),
      (this.setScissor = function (M, k, j, H) {
        M.isVector4 ? K.set(M.x, M.y, M.z, M.w) : K.set(M, k, j, H),
          Ne.scissor(R.copy(K).multiplyScalar(W).round());
      }),
      (this.getScissorTest = function () {
        return oe;
      }),
      (this.setScissorTest = function (M) {
        Ne.setScissorTest((oe = M));
      }),
      (this.setOpaqueSort = function (M) {
        L = M;
      }),
      (this.setTransparentSort = function (M) {
        U = M;
      }),
      (this.getClearColor = function (M) {
        return M.copy(He.getClearColor());
      }),
      (this.setClearColor = function () {
        He.setClearColor.apply(He, arguments);
      }),
      (this.getClearAlpha = function () {
        return He.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        He.setClearAlpha.apply(He, arguments);
      }),
      (this.clear = function (M = !0, k = !0, j = !0) {
        let H = 0;
        if (M) {
          let F = !1;
          if (b !== null) {
            const ge = b.texture.format;
            F = ge === fM || ge === hM || ge === dM;
          }
          if (F) {
            const ge = b.texture.type,
              we =
                ge === Jr ||
                ge === zr ||
                ge === Rv ||
                ge === Hs ||
                ge === cM ||
                ge === uM,
              Pe = He.getClearColor(),
              Ie = He.getClearAlpha(),
              Ye = Pe.r,
              Oe = Pe.g,
              ze = Pe.b;
            we
              ? ((p[0] = Ye),
                (p[1] = Oe),
                (p[2] = ze),
                (p[3] = Ie),
                I.clearBufferuiv(I.COLOR, 0, p))
              : ((v[0] = Ye),
                (v[1] = Oe),
                (v[2] = ze),
                (v[3] = Ie),
                I.clearBufferiv(I.COLOR, 0, v));
          } else H |= I.COLOR_BUFFER_BIT;
        }
        k && (H |= I.DEPTH_BUFFER_BIT),
          j &&
            ((H |= I.STENCIL_BUFFER_BIT),
            this.state.buffers.stencil.setMask(4294967295)),
          I.clear(H);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", yt, !1),
          n.removeEventListener("webglcontextrestored", N, !1),
          n.removeEventListener("webglcontextcreationerror", de, !1),
          Ve.dispose(),
          De.dispose(),
          qe.dispose(),
          Pt.dispose(),
          C.dispose(),
          Z.dispose(),
          xe.dispose(),
          Se.dispose(),
          re.dispose(),
          Be.dispose(),
          Be.removeEventListener("sessionstart", qn),
          Be.removeEventListener("sessionend", ft),
          he && (he.dispose(), (he = null)),
          pn.stop();
      });
    function yt(M) {
      M.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (S = !0);
    }
    function N() {
      console.log("THREE.WebGLRenderer: Context Restored."), (S = !1);
      const M = nt.autoReset,
        k = fe.enabled,
        j = fe.autoUpdate,
        H = fe.needsUpdate,
        F = fe.type;
      it(),
        (nt.autoReset = M),
        (fe.enabled = k),
        (fe.autoUpdate = j),
        (fe.needsUpdate = H),
        (fe.type = F);
    }
    function de(M) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        M.statusMessage
      );
    }
    function B(M) {
      const k = M.target;
      k.removeEventListener("dispose", B), ae(k);
    }
    function ae(M) {
      pe(M), qe.remove(M);
    }
    function pe(M) {
      const k = qe.get(M).programs;
      k !== void 0 &&
        (k.forEach(function (j) {
          re.releaseProgram(j);
        }),
        M.isShaderMaterial && re.releaseShaderCache(M));
    }
    this.renderBufferDirect = function (M, k, j, H, F, ge) {
      k === null && (k = lt);
      const we = F.isMesh && F.matrixWorld.determinant() < 0,
        Pe = zM(M, k, j, H, F);
      Ne.setMaterial(H, we);
      let Ie = j.index,
        Ye = 1;
      if (H.wireframe === !0) {
        if (((Ie = $.getWireframeAttribute(j)), Ie === void 0)) return;
        Ye = 2;
      }
      const Oe = j.drawRange,
        ze = j.attributes.position;
      let Lt = Oe.start * Ye,
        Un = (Oe.start + Oe.count) * Ye;
      ge !== null &&
        ((Lt = Math.max(Lt, ge.start * Ye)),
        (Un = Math.min(Un, (ge.start + ge.count) * Ye))),
        Ie !== null
          ? ((Lt = Math.max(Lt, 0)), (Un = Math.min(Un, Ie.count)))
          : ze != null &&
            ((Lt = Math.max(Lt, 0)), (Un = Math.min(Un, ze.count)));
      const Gt = Un - Lt;
      if (Gt < 0 || Gt === 1 / 0) return;
      xe.setup(F, H, Pe, j, Ie);
      let Gi,
        wt = kt;
      if (
        (Ie !== null && ((Gi = E.get(Ie)), (wt = Je), wt.setIndex(Gi)),
        F.isMesh)
      )
        H.wireframe === !0
          ? (Ne.setLineWidth(H.wireframeLinewidth * Ue()), wt.setMode(I.LINES))
          : wt.setMode(I.TRIANGLES);
      else if (F.isLine) {
        let Ge = H.linewidth;
        Ge === void 0 && (Ge = 1),
          Ne.setLineWidth(Ge * Ue()),
          F.isLineSegments
            ? wt.setMode(I.LINES)
            : F.isLineLoop
            ? wt.setMode(I.LINE_LOOP)
            : wt.setMode(I.LINE_STRIP);
      } else
        F.isPoints
          ? wt.setMode(I.POINTS)
          : F.isSprite && wt.setMode(I.TRIANGLES);
      if (F.isBatchedMesh)
        wt.renderMultiDraw(
          F._multiDrawStarts,
          F._multiDrawCounts,
          F._multiDrawCount
        );
      else if (F.isInstancedMesh) wt.renderInstances(Lt, Gt, F.count);
      else if (j.isInstancedBufferGeometry) {
        const Ge = j._maxInstanceCount !== void 0 ? j._maxInstanceCount : 1 / 0,
          Ah = Math.min(j.instanceCount, Ge);
        wt.renderInstances(Lt, Gt, Ah);
      } else wt.render(Lt, Gt);
    };
    function et(M, k, j) {
      M.transparent === !0 && M.side === nr && M.forceSinglePass === !1
        ? ((M.side = Dn),
          (M.needsUpdate = !0),
          Dc(M, k, j),
          (M.side = as),
          (M.needsUpdate = !0),
          Dc(M, k, j),
          (M.side = nr))
        : Dc(M, k, j);
    }
    (this.compile = function (M, k, j = null) {
      j === null && (j = M),
        (m = De.get(j)),
        m.init(),
        y.push(m),
        j.traverseVisible(function (F) {
          F.isLight &&
            F.layers.test(k.layers) &&
            (m.pushLight(F), F.castShadow && m.pushShadow(F));
        }),
        M !== j &&
          M.traverseVisible(function (F) {
            F.isLight &&
              F.layers.test(k.layers) &&
              (m.pushLight(F), F.castShadow && m.pushShadow(F));
          }),
        m.setupLights(g._useLegacyLights);
      const H = new Set();
      return (
        M.traverse(function (F) {
          const ge = F.material;
          if (ge)
            if (Array.isArray(ge))
              for (let we = 0; we < ge.length; we++) {
                const Pe = ge[we];
                et(Pe, j, F), H.add(Pe);
              }
            else et(ge, j, F), H.add(ge);
        }),
        y.pop(),
        (m = null),
        H
      );
    }),
      (this.compileAsync = function (M, k, j = null) {
        const H = this.compile(M, k, j);
        return new Promise((F) => {
          function ge() {
            if (
              (H.forEach(function (we) {
                qe.get(we).currentProgram.isReady() && H.delete(we);
              }),
              H.size === 0)
            ) {
              F(M);
              return;
            }
            setTimeout(ge, 10);
          }
          be.get("KHR_parallel_shader_compile") !== null
            ? ge()
            : setTimeout(ge, 10);
        });
      });
    let ht = null;
    function Kt(M) {
      ht && ht(M);
    }
    function qn() {
      pn.stop();
    }
    function ft() {
      pn.start();
    }
    const pn = new PM();
    pn.setAnimationLoop(Kt),
      typeof self < "u" && pn.setContext(self),
      (this.setAnimationLoop = function (M) {
        (ht = M), Be.setAnimationLoop(M), M === null ? pn.stop() : pn.start();
      }),
      Be.addEventListener("sessionstart", qn),
      Be.addEventListener("sessionend", ft),
      (this.render = function (M, k) {
        if (k !== void 0 && k.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (S === !0) return;
        M.matrixWorldAutoUpdate === !0 && M.updateMatrixWorld(),
          k.parent === null &&
            k.matrixWorldAutoUpdate === !0 &&
            k.updateMatrixWorld(),
          Be.enabled === !0 &&
            Be.isPresenting === !0 &&
            (Be.cameraAutoUpdate === !0 && Be.updateCamera(k),
            (k = Be.getCamera())),
          M.isScene === !0 && M.onBeforeRender(g, M, k, b),
          (m = De.get(M, y.length)),
          m.init(),
          y.push(m),
          Re.multiplyMatrices(k.projectionMatrix, k.matrixWorldInverse),
          ke.setFromProjectionMatrix(Re),
          (Q = this.localClippingEnabled),
          (V = ce.init(this.clippingPlanes, Q)),
          (x = Ve.get(M, f.length)),
          x.init(),
          f.push(x),
          Ai(M, k, 0, g.sortObjects),
          x.finish(),
          g.sortObjects === !0 && x.sort(L, U),
          this.info.render.frame++,
          V === !0 && ce.beginShadows();
        const j = m.state.shadowsArray;
        if (
          (fe.render(j, M, k),
          V === !0 && ce.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          (Be.enabled === !1 ||
            Be.isPresenting === !1 ||
            Be.hasDepthSensing() === !1) &&
            He.render(x, M),
          m.setupLights(g._useLegacyLights),
          k.isArrayCamera)
        ) {
          const H = k.cameras;
          for (let F = 0, ge = H.length; F < ge; F++) {
            const we = H[F];
            Nv(x, M, we, we.viewport);
          }
        } else Nv(x, M, k);
        b !== null &&
          (Ke.updateMultisampleRenderTarget(b), Ke.updateRenderTargetMipmap(b)),
          M.isScene === !0 && M.onAfterRender(g, M, k),
          xe.resetDefaultState(),
          (P = -1),
          (G = null),
          y.pop(),
          y.length > 0 ? (m = y[y.length - 1]) : (m = null),
          f.pop(),
          f.length > 0 ? (x = f[f.length - 1]) : (x = null);
      });
    function Ai(M, k, j, H) {
      if (M.visible === !1) return;
      if (M.layers.test(k.layers)) {
        if (M.isGroup) j = M.renderOrder;
        else if (M.isLOD) M.autoUpdate === !0 && M.update(k);
        else if (M.isLight) m.pushLight(M), M.castShadow && m.pushShadow(M);
        else if (M.isSprite) {
          if (!M.frustumCulled || ke.intersectsSprite(M)) {
            H && _e.setFromMatrixPosition(M.matrixWorld).applyMatrix4(Re);
            const we = Z.update(M),
              Pe = M.material;
            Pe.visible && x.push(M, we, Pe, j, _e.z, null);
          }
        } else if (
          (M.isMesh || M.isLine || M.isPoints) &&
          (!M.frustumCulled || ke.intersectsObject(M))
        ) {
          const we = Z.update(M),
            Pe = M.material;
          if (
            (H &&
              (M.boundingSphere !== void 0
                ? (M.boundingSphere === null && M.computeBoundingSphere(),
                  _e.copy(M.boundingSphere.center))
                : (we.boundingSphere === null && we.computeBoundingSphere(),
                  _e.copy(we.boundingSphere.center)),
              _e.applyMatrix4(M.matrixWorld).applyMatrix4(Re)),
            Array.isArray(Pe))
          ) {
            const Ie = we.groups;
            for (let Ye = 0, Oe = Ie.length; Ye < Oe; Ye++) {
              const ze = Ie[Ye],
                Lt = Pe[ze.materialIndex];
              Lt && Lt.visible && x.push(M, we, Lt, j, _e.z, ze);
            }
          } else Pe.visible && x.push(M, we, Pe, j, _e.z, null);
        }
      }
      const ge = M.children;
      for (let we = 0, Pe = ge.length; we < Pe; we++) Ai(ge[we], k, j, H);
    }
    function Nv(M, k, j, H) {
      const F = M.opaque,
        ge = M.transmissive,
        we = M.transparent;
      m.setupLightsView(j),
        V === !0 && ce.setGlobalState(g.clippingPlanes, j),
        ge.length > 0 && BM(F, ge, k, j),
        H && Ne.viewport(w.copy(H)),
        F.length > 0 && Nc(F, k, j),
        ge.length > 0 && Nc(ge, k, j),
        we.length > 0 && Nc(we, k, j),
        Ne.buffers.depth.setTest(!0),
        Ne.buffers.depth.setMask(!0),
        Ne.buffers.color.setMask(!0),
        Ne.setPolygonOffset(!1);
    }
    function BM(M, k, j, H) {
      if ((j.isScene === !0 ? j.overrideMaterial : null) !== null) return;
      const ge = Ze.isWebGL2;
      he === null &&
        (he = new ta(1, 1, {
          generateMipmaps: !0,
          type: be.has("EXT_color_buffer_half_float") ? hc : Jr,
          minFilter: Fs,
          samples: ge ? 4 : 0,
        })),
        g.getDrawingBufferSize(Ee),
        ge ? he.setSize(Ee.x, Ee.y) : he.setSize(jm(Ee.x), jm(Ee.y));
      const we = g.getRenderTarget();
      g.setRenderTarget(he),
        g.getClearColor(J),
        (D = g.getClearAlpha()),
        D < 1 && g.setClearColor(16777215, 0.5),
        g.clear();
      const Pe = g.toneMapping;
      (g.toneMapping = Kr),
        Nc(M, j, H),
        Ke.updateMultisampleRenderTarget(he),
        Ke.updateRenderTargetMipmap(he);
      let Ie = !1;
      for (let Ye = 0, Oe = k.length; Ye < Oe; Ye++) {
        const ze = k[Ye],
          Lt = ze.object,
          Un = ze.geometry,
          Gt = ze.material,
          Gi = ze.group;
        if (Gt.side === nr && Lt.layers.test(H.layers)) {
          const wt = Gt.side;
          (Gt.side = Dn),
            (Gt.needsUpdate = !0),
            Dv(Lt, j, H, Un, Gt, Gi),
            (Gt.side = wt),
            (Gt.needsUpdate = !0),
            (Ie = !0);
        }
      }
      Ie === !0 &&
        (Ke.updateMultisampleRenderTarget(he), Ke.updateRenderTargetMipmap(he)),
        g.setRenderTarget(we),
        g.setClearColor(J, D),
        (g.toneMapping = Pe);
    }
    function Nc(M, k, j) {
      const H = k.isScene === !0 ? k.overrideMaterial : null;
      for (let F = 0, ge = M.length; F < ge; F++) {
        const we = M[F],
          Pe = we.object,
          Ie = we.geometry,
          Ye = H === null ? we.material : H,
          Oe = we.group;
        Pe.layers.test(j.layers) && Dv(Pe, k, j, Ie, Ye, Oe);
      }
    }
    function Dv(M, k, j, H, F, ge) {
      M.onBeforeRender(g, k, j, H, F, ge),
        M.modelViewMatrix.multiplyMatrices(j.matrixWorldInverse, M.matrixWorld),
        M.normalMatrix.getNormalMatrix(M.modelViewMatrix),
        F.onBeforeRender(g, k, j, H, M, ge),
        F.transparent === !0 && F.side === nr && F.forceSinglePass === !1
          ? ((F.side = Dn),
            (F.needsUpdate = !0),
            g.renderBufferDirect(j, k, H, F, M, ge),
            (F.side = as),
            (F.needsUpdate = !0),
            g.renderBufferDirect(j, k, H, F, M, ge),
            (F.side = nr))
          : g.renderBufferDirect(j, k, H, F, M, ge),
        M.onAfterRender(g, k, j, H, F, ge);
    }
    function Dc(M, k, j) {
      k.isScene !== !0 && (k = lt);
      const H = qe.get(M),
        F = m.state.lights,
        ge = m.state.shadowsArray,
        we = F.state.version,
        Pe = re.getParameters(M, F.state, ge, k, j),
        Ie = re.getProgramCacheKey(Pe);
      let Ye = H.programs;
      (H.environment = M.isMeshStandardMaterial ? k.environment : null),
        (H.fog = k.fog),
        (H.envMap = (M.isMeshStandardMaterial ? C : Pt).get(
          M.envMap || H.environment
        )),
        (H.envMapRotation =
          H.environment !== null && M.envMap === null
            ? k.environmentRotation
            : M.envMapRotation),
        Ye === void 0 &&
          (M.addEventListener("dispose", B),
          (Ye = new Map()),
          (H.programs = Ye));
      let Oe = Ye.get(Ie);
      if (Oe !== void 0) {
        if (H.currentProgram === Oe && H.lightsStateVersion === we)
          return Iv(M, Pe), Oe;
      } else
        (Pe.uniforms = re.getUniforms(M)),
          M.onBuild(j, Pe, g),
          M.onBeforeCompile(Pe, g),
          (Oe = re.acquireProgram(Pe, Ie)),
          Ye.set(Ie, Oe),
          (H.uniforms = Pe.uniforms);
      const ze = H.uniforms;
      return (
        ((!M.isShaderMaterial && !M.isRawShaderMaterial) ||
          M.clipping === !0) &&
          (ze.clippingPlanes = ce.uniform),
        Iv(M, Pe),
        (H.needsLights = VM(M)),
        (H.lightsStateVersion = we),
        H.needsLights &&
          ((ze.ambientLightColor.value = F.state.ambient),
          (ze.lightProbe.value = F.state.probe),
          (ze.directionalLights.value = F.state.directional),
          (ze.directionalLightShadows.value = F.state.directionalShadow),
          (ze.spotLights.value = F.state.spot),
          (ze.spotLightShadows.value = F.state.spotShadow),
          (ze.rectAreaLights.value = F.state.rectArea),
          (ze.ltc_1.value = F.state.rectAreaLTC1),
          (ze.ltc_2.value = F.state.rectAreaLTC2),
          (ze.pointLights.value = F.state.point),
          (ze.pointLightShadows.value = F.state.pointShadow),
          (ze.hemisphereLights.value = F.state.hemi),
          (ze.directionalShadowMap.value = F.state.directionalShadowMap),
          (ze.directionalShadowMatrix.value = F.state.directionalShadowMatrix),
          (ze.spotShadowMap.value = F.state.spotShadowMap),
          (ze.spotLightMatrix.value = F.state.spotLightMatrix),
          (ze.spotLightMap.value = F.state.spotLightMap),
          (ze.pointShadowMap.value = F.state.pointShadowMap),
          (ze.pointShadowMatrix.value = F.state.pointShadowMatrix)),
        (H.currentProgram = Oe),
        (H.uniformsList = null),
        Oe
      );
    }
    function kv(M) {
      if (M.uniformsList === null) {
        const k = M.currentProgram.getUniforms();
        M.uniformsList = qu.seqWithValue(k.seq, M.uniforms);
      }
      return M.uniformsList;
    }
    function Iv(M, k) {
      const j = qe.get(M);
      (j.outputColorSpace = k.outputColorSpace),
        (j.batching = k.batching),
        (j.instancing = k.instancing),
        (j.instancingColor = k.instancingColor),
        (j.instancingMorph = k.instancingMorph),
        (j.skinning = k.skinning),
        (j.morphTargets = k.morphTargets),
        (j.morphNormals = k.morphNormals),
        (j.morphColors = k.morphColors),
        (j.morphTargetsCount = k.morphTargetsCount),
        (j.numClippingPlanes = k.numClippingPlanes),
        (j.numIntersection = k.numClipIntersection),
        (j.vertexAlphas = k.vertexAlphas),
        (j.vertexTangents = k.vertexTangents),
        (j.toneMapping = k.toneMapping);
    }
    function zM(M, k, j, H, F) {
      k.isScene !== !0 && (k = lt), Ke.resetTextureUnits();
      const ge = k.fog,
        we = H.isMeshStandardMaterial ? k.environment : null,
        Pe =
          b === null
            ? g.outputColorSpace
            : b.isXRRenderTarget === !0
            ? b.texture.colorSpace
            : fs,
        Ie = (H.isMeshStandardMaterial ? C : Pt).get(H.envMap || we),
        Ye =
          H.vertexColors === !0 &&
          !!j.attributes.color &&
          j.attributes.color.itemSize === 4,
        Oe = !!j.attributes.tangent && (!!H.normalMap || H.anisotropy > 0),
        ze = !!j.morphAttributes.position,
        Lt = !!j.morphAttributes.normal,
        Un = !!j.morphAttributes.color;
      let Gt = Kr;
      H.toneMapped &&
        (b === null || b.isXRRenderTarget === !0) &&
        (Gt = g.toneMapping);
      const Gi =
          j.morphAttributes.position ||
          j.morphAttributes.normal ||
          j.morphAttributes.color,
        wt = Gi !== void 0 ? Gi.length : 0,
        Ge = qe.get(H),
        Ah = m.state.lights;
      if (V === !0 && (Q === !0 || M !== G)) {
        const Yn = M === G && H.id === P;
        ce.setState(H, M, Yn);
      }
      let xt = !1;
      H.version === Ge.__version
        ? ((Ge.needsLights && Ge.lightsStateVersion !== Ah.state.version) ||
            Ge.outputColorSpace !== Pe ||
            (F.isBatchedMesh && Ge.batching === !1) ||
            (!F.isBatchedMesh && Ge.batching === !0) ||
            (F.isInstancedMesh && Ge.instancing === !1) ||
            (!F.isInstancedMesh && Ge.instancing === !0) ||
            (F.isSkinnedMesh && Ge.skinning === !1) ||
            (!F.isSkinnedMesh && Ge.skinning === !0) ||
            (F.isInstancedMesh &&
              Ge.instancingColor === !0 &&
              F.instanceColor === null) ||
            (F.isInstancedMesh &&
              Ge.instancingColor === !1 &&
              F.instanceColor !== null) ||
            (F.isInstancedMesh &&
              Ge.instancingMorph === !0 &&
              F.morphTexture === null) ||
            (F.isInstancedMesh &&
              Ge.instancingMorph === !1 &&
              F.morphTexture !== null) ||
            Ge.envMap !== Ie ||
            (H.fog === !0 && Ge.fog !== ge) ||
            (Ge.numClippingPlanes !== void 0 &&
              (Ge.numClippingPlanes !== ce.numPlanes ||
                Ge.numIntersection !== ce.numIntersection)) ||
            Ge.vertexAlphas !== Ye ||
            Ge.vertexTangents !== Oe ||
            Ge.morphTargets !== ze ||
            Ge.morphNormals !== Lt ||
            Ge.morphColors !== Un ||
            Ge.toneMapping !== Gt ||
            (Ze.isWebGL2 === !0 && Ge.morphTargetsCount !== wt)) &&
          (xt = !0)
        : ((xt = !0), (Ge.__version = H.version));
      let ps = Ge.currentProgram;
      xt === !0 && (ps = Dc(H, k, F));
      let Uv = !1,
        Uo = !1,
        Ch = !1;
      const nn = ps.getUniforms(),
        ms = Ge.uniforms;
      if (
        (Ne.useProgram(ps.program) && ((Uv = !0), (Uo = !0), (Ch = !0)),
        H.id !== P && ((P = H.id), (Uo = !0)),
        Uv || G !== M)
      ) {
        nn.setValue(I, "projectionMatrix", M.projectionMatrix),
          nn.setValue(I, "viewMatrix", M.matrixWorldInverse);
        const Yn = nn.map.cameraPosition;
        Yn !== void 0 &&
          Yn.setValue(I, _e.setFromMatrixPosition(M.matrixWorld)),
          Ze.logarithmicDepthBuffer &&
            nn.setValue(
              I,
              "logDepthBufFC",
              2 / (Math.log(M.far + 1) / Math.LN2)
            ),
          (H.isMeshPhongMaterial ||
            H.isMeshToonMaterial ||
            H.isMeshLambertMaterial ||
            H.isMeshBasicMaterial ||
            H.isMeshStandardMaterial ||
            H.isShaderMaterial) &&
            nn.setValue(I, "isOrthographic", M.isOrthographicCamera === !0),
          G !== M && ((G = M), (Uo = !0), (Ch = !0));
      }
      if (F.isSkinnedMesh) {
        nn.setOptional(I, F, "bindMatrix"),
          nn.setOptional(I, F, "bindMatrixInverse");
        const Yn = F.skeleton;
        Yn &&
          (Ze.floatVertexTextures
            ? (Yn.boneTexture === null && Yn.computeBoneTexture(),
              nn.setValue(I, "boneTexture", Yn.boneTexture, Ke))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      F.isBatchedMesh &&
        (nn.setOptional(I, F, "batchingTexture"),
        nn.setValue(I, "batchingTexture", F._matricesTexture, Ke));
      const Rh = j.morphAttributes;
      if (
        ((Rh.position !== void 0 ||
          Rh.normal !== void 0 ||
          (Rh.color !== void 0 && Ze.isWebGL2 === !0)) &&
          se.update(F, j, ps),
        (Uo || Ge.receiveShadow !== F.receiveShadow) &&
          ((Ge.receiveShadow = F.receiveShadow),
          nn.setValue(I, "receiveShadow", F.receiveShadow)),
        H.isMeshGouraudMaterial &&
          H.envMap !== null &&
          ((ms.envMap.value = Ie),
          (ms.flipEnvMap.value =
            Ie.isCubeTexture && Ie.isRenderTargetTexture === !1 ? -1 : 1)),
        Uo &&
          (nn.setValue(I, "toneMappingExposure", g.toneMappingExposure),
          Ge.needsLights && jM(ms, Ch),
          ge && H.fog === !0 && ee.refreshFogUniforms(ms, ge),
          ee.refreshMaterialUniforms(ms, H, W, q, he),
          qu.upload(I, kv(Ge), ms, Ke)),
        H.isShaderMaterial &&
          H.uniformsNeedUpdate === !0 &&
          (qu.upload(I, kv(Ge), ms, Ke), (H.uniformsNeedUpdate = !1)),
        H.isSpriteMaterial && nn.setValue(I, "center", F.center),
        nn.setValue(I, "modelViewMatrix", F.modelViewMatrix),
        nn.setValue(I, "normalMatrix", F.normalMatrix),
        nn.setValue(I, "modelMatrix", F.matrixWorld),
        H.isShaderMaterial || H.isRawShaderMaterial)
      ) {
        const Yn = H.uniformsGroups;
        for (let Ph = 0, HM = Yn.length; Ph < HM; Ph++)
          if (Ze.isWebGL2) {
            const Ov = Yn[Ph];
            Se.update(Ov, ps), Se.bind(Ov, ps);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return ps;
    }
    function jM(M, k) {
      (M.ambientLightColor.needsUpdate = k),
        (M.lightProbe.needsUpdate = k),
        (M.directionalLights.needsUpdate = k),
        (M.directionalLightShadows.needsUpdate = k),
        (M.pointLights.needsUpdate = k),
        (M.pointLightShadows.needsUpdate = k),
        (M.spotLights.needsUpdate = k),
        (M.spotLightShadows.needsUpdate = k),
        (M.rectAreaLights.needsUpdate = k),
        (M.hemisphereLights.needsUpdate = k);
    }
    function VM(M) {
      return (
        M.isMeshLambertMaterial ||
        M.isMeshToonMaterial ||
        M.isMeshPhongMaterial ||
        M.isMeshStandardMaterial ||
        M.isShadowMaterial ||
        (M.isShaderMaterial && M.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return T;
    }),
      (this.getActiveMipmapLevel = function () {
        return A;
      }),
      (this.getRenderTarget = function () {
        return b;
      }),
      (this.setRenderTargetTextures = function (M, k, j) {
        (qe.get(M.texture).__webglTexture = k),
          (qe.get(M.depthTexture).__webglTexture = j);
        const H = qe.get(M);
        (H.__hasExternalTextures = !0),
          (H.__autoAllocateDepthBuffer = j === void 0),
          H.__autoAllocateDepthBuffer ||
            (be.has("WEBGL_multisampled_render_to_texture") === !0 &&
              (console.warn(
                "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
              ),
              (H.__useRenderToTexture = !1)));
      }),
      (this.setRenderTargetFramebuffer = function (M, k) {
        const j = qe.get(M);
        (j.__webglFramebuffer = k), (j.__useDefaultFramebuffer = k === void 0);
      }),
      (this.setRenderTarget = function (M, k = 0, j = 0) {
        (b = M), (T = k), (A = j);
        let H = !0,
          F = null,
          ge = !1,
          we = !1;
        if (M) {
          const Ie = qe.get(M);
          Ie.__useDefaultFramebuffer !== void 0
            ? (Ne.bindFramebuffer(I.FRAMEBUFFER, null), (H = !1))
            : Ie.__webglFramebuffer === void 0
            ? Ke.setupRenderTarget(M)
            : Ie.__hasExternalTextures &&
              Ke.rebindTextures(
                M,
                qe.get(M.texture).__webglTexture,
                qe.get(M.depthTexture).__webglTexture
              );
          const Ye = M.texture;
          (Ye.isData3DTexture ||
            Ye.isDataArrayTexture ||
            Ye.isCompressedArrayTexture) &&
            (we = !0);
          const Oe = qe.get(M).__webglFramebuffer;
          M.isWebGLCubeRenderTarget
            ? (Array.isArray(Oe[k]) ? (F = Oe[k][j]) : (F = Oe[k]), (ge = !0))
            : Ze.isWebGL2 && M.samples > 0 && Ke.useMultisampledRTT(M) === !1
            ? (F = qe.get(M).__webglMultisampledFramebuffer)
            : Array.isArray(Oe)
            ? (F = Oe[j])
            : (F = Oe),
            w.copy(M.viewport),
            R.copy(M.scissor),
            (ie = M.scissorTest);
        } else
          w.copy(X).multiplyScalar(W).floor(),
            R.copy(K).multiplyScalar(W).floor(),
            (ie = oe);
        if (
          (Ne.bindFramebuffer(I.FRAMEBUFFER, F) &&
            Ze.drawBuffers &&
            H &&
            Ne.drawBuffers(M, F),
          Ne.viewport(w),
          Ne.scissor(R),
          Ne.setScissorTest(ie),
          ge)
        ) {
          const Ie = qe.get(M.texture);
          I.framebufferTexture2D(
            I.FRAMEBUFFER,
            I.COLOR_ATTACHMENT0,
            I.TEXTURE_CUBE_MAP_POSITIVE_X + k,
            Ie.__webglTexture,
            j
          );
        } else if (we) {
          const Ie = qe.get(M.texture),
            Ye = k || 0;
          I.framebufferTextureLayer(
            I.FRAMEBUFFER,
            I.COLOR_ATTACHMENT0,
            Ie.__webglTexture,
            j || 0,
            Ye
          );
        }
        P = -1;
      }),
      (this.readRenderTargetPixels = function (M, k, j, H, F, ge, we) {
        if (!(M && M.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Pe = qe.get(M).__webglFramebuffer;
        if ((M.isWebGLCubeRenderTarget && we !== void 0 && (Pe = Pe[we]), Pe)) {
          Ne.bindFramebuffer(I.FRAMEBUFFER, Pe);
          try {
            const Ie = M.texture,
              Ye = Ie.format,
              Oe = Ie.type;
            if (
              Ye !== _i &&
              Te.convert(Ye) !==
                I.getParameter(I.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const ze =
              Oe === hc &&
              (be.has("EXT_color_buffer_half_float") ||
                (Ze.isWebGL2 && be.has("EXT_color_buffer_float")));
            if (
              Oe !== Jr &&
              Te.convert(Oe) !==
                I.getParameter(I.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                Oe === ir &&
                (Ze.isWebGL2 ||
                  be.has("OES_texture_float") ||
                  be.has("WEBGL_color_buffer_float"))
              ) &&
              !ze
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            k >= 0 &&
              k <= M.width - H &&
              j >= 0 &&
              j <= M.height - F &&
              I.readPixels(k, j, H, F, Te.convert(Ye), Te.convert(Oe), ge);
          } finally {
            const Ie = b !== null ? qe.get(b).__webglFramebuffer : null;
            Ne.bindFramebuffer(I.FRAMEBUFFER, Ie);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (M, k, j = 0) {
        const H = Math.pow(2, -j),
          F = Math.floor(k.image.width * H),
          ge = Math.floor(k.image.height * H);
        Ke.setTexture2D(k, 0),
          I.copyTexSubImage2D(I.TEXTURE_2D, j, 0, 0, M.x, M.y, F, ge),
          Ne.unbindTexture();
      }),
      (this.copyTextureToTexture = function (M, k, j, H = 0) {
        const F = k.image.width,
          ge = k.image.height,
          we = Te.convert(j.format),
          Pe = Te.convert(j.type);
        Ke.setTexture2D(j, 0),
          I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, j.flipY),
          I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, j.premultiplyAlpha),
          I.pixelStorei(I.UNPACK_ALIGNMENT, j.unpackAlignment),
          k.isDataTexture
            ? I.texSubImage2D(
                I.TEXTURE_2D,
                H,
                M.x,
                M.y,
                F,
                ge,
                we,
                Pe,
                k.image.data
              )
            : k.isCompressedTexture
            ? I.compressedTexSubImage2D(
                I.TEXTURE_2D,
                H,
                M.x,
                M.y,
                k.mipmaps[0].width,
                k.mipmaps[0].height,
                we,
                k.mipmaps[0].data
              )
            : I.texSubImage2D(I.TEXTURE_2D, H, M.x, M.y, we, Pe, k.image),
          H === 0 && j.generateMipmaps && I.generateMipmap(I.TEXTURE_2D),
          Ne.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (M, k, j, H, F = 0) {
        if (g.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const ge = Math.round(M.max.x - M.min.x),
          we = Math.round(M.max.y - M.min.y),
          Pe = M.max.z - M.min.z + 1,
          Ie = Te.convert(H.format),
          Ye = Te.convert(H.type);
        let Oe;
        if (H.isData3DTexture) Ke.setTexture3D(H, 0), (Oe = I.TEXTURE_3D);
        else if (H.isDataArrayTexture || H.isCompressedArrayTexture)
          Ke.setTexture2DArray(H, 0), (Oe = I.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        I.pixelStorei(I.UNPACK_FLIP_Y_WEBGL, H.flipY),
          I.pixelStorei(I.UNPACK_PREMULTIPLY_ALPHA_WEBGL, H.premultiplyAlpha),
          I.pixelStorei(I.UNPACK_ALIGNMENT, H.unpackAlignment);
        const ze = I.getParameter(I.UNPACK_ROW_LENGTH),
          Lt = I.getParameter(I.UNPACK_IMAGE_HEIGHT),
          Un = I.getParameter(I.UNPACK_SKIP_PIXELS),
          Gt = I.getParameter(I.UNPACK_SKIP_ROWS),
          Gi = I.getParameter(I.UNPACK_SKIP_IMAGES),
          wt = j.isCompressedTexture ? j.mipmaps[F] : j.image;
        I.pixelStorei(I.UNPACK_ROW_LENGTH, wt.width),
          I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, wt.height),
          I.pixelStorei(I.UNPACK_SKIP_PIXELS, M.min.x),
          I.pixelStorei(I.UNPACK_SKIP_ROWS, M.min.y),
          I.pixelStorei(I.UNPACK_SKIP_IMAGES, M.min.z),
          j.isDataTexture || j.isData3DTexture
            ? I.texSubImage3D(Oe, F, k.x, k.y, k.z, ge, we, Pe, Ie, Ye, wt.data)
            : H.isCompressedArrayTexture
            ? I.compressedTexSubImage3D(
                Oe,
                F,
                k.x,
                k.y,
                k.z,
                ge,
                we,
                Pe,
                Ie,
                wt.data
              )
            : I.texSubImage3D(Oe, F, k.x, k.y, k.z, ge, we, Pe, Ie, Ye, wt),
          I.pixelStorei(I.UNPACK_ROW_LENGTH, ze),
          I.pixelStorei(I.UNPACK_IMAGE_HEIGHT, Lt),
          I.pixelStorei(I.UNPACK_SKIP_PIXELS, Un),
          I.pixelStorei(I.UNPACK_SKIP_ROWS, Gt),
          I.pixelStorei(I.UNPACK_SKIP_IMAGES, Gi),
          F === 0 && H.generateMipmaps && I.generateMipmap(Oe),
          Ne.unbindTexture();
      }),
      (this.initTexture = function (M) {
        M.isCubeTexture
          ? Ke.setTextureCube(M, 0)
          : M.isData3DTexture
          ? Ke.setTexture3D(M, 0)
          : M.isDataArrayTexture || M.isCompressedArrayTexture
          ? Ke.setTexture2DArray(M, 0)
          : Ke.setTexture2D(M, 0),
          Ne.unbindTexture();
      }),
      (this.resetState = function () {
        (T = 0), (A = 0), (b = null), Ne.reset(), xe.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", {
            detail: this,
          })
        );
  }
  get coordinateSystem() {
    return ar;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(e) {
    this._outputColorSpace = e;
    const n = this.getContext();
    (n.drawingBufferColorSpace = e === Pv ? "display-p3" : "srgb"),
      (n.unpackColorSpace =
        dt.workingColorSpace === Eh ? "display-p3" : "srgb");
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
class Oj extends OM {}
Oj.prototype.isWebGL1Renderer = !0;
class Fj extends In {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.backgroundRotation = new gr()),
      (this.environmentRotation = new gr()),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", {
            detail: this,
          })
        );
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      this.backgroundRotation.copy(e.backgroundRotation),
      this.environmentRotation.copy(e.environmentRotation),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const n = super.toJSON(e);
    return (
      this.fog !== null && (n.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (n.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (n.object.backgroundIntensity = this.backgroundIntensity),
      (n.object.backgroundRotation = this.backgroundRotation.toArray()),
      (n.object.environmentRotation = this.environmentRotation.toArray()),
      n
    );
  }
}
class FM extends Pc {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new ct(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const pS = new Ft(),
  Hm = new xM(),
  Cu = new Th(),
  Ru = new z();
class Bj extends In {
  constructor(e = new _r(), n = new FM()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = n),
      this.updateMorphTargets();
  }
  copy(e, n) {
    return (
      super.copy(e, n),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, n) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      a = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Cu.copy(i.boundingSphere),
      Cu.applyMatrix4(r),
      (Cu.radius += s),
      e.ray.intersectsSphere(Cu) === !1)
    )
      return;
    pS.copy(r).invert(), Hm.copy(e.ray).applyMatrix4(pS);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = i.index,
      d = i.attributes.position;
    if (c !== null) {
      const h = Math.max(0, a.start),
        p = Math.min(c.count, a.start + a.count);
      for (let v = h, x = p; v < x; v++) {
        const m = c.getX(v);
        Ru.fromBufferAttribute(d, m), mS(Ru, m, l, r, e, n, this);
      }
    } else {
      const h = Math.max(0, a.start),
        p = Math.min(d.count, a.start + a.count);
      for (let v = h, x = p; v < x; v++)
        Ru.fromBufferAttribute(d, v), mS(Ru, v, l, r, e, n, this);
    }
  }
  updateMorphTargets() {
    const n = this.geometry.morphAttributes,
      i = Object.keys(n);
    if (i.length > 0) {
      const r = n[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = r.length; s < a; s++) {
          const o = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
function mS(t, e, n, i, r, s, a) {
  const o = Hm.distanceSqToPoint(t);
  if (o < n) {
    const l = new z();
    Hm.closestPointToPoint(t, l), l.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a,
    });
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", {
      detail: {
        revision: Cv,
      },
    })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Cv));
const zj = () => {
    const t = O.useRef(null),
      e = O.useRef(null),
      n = O.useRef(null),
      i = O.useRef(null),
      r = O.useRef(null);
    return (
      O.useEffect(() => {
        if (!t.current) return;
        e.current = new Fj();
        const s = window.innerWidth / window.innerHeight;
        (n.current = new ti(75, s, 0.1, 1e3)),
          (n.current.position.z = 50),
          (i.current = new OM({
            antialias: !0,
            alpha: !0,
            canvas: t.current.querySelector("canvas") || void 0,
          })),
          i.current.setPixelRatio(window.devicePixelRatio),
          i.current.setSize(window.innerWidth, window.innerHeight),
          i.current.setClearColor(0, 0),
          t.current.querySelector("canvas") ||
            t.current.appendChild(i.current.domElement);
        const a = new _r(),
          o = 2e3,
          l = new Float32Array(o * 3);
        for (let p = 0; p < o * 3; p += 3) {
          const x = Math.random() * Math.PI * 2,
            m = Math.random() * Math.PI;
          (l[p] = 50 * Math.sin(m) * Math.cos(x)),
            (l[p + 1] = 50 * Math.sin(m) * Math.sin(x)),
            (l[p + 2] = 50 * Math.cos(m));
        }
        a.setAttribute("position", new Ei(l, 3));
        const c = new FM({
          size: 0.2,
          sizeAttenuation: !0,
          color: 2447439,
          transparent: !0,
          opacity: 0.8,
          blending: Nm,
        });
        (r.current = new Bj(a, c)), e.current.add(r.current);
        let u;
        const d = () => {
          !r.current ||
            !i.current ||
            !e.current ||
            !n.current ||
            ((r.current.rotation.x += 5e-4),
            (r.current.rotation.y += 5e-4),
            i.current.render(e.current, n.current),
            (u = requestAnimationFrame(d)));
        };
        d();
        const h = () => {
          if (!n.current || !i.current) return;
          const p = window.innerWidth,
            v = window.innerHeight;
          (n.current.aspect = p / v),
            n.current.updateProjectionMatrix(),
            i.current.setSize(p, v);
        };
        return (
          window.addEventListener("resize", h),
          () => {
            var p;
            window.removeEventListener("resize", h),
              cancelAnimationFrame(u),
              t.current &&
                i.current &&
                t.current.removeChild(i.current.domElement),
              a.dispose(),
              c.dispose(),
              (p = i.current) == null || p.dispose();
          }
        );
      }, []),
      _.jsx("div", {
        ref: t,
        className:
          "absolute inset-0 -z-10 bg-gradient-to-b from-verde/5 to-transparent",
        style: {
          mixBlendMode: "screen",
        },
      })
    );
  },
  jj = () => {
    const [t, e] = Cd({
        triggerOnce: !0,
        threshold: 0.1,
      }),
      [n, i] = Cd({
        triggerOnce: !0,
        threshold: 0.1,
      }),
      r = {
        hidden: {
          opacity: 0,
          y: 20,
        },
        visible: {
          opacity: 1,
          y: 0,
        },
      };
    return _.jsxs("div", {
      className: "bg-gradient-to-b from-marfil to-verde/5",
      children: [
        _.jsxs("section", {
          ref: t,
          className: "relative min-h-screen flex items-center justify-center",
          children: [
            _.jsx("div", {
              className: "absolute inset-0 bg-cover bg-center bg-no-repeat z-0",
              style: {
                backgroundImage: 'url("https://imgur.com/K9kyHH0.jpg")',
                opacity: 0.6,
              },
            }),
            _.jsx("div", {
              className: "absolute inset-0 bg-medianoche/60 z-0",
            }),
            _.jsx(zj, {}),
            _.jsx(Me.div, {
              className: "container relative z-10",
              initial: "hidden",
              animate: e ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
              },
              children: _.jsxs("div", {
                className: "text-center",
                children: [
                  _.jsx("h1", {
                    className:
                      "text-6xl md:text-7xl font-heading font-bold text-marfil mb-6",
                    children: "Origen del Torneo",
                  }),
                  _.jsx("p", {
                    className:
                      "text-xl md:text-2xl text-marfil/90 max-w-3xl mx-auto",
                    children: "Una iniciativa que transforma el padel",
                  }),
                ],
              }),
            }),
          ],
        }),
        _.jsxs("div", {
          ref: n,
          className: "container py-24",
          children: [
            _.jsx(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 0.2,
              },
              children: _.jsxs("div", {
                className: "flex flex-col md:flex-row items-center gap-12",
                children: [
                  _.jsx("div", {
                    className: "md:w-1/2",
                    children: _.jsxs("div", {
                      className:
                        "bg-gradient-to-br from-verde/10 to-beige/10 p-12 rounded-2xl shadow-xl",
                      children: [
                        _.jsx("h2", {
                          className:
                            "text-4xl font-heading font-bold text-verde mb-8",
                          children: "La Historia Detrs del Torneo",
                        }),
                        _.jsxs("div", {
                          className: "space-y-6 text-lg text-medianoche/80",
                          children: [
                            _.jsx("p", {
                              children:
                                "Padeln nace de la pasin por el deporte y la visin de tres jvenes emprendedores que identificaron la necesidad de elevar el nivel de los torneos de padel.",
                            }),
                            _.jsx("p", {
                              children:
                                "Inspirados por los grandes torneos internacionales y la creciente popularidad del padel entre los jvenes, decidimos crear un evento que no solo destacara por su nivel competitivo, sino tambin por su capacidad de generar conexiones significativas.",
                            }),
                          ],
                        }),
                      ],
                    }),
                  }),
                  _.jsx("div", {
                    className:
                      "md:w-1/2 flex items-center justify-center p-12 bg-gradient-to-br from-verde/5 to-beige/5 rounded-2xl",
                    children: _.jsx("img", {
                      src: "https://imgur.com/TGi4zvB.png",
                      alt: "Padeln Logo",
                      className: "w-full max-w-[300px] h-auto object-contain",
                    }),
                  }),
                ],
              }),
            }),
            _.jsx(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 0.4,
              },
              children: _.jsxs("div", {
                className:
                  "flex flex-col md:flex-row-reverse items-center gap-12",
                children: [
                  _.jsx("div", {
                    className: "md:w-1/2",
                    children: _.jsx("div", {
                      className: "grid grid-cols-1 sm:grid-cols-2 gap-6",
                      children: [
                        {
                          icon: _.jsx(jE, {
                            className: "w-8 h-8",
                          }),
                          title: "Excelencia",
                          description: "Buscamos la perfeccin en cada detalle",
                          bgColor: "bg-gradient-to-br from-verde/20 to-verde/5",
                        },
                        {
                          icon: _.jsx(di, {
                            className: "w-8 h-8",
                          }),
                          title: "Innovacin",
                          description: "Reimaginamos la experiencia del torneo",
                          bgColor: "bg-gradient-to-br from-beige/20 to-beige/5",
                        },
                        {
                          icon: _.jsx(VE, {
                            className: "w-8 h-8",
                          }),
                          title: "Pasin",
                          description: "Ponemos el corazn en cada aspecto",
                          bgColor:
                            "bg-gradient-to-br from-verde/15 to-beige/15",
                        },
                        {
                          icon: _.jsx(zg, {
                            className: "w-8 h-8",
                          }),
                          title: "Dinamismo",
                          description: "Energa y movimiento constante",
                          bgColor:
                            "bg-gradient-to-br from-beige/15 to-verde/15",
                        },
                      ].map((s, a) =>
                        _.jsxs(
                          Me.div,
                          {
                            className: `${s.bgColor} p-6 rounded-xl shadow-lg text-center transform hover:scale-105 transition-transform duration-300 h-full flex flex-col items-center justify-center`,
                            whileHover: {
                              y: -5,
                            },
                            children: [
                              _.jsx("div", {
                                className:
                                  "w-12 h-12 bg-marfil rounded-full flex items-center justify-center mx-auto mb-4",
                                children: _.jsx("div", {
                                  className: "text-verde",
                                  children: s.icon,
                                }),
                              }),
                              _.jsx("h3", {
                                className:
                                  "text-lg font-semibold mb-2 text-verde",
                                children: s.title,
                              }),
                              _.jsx("p", {
                                className: "text-sm text-medianoche/80",
                                children: s.description,
                              }),
                            ],
                          },
                          a
                        )
                      ),
                    }),
                  }),
                  _.jsxs("div", {
                    className: "md:w-1/2 flex flex-col justify-center",
                    children: [
                      _.jsx("h2", {
                        className:
                          "text-4xl font-heading font-bold text-verde mb-8",
                        children: "Nuestros Valores",
                      }),
                      _.jsx("p", {
                        className: "text-lg text-medianoche/80 mb-8",
                        children:
                          "En Padeln, nuestros valores son el pilar fundamental que gua cada decisin y accin. Buscamos la excelencia en cada detalle, innovamos constantemente para ofrecer experiencias nicas, y ponemos toda nuestra pasin en crear un torneo excepcional.",
                      }),
                      _.jsx("img", {
                        src: "https://imgur.com/NC7U8MJ.jpg",
                        alt: "Valores del Torneo",
                        className:
                          "rounded-2xl shadow-xl w-full h-[300px] object-cover",
                      }),
                    ],
                  }),
                ],
              }),
            }),
            _.jsxs(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 0.6,
              },
              children: [
                _.jsx("h2", {
                  className:
                    "text-4xl font-heading font-bold text-verde mb-12 text-center",
                  children: "Comit Organizador",
                }),
                _.jsx("div", {
                  className: "grid grid-cols-1 md:grid-cols-3 gap-8",
                  children: [
                    {
                      name: "Alejandro Aceves Gmez",
                      image: "https://imgur.com/iqkSb7t.jpg",
                      bgColor: "bg-gradient-to-br from-verde/20 to-beige/5",
                      objectPosition: "top",
                    },
                    {
                      name: "Sebastin Salido Gmez-Ibarra",
                      image: "https://imgur.com/f9smK0k.jpg",
                      bgColor: "bg-gradient-to-br from-beige/20 to-verde/5",
                      objectPosition: "top",
                    },
                    {
                      name: "Carlos Manuel Saucedo De La Madrid",
                      image: "https://imgur.com/BnaovUW.jpg",
                      bgColor: "bg-gradient-to-br from-verde/15 to-beige/15",
                      objectPosition: "center",
                    },
                  ].map((s, a) =>
                    _.jsxs(
                      Me.div,
                      {
                        className: `${s.bgColor} p-8 rounded-xl shadow-lg transform hover:scale-105 transition-transform duration-300`,
                        whileHover: {
                          y: -5,
                        },
                        children: [
                          _.jsx("div", {
                            className:
                              "w-32 h-32 rounded-full mb-6 mx-auto overflow-hidden",
                            children: _.jsx("img", {
                              src: s.image,
                              alt: s.name,
                              className: "w-full h-full object-cover",
                              style: {
                                objectPosition: s.objectPosition,
                              },
                            }),
                          }),
                          _.jsx("h3", {
                            className:
                              "text-lg font-semibold text-center text-verde",
                            children: s.name,
                          }),
                        ],
                      },
                      a
                    )
                  ),
                }),
              ],
            }),
            _.jsx(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 0.8,
              },
              children: _.jsxs("div", {
                className: "flex flex-col md:flex-row items-center gap-12",
                children: [
                  _.jsxs("div", {
                    className: "md:w-1/2",
                    children: [
                      _.jsx("h2", {
                        className:
                          "text-4xl font-heading font-bold text-verde mb-8",
                        children: "Nuestra Visin",
                      }),
                      _.jsx("div", {
                        className: "space-y-8",
                        children: [
                          {
                            icon: _.jsx(GE, {
                              className: "w-8 h-8 text-verde",
                            }),
                            title: "Excelencia Deportiva",
                            description:
                              "Elevar el nivel competitivo del padel, creando un torneo de referencia nacional",
                          },
                          {
                            icon: _.jsx(TR, {
                              className: "w-8 h-8 text-verde",
                            }),
                            title: "Impacto Social",
                            description:
                              "Fomentar la comunidad y el networking a travs del deporte, creando conexiones duraderas",
                          },
                        ].map((s, a) =>
                          _.jsxs(
                            "div",
                            {
                              className: "flex items-start gap-4",
                              children: [
                                _.jsx("div", {
                                  className:
                                    "w-12 h-12 bg-verde/10 rounded-full flex items-center justify-center flex-shrink-0",
                                  children: s.icon,
                                }),
                                _.jsxs("div", {
                                  children: [
                                    _.jsx("h3", {
                                      className:
                                        "text-xl font-semibold mb-2 text-verde",
                                      children: s.title,
                                    }),
                                    _.jsx("p", {
                                      className: "text-medianoche/80",
                                      children: s.description,
                                    }),
                                  ],
                                }),
                              ],
                            },
                            a
                          )
                        ),
                      }),
                    ],
                  }),
                  _.jsx("div", {
                    className: "md:w-1/2",
                    children: _.jsx("img", {
                      src: "https://imgur.com/ZJUZiAq.jpg",
                      alt: "Visin del Torneo",
                      className:
                        "rounded-2xl shadow-xl w-full h-[400px] object-cover",
                    }),
                  }),
                ],
              }),
            }),
            _.jsx(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 1,
              },
              children: _.jsxs("div", {
                className:
                  "flex flex-col md:flex-row-reverse items-center gap-12",
                children: [
                  _.jsx("div", {
                    className: "md:w-1/2",
                    children: _.jsxs("div", {
                      className:
                        "bg-gradient-to-br from-verde/10 to-beige/10 p-12 rounded-2xl shadow-xl",
                      children: [
                        _.jsx("blockquote", {
                          className:
                            "text-3xl font-heading italic text-verde mb-6",
                          children: '" "',
                        }),
                        _.jsx("cite", {
                          className:
                            "text-xl text-medianoche/80 font-body block text-right",
                          children: " Padeln",
                        }),
                      ],
                    }),
                  }),
                  _.jsx("div", {
                    className: "md:w-1/2",
                    children: _.jsx("img", {
                      src: "https://imgur.com/35rmI5v.jpg",
                      alt: "Ambiente del Torneo",
                      className:
                        "rounded-2xl shadow-xl w-full h-[400px] object-cover",
                    }),
                  }),
                ],
              }),
            }),
            _.jsx(Me.section, {
              className: "mb-32",
              initial: "hidden",
              animate: i ? "visible" : "hidden",
              variants: r,
              transition: {
                duration: 0.8,
                delay: 1.2,
              },
              children: _.jsx("div", {
                className:
                  "bg-gradient-to-br from-verde/10 to-beige/10 p-12 rounded-2xl shadow-xl border border-verde/20",
                children: _.jsxs("div", {
                  className: "max-w-4xl mx-auto",
                  children: [
                    _.jsx("h2", {
                      className:
                        "text-4xl font-heading font-bold text-verde mb-6 text-center",
                      children: "Haz Crecer Tu Marca Con Nosotros",
                    }),
                    _.jsx("p", {
                      className: "text-xl text-medianoche/80 mb-12 text-center",
                      children:
                        "nete como patrocinador oficial y forma parte de la nueva era del padel",
                    }),
                    _.jsxs("div", {
                      className: "grid grid-cols-1 md:grid-cols-2 gap-8 mb-12",
                      children: [
                        _.jsxs(Me.div, {
                          className:
                            "bg-marfil/5 backdrop-blur-sm p-8 rounded-xl border border-verde/10",
                          whileHover: {
                            scale: 1.02,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx("h3", {
                              className:
                                "text-xl font-semibold text-verde mb-4",
                              children: "Beneficios Premium",
                            }),
                            _.jsxs("ul", {
                              className: "space-y-3",
                              children: [
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children:
                                        "Visibilidad destacada en el evento",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children: "Promocin en redes sociales",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children:
                                        "Menciones exclusivas durante el torneo",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children:
                                        "Espacios publicitarios premium",
                                    }),
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                        _.jsxs(Me.div, {
                          className:
                            "bg-marfil/5 backdrop-blur-sm p-8 rounded-xl border border-verde/10",
                          whileHover: {
                            scale: 1.02,
                          },
                          transition: {
                            duration: 0.2,
                          },
                          children: [
                            _.jsx("h3", {
                              className:
                                "text-xl font-semibold text-verde mb-4",
                              children: "Alcance Garantizado",
                            }),
                            _.jsxs("ul", {
                              className: "space-y-3",
                              children: [
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children: "+300 asistentes presenciales",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children: "+100k alcance en Instagram",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children: "Cobertura en medios locales",
                                    }),
                                  ],
                                }),
                                _.jsxs("li", {
                                  className:
                                    "flex items-center gap-3 text-medianoche/80",
                                  children: [
                                    _.jsx(di, {
                                      className:
                                        "w-5 h-5 text-verde flex-shrink-0",
                                    }),
                                    _.jsx("span", {
                                      children: "Networking con marcas premium",
                                    }),
                                  ],
                                }),
                              ],
                            }),
                          ],
                        }),
                      ],
                    }),
                    _.jsxs("div", {
                      className: "text-center",
                      children: [
                        _.jsx("p", {
                          className: "text-lg text-medianoche/80 mb-8",
                          children:
                            "Descubre cmo tu marca puede brillar en el evento de padel ms exclusivo",
                        }),
                        _.jsx(Me.a, {
                          href: "https://wa.me/5213319426363",
                          target: "_blank",
                          rel: "noopener noreferrer",
                          className:
                            "inline-flex items-center px-8 py-4 text-lg font-medium text-marfil bg-verde rounded-lg hover:bg-beige transition-colors duration-300",
                          whileHover: {
                            scale: 1.05,
                          },
                          whileTap: {
                            scale: 0.95,
                          },
                          children: "Contacta a Nuestro Equipo Comercial",
                        }),
                      ],
                    }),
                  ],
                }),
              }),
            }),
          ],
        }),
      ],
    });
  },
  Vj = () =>
    _.jsx("footer", {
      className: "bg-verde text-marfil",
      children: _.jsxs("div", {
        className: "container py-12",
        children: [
          _.jsx("div", {
            children: _.jsxs("div", {
              children: [
                _.jsx("h3", {
                  className: "text-xl font-bold mb-4 text-oro",
                  children: "Padeln",
                }),
                _.jsx("p", {
                  className: "text-marfil/80 mb-4",
                  children: " ",
                }),
              ],
            }),
          }),
          _.jsx("div", {
            className:
              "mt-12 pt-6 border-t border-marfil/20 text-center text-marfil/60 text-sm",
            children: _.jsxs("p", {
              children: [
                " ",
                new Date().getFullYear(),
                " Padeln. Todos los derechos reservados.",
              ],
            }),
          }),
        ],
      }),
    });
function Hj() {
  const { pathname: t } = yc();
  return (
    O.useEffect(() => {
      window.scrollTo(0, 0);
    }, [t]),
    null
  );
}
function Gj() {
  return (
    O.useEffect(() => {
      document.title = "Padeln";
    }, []),
    _.jsxs(gR, {
      children: [
        _.jsx(Hj, {}),
        _.jsxs("div", {
          className: "flex flex-col min-h-screen",
          children: [
            _.jsx(LR, {}),
            _.jsxs(cR, {
              children: [
                _.jsx(rl, {
                  path: "/",
                  element: _.jsxs(_.Fragment, {
                    children: [_.jsx(UD, {}), _.jsx($D, {})],
                  }),
                }),
                _.jsx(rl, {
                  path: "/registro",
                  element: _.jsx(xU, {}),
                }),
                _.jsx(rl, {
                  path: "/patrocinadores",
                  element: _.jsx(wU, {}),
                }),
                _.jsx(rl, {
                  path: "/acerca-de",
                  element: _.jsx(jj, {}),
                }),
              ],
            }),
            _.jsx(Vj, {}),
          ],
        }),
      ],
    })
  );
}
CE(document.getElementById("root")).render(
  _.jsx(O.StrictMode, {
    children: _.jsx(Gj, {}),
  })
);
export { WM as g };
